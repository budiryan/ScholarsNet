[{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9301109v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Andrew W. Smith"
    ], 
    "lead_author": "Andrew W. Smith", 
    "arxiv-id": "cs/9301109v1", 
    "title": "Logic Programming, Functional Programming, and Inductive Definitions", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "An attempt at unifying logic and functional programming is reported. As a\nstarting point, we take the view that \"logic programs\" are not about logic but\nconstitute inductive definitions of sets and relations. A skeletal language\ndesign based on these considerations is sketched and a prototype implementation\ndiscussed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9301109v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Andrew W. Smith"
    ], 
    "lead_author": "Andrew W. Smith", 
    "arxiv-id": "cs/9301109v1", 
    "title": "Logic Programming, Functional Programming, and Inductive Definitions", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "An attempt at unifying logic and functional programming is reported. As a\nstarting point, we take the view that \"logic programs\" are not about logic but\nconstitute inductive definitions of sets and relations. A skeletal language\ndesign based on these considerations is sketched and a prototype implementation\ndiscussed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9301109v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Andrew W. Smith"
    ], 
    "lead_author": "Andrew W. Smith", 
    "arxiv-id": "cs/9301109v1", 
    "title": "Logic Programming, Functional Programming, and Inductive Definitions", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "An attempt at unifying logic and functional programming is reported. As a\nstarting point, we take the view that \"logic programs\" are not about logic but\nconstitute inductive definitions of sets and relations. A skeletal language\ndesign based on these considerations is sketched and a prototype implementation\ndiscussed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9301109v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Andrew W. Smith"
    ], 
    "lead_author": "Andrew W. Smith", 
    "arxiv-id": "cs/9301109v1", 
    "title": "Logic Programming, Functional Programming, and Inductive Definitions", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "An attempt at unifying logic and functional programming is reported. As a\nstarting point, we take the view that \"logic programs\" are not about logic but\nconstitute inductive definitions of sets and relations. A skeletal language\ndesign based on these considerations is sketched and a prototype implementation\ndiscussed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9301109v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Andrew W. Smith"
    ], 
    "lead_author": "Andrew W. Smith", 
    "arxiv-id": "cs/9301109v1", 
    "title": "Logic Programming, Functional Programming, and Inductive Definitions", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "An attempt at unifying logic and functional programming is reported. As a\nstarting point, we take the view that \"logic programs\" are not about logic but\nconstitute inductive definitions of sets and relations. A skeletal language\ndesign based on these considerations is sketched and a prototype implementation\ndiscussed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9301109v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Andrew W. Smith"
    ], 
    "lead_author": "Andrew W. Smith", 
    "arxiv-id": "cs/9301109v1", 
    "title": "Logic Programming, Functional Programming, and Inductive Definitions", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "An attempt at unifying logic and functional programming is reported. As a\nstarting point, we take the view that \"logic programs\" are not about logic but\nconstitute inductive definitions of sets and relations. A skeletal language\ndesign based on these considerations is sketched and a prototype implementation\ndiscussed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9301109v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Andrew W. Smith"
    ], 
    "lead_author": "Andrew W. Smith", 
    "arxiv-id": "cs/9301109v1", 
    "title": "Logic Programming, Functional Programming, and Inductive Definitions", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "An attempt at unifying logic and functional programming is reported. As a\nstarting point, we take the view that \"logic programs\" are not about logic but\nconstitute inductive definitions of sets and relations. A skeletal language\ndesign based on these considerations is sketched and a prototype implementation\ndiscussed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9301109v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Andrew W. Smith"
    ], 
    "lead_author": "Andrew W. Smith", 
    "arxiv-id": "cs/9301109v1", 
    "title": "Logic Programming, Functional Programming, and Inductive Definitions", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "An attempt at unifying logic and functional programming is reported. As a\nstarting point, we take the view that \"logic programs\" are not about logic but\nconstitute inductive definitions of sets and relations. A skeletal language\ndesign based on these considerations is sketched and a prototype implementation\ndiscussed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9301109v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Andrew W. Smith"
    ], 
    "lead_author": "Andrew W. Smith", 
    "arxiv-id": "cs/9301109v1", 
    "title": "Logic Programming, Functional Programming, and Inductive Definitions", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "An attempt at unifying logic and functional programming is reported. As a\nstarting point, we take the view that \"logic programs\" are not about logic but\nconstitute inductive definitions of sets and relations. A skeletal language\ndesign based on these considerations is sketched and a prototype implementation\ndiscussed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9301109v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Andrew W. Smith"
    ], 
    "lead_author": "Andrew W. Smith", 
    "arxiv-id": "cs/9301109v1", 
    "title": "Logic Programming, Functional Programming, and Inductive Definitions", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "An attempt at unifying logic and functional programming is reported. As a\nstarting point, we take the view that \"logic programs\" are not about logic but\nconstitute inductive definitions of sets and relations. A skeletal language\ndesign based on these considerations is sketched and a prototype implementation\ndiscussed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9301109v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Andrew W. Smith"
    ], 
    "lead_author": "Andrew W. Smith", 
    "arxiv-id": "cs/9301109v1", 
    "title": "Logic Programming, Functional Programming, and Inductive Definitions", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "An attempt at unifying logic and functional programming is reported. As a\nstarting point, we take the view that \"logic programs\" are not about logic but\nconstitute inductive definitions of sets and relations. A skeletal language\ndesign based on these considerations is sketched and a prototype implementation\ndiscussed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9301109v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Andrew W. Smith"
    ], 
    "lead_author": "Andrew W. Smith", 
    "arxiv-id": "cs/9301109v1", 
    "title": "Logic Programming, Functional Programming, and Inductive Definitions", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "An attempt at unifying logic and functional programming is reported. As a\nstarting point, we take the view that \"logic programs\" are not about logic but\nconstitute inductive definitions of sets and relations. A skeletal language\ndesign based on these considerations is sketched and a prototype implementation\ndiscussed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9301109v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Andrew W. Smith"
    ], 
    "lead_author": "Andrew W. Smith", 
    "arxiv-id": "cs/9301109v1", 
    "title": "Logic Programming, Functional Programming, and Inductive Definitions", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "An attempt at unifying logic and functional programming is reported. As a\nstarting point, we take the view that \"logic programs\" are not about logic but\nconstitute inductive definitions of sets and relations. A skeletal language\ndesign based on these considerations is sketched and a prototype implementation\ndiscussed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9301109v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Andrew W. Smith"
    ], 
    "lead_author": "Andrew W. Smith", 
    "arxiv-id": "cs/9301109v1", 
    "title": "Logic Programming, Functional Programming, and Inductive Definitions", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "An attempt at unifying logic and functional programming is reported. As a\nstarting point, we take the view that \"logic programs\" are not about logic but\nconstitute inductive definitions of sets and relations. A skeletal language\ndesign based on these considerations is sketched and a prototype implementation\ndiscussed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9301109v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Andrew W. Smith"
    ], 
    "lead_author": "Andrew W. Smith", 
    "arxiv-id": "cs/9301109v1", 
    "title": "Logic Programming, Functional Programming, and Inductive Definitions", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "An attempt at unifying logic and functional programming is reported. As a\nstarting point, we take the view that \"logic programs\" are not about logic but\nconstitute inductive definitions of sets and relations. A skeletal language\ndesign based on these considerations is sketched and a prototype implementation\ndiscussed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9301109v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Andrew W. Smith"
    ], 
    "lead_author": "Andrew W. Smith", 
    "arxiv-id": "cs/9301109v1", 
    "title": "Logic Programming, Functional Programming, and Inductive Definitions", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "An attempt at unifying logic and functional programming is reported. As a\nstarting point, we take the view that \"logic programs\" are not about logic but\nconstitute inductive definitions of sets and relations. A skeletal language\ndesign based on these considerations is sketched and a prototype implementation\ndiscussed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9301109v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Andrew W. Smith"
    ], 
    "lead_author": "Andrew W. Smith", 
    "arxiv-id": "cs/9301109v1", 
    "title": "Logic Programming, Functional Programming, and Inductive Definitions", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "An attempt at unifying logic and functional programming is reported. As a\nstarting point, we take the view that \"logic programs\" are not about logic but\nconstitute inductive definitions of sets and relations. A skeletal language\ndesign based on these considerations is sketched and a prototype implementation\ndiscussed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9301109v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Andrew W. Smith"
    ], 
    "lead_author": "Andrew W. Smith", 
    "arxiv-id": "cs/9301109v1", 
    "title": "Logic Programming, Functional Programming, and Inductive Definitions", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "An attempt at unifying logic and functional programming is reported. As a\nstarting point, we take the view that \"logic programs\" are not about logic but\nconstitute inductive definitions of sets and relations. A skeletal language\ndesign based on these considerations is sketched and a prototype implementation\ndiscussed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9301109v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Andrew W. Smith"
    ], 
    "lead_author": "Andrew W. Smith", 
    "arxiv-id": "cs/9301109v1", 
    "title": "Logic Programming, Functional Programming, and Inductive Definitions", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "An attempt at unifying logic and functional programming is reported. As a\nstarting point, we take the view that \"logic programs\" are not about logic but\nconstitute inductive definitions of sets and relations. A skeletal language\ndesign based on these considerations is sketched and a prototype implementation\ndiscussed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9301109v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Andrew W. Smith"
    ], 
    "lead_author": "Andrew W. Smith", 
    "arxiv-id": "cs/9301109v1", 
    "title": "Logic Programming, Functional Programming, and Inductive Definitions", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "An attempt at unifying logic and functional programming is reported. As a\nstarting point, we take the view that \"logic programs\" are not about logic but\nconstitute inductive definitions of sets and relations. A skeletal language\ndesign based on these considerations is sketched and a prototype implementation\ndiscussed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9301109v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Andrew W. Smith"
    ], 
    "lead_author": "Andrew W. Smith", 
    "arxiv-id": "cs/9301109v1", 
    "title": "Logic Programming, Functional Programming, and Inductive Definitions", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "An attempt at unifying logic and functional programming is reported. As a\nstarting point, we take the view that \"logic programs\" are not about logic but\nconstitute inductive definitions of sets and relations. A skeletal language\ndesign based on these considerations is sketched and a prototype implementation\ndiscussed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9301109v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Andrew W. Smith"
    ], 
    "lead_author": "Andrew W. Smith", 
    "arxiv-id": "cs/9301109v1", 
    "title": "Logic Programming, Functional Programming, and Inductive Definitions", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "An attempt at unifying logic and functional programming is reported. As a\nstarting point, we take the view that \"logic programs\" are not about logic but\nconstitute inductive definitions of sets and relations. A skeletal language\ndesign based on these considerations is sketched and a prototype implementation\ndiscussed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9301109v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Andrew W. Smith"
    ], 
    "lead_author": "Andrew W. Smith", 
    "arxiv-id": "cs/9301109v1", 
    "title": "Logic Programming, Functional Programming, and Inductive Definitions", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "An attempt at unifying logic and functional programming is reported. As a\nstarting point, we take the view that \"logic programs\" are not about logic but\nconstitute inductive definitions of sets and relations. A skeletal language\ndesign based on these considerations is sketched and a prototype implementation\ndiscussed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9301109v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Andrew W. Smith"
    ], 
    "lead_author": "Andrew W. Smith", 
    "arxiv-id": "cs/9301109v1", 
    "title": "Logic Programming, Functional Programming, and Inductive Definitions", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "An attempt at unifying logic and functional programming is reported. As a\nstarting point, we take the view that \"logic programs\" are not about logic but\nconstitute inductive definitions of sets and relations. A skeletal language\ndesign based on these considerations is sketched and a prototype implementation\ndiscussed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9301109v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Andrew W. Smith"
    ], 
    "lead_author": "Andrew W. Smith", 
    "arxiv-id": "cs/9301109v1", 
    "title": "Logic Programming, Functional Programming, and Inductive Definitions", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "An attempt at unifying logic and functional programming is reported. As a\nstarting point, we take the view that \"logic programs\" are not about logic but\nconstitute inductive definitions of sets and relations. A skeletal language\ndesign based on these considerations is sketched and a prototype implementation\ndiscussed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9301109v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Andrew W. Smith"
    ], 
    "lead_author": "Andrew W. Smith", 
    "arxiv-id": "cs/9301109v1", 
    "title": "Logic Programming, Functional Programming, and Inductive Definitions", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "An attempt at unifying logic and functional programming is reported. As a\nstarting point, we take the view that \"logic programs\" are not about logic but\nconstitute inductive definitions of sets and relations. A skeletal language\ndesign based on these considerations is sketched and a prototype implementation\ndiscussed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9301109v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Andrew W. Smith"
    ], 
    "lead_author": "Andrew W. Smith", 
    "arxiv-id": "cs/9301109v1", 
    "title": "Logic Programming, Functional Programming, and Inductive Definitions", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "An attempt at unifying logic and functional programming is reported. As a\nstarting point, we take the view that \"logic programs\" are not about logic but\nconstitute inductive definitions of sets and relations. A skeletal language\ndesign based on these considerations is sketched and a prototype implementation\ndiscussed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9301109v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Andrew W. Smith"
    ], 
    "lead_author": "Andrew W. Smith", 
    "arxiv-id": "cs/9301109v1", 
    "title": "Logic Programming, Functional Programming, and Inductive Definitions", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "An attempt at unifying logic and functional programming is reported. As a\nstarting point, we take the view that \"logic programs\" are not about logic but\nconstitute inductive definitions of sets and relations. A skeletal language\ndesign based on these considerations is sketched and a prototype implementation\ndiscussed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9301109v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Andrew W. Smith"
    ], 
    "lead_author": "Andrew W. Smith", 
    "arxiv-id": "cs/9301109v1", 
    "title": "Logic Programming, Functional Programming, and Inductive Definitions", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "An attempt at unifying logic and functional programming is reported. As a\nstarting point, we take the view that \"logic programs\" are not about logic but\nconstitute inductive definitions of sets and relations. A skeletal language\ndesign based on these considerations is sketched and a prototype implementation\ndiscussed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9301109v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Andrew W. Smith"
    ], 
    "lead_author": "Andrew W. Smith", 
    "arxiv-id": "cs/9301109v1", 
    "title": "Logic Programming, Functional Programming, and Inductive Definitions", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "An attempt at unifying logic and functional programming is reported. As a\nstarting point, we take the view that \"logic programs\" are not about logic but\nconstitute inductive definitions of sets and relations. A skeletal language\ndesign based on these considerations is sketched and a prototype implementation\ndiscussed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9301109v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Andrew W. Smith"
    ], 
    "lead_author": "Andrew W. Smith", 
    "arxiv-id": "cs/9301109v1", 
    "title": "Logic Programming, Functional Programming, and Inductive Definitions", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "An attempt at unifying logic and functional programming is reported. As a\nstarting point, we take the view that \"logic programs\" are not about logic but\nconstitute inductive definitions of sets and relations. A skeletal language\ndesign based on these considerations is sketched and a prototype implementation\ndiscussed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9301109v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Andrew W. Smith"
    ], 
    "lead_author": "Andrew W. Smith", 
    "arxiv-id": "cs/9301109v1", 
    "title": "Logic Programming, Functional Programming, and Inductive Definitions", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "An attempt at unifying logic and functional programming is reported. As a\nstarting point, we take the view that \"logic programs\" are not about logic but\nconstitute inductive definitions of sets and relations. A skeletal language\ndesign based on these considerations is sketched and a prototype implementation\ndiscussed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9301109v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Andrew W. Smith"
    ], 
    "lead_author": "Andrew W. Smith", 
    "arxiv-id": "cs/9301109v1", 
    "title": "Logic Programming, Functional Programming, and Inductive Definitions", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "An attempt at unifying logic and functional programming is reported. As a\nstarting point, we take the view that \"logic programs\" are not about logic but\nconstitute inductive definitions of sets and relations. A skeletal language\ndesign based on these considerations is sketched and a prototype implementation\ndiscussed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9301109v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Andrew W. Smith"
    ], 
    "lead_author": "Andrew W. Smith", 
    "arxiv-id": "cs/9301109v1", 
    "title": "Logic Programming, Functional Programming, and Inductive Definitions", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "An attempt at unifying logic and functional programming is reported. As a\nstarting point, we take the view that \"logic programs\" are not about logic but\nconstitute inductive definitions of sets and relations. A skeletal language\ndesign based on these considerations is sketched and a prototype implementation\ndiscussed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9301109v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Andrew W. Smith"
    ], 
    "lead_author": "Andrew W. Smith", 
    "arxiv-id": "cs/9301109v1", 
    "title": "Logic Programming, Functional Programming, and Inductive Definitions", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "An attempt at unifying logic and functional programming is reported. As a\nstarting point, we take the view that \"logic programs\" are not about logic but\nconstitute inductive definitions of sets and relations. A skeletal language\ndesign based on these considerations is sketched and a prototype implementation\ndiscussed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9301109v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Andrew W. Smith"
    ], 
    "lead_author": "Andrew W. Smith", 
    "arxiv-id": "cs/9301109v1", 
    "title": "Logic Programming, Functional Programming, and Inductive Definitions", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "An attempt at unifying logic and functional programming is reported. As a\nstarting point, we take the view that \"logic programs\" are not about logic but\nconstitute inductive definitions of sets and relations. A skeletal language\ndesign based on these considerations is sketched and a prototype implementation\ndiscussed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9301109v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Andrew W. Smith"
    ], 
    "lead_author": "Andrew W. Smith", 
    "arxiv-id": "cs/9301109v1", 
    "title": "Logic Programming, Functional Programming, and Inductive Definitions", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "An attempt at unifying logic and functional programming is reported. As a\nstarting point, we take the view that \"logic programs\" are not about logic but\nconstitute inductive definitions of sets and relations. A skeletal language\ndesign based on these considerations is sketched and a prototype implementation\ndiscussed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9301109v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Andrew W. Smith"
    ], 
    "lead_author": "Andrew W. Smith", 
    "arxiv-id": "cs/9301109v1", 
    "title": "Logic Programming, Functional Programming, and Inductive Definitions", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "An attempt at unifying logic and functional programming is reported. As a\nstarting point, we take the view that \"logic programs\" are not about logic but\nconstitute inductive definitions of sets and relations. A skeletal language\ndesign based on these considerations is sketched and a prototype implementation\ndiscussed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9301109v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Andrew W. Smith"
    ], 
    "lead_author": "Andrew W. Smith", 
    "arxiv-id": "cs/9301109v1", 
    "title": "Logic Programming, Functional Programming, and Inductive Definitions", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "An attempt at unifying logic and functional programming is reported. As a\nstarting point, we take the view that \"logic programs\" are not about logic but\nconstitute inductive definitions of sets and relations. A skeletal language\ndesign based on these considerations is sketched and a prototype implementation\ndiscussed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9301109v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Andrew W. Smith"
    ], 
    "lead_author": "Andrew W. Smith", 
    "arxiv-id": "cs/9301109v1", 
    "title": "Logic Programming, Functional Programming, and Inductive Definitions", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "An attempt at unifying logic and functional programming is reported. As a\nstarting point, we take the view that \"logic programs\" are not about logic but\nconstitute inductive definitions of sets and relations. A skeletal language\ndesign based on these considerations is sketched and a prototype implementation\ndiscussed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9301109v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Andrew W. Smith"
    ], 
    "lead_author": "Andrew W. Smith", 
    "arxiv-id": "cs/9301109v1", 
    "title": "Logic Programming, Functional Programming, and Inductive Definitions", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "An attempt at unifying logic and functional programming is reported. As a\nstarting point, we take the view that \"logic programs\" are not about logic but\nconstitute inductive definitions of sets and relations. A skeletal language\ndesign based on these considerations is sketched and a prototype implementation\ndiscussed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9301109v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Andrew W. Smith"
    ], 
    "lead_author": "Andrew W. Smith", 
    "arxiv-id": "cs/9301109v1", 
    "title": "Logic Programming, Functional Programming, and Inductive Definitions", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "An attempt at unifying logic and functional programming is reported. As a\nstarting point, we take the view that \"logic programs\" are not about logic but\nconstitute inductive definitions of sets and relations. A skeletal language\ndesign based on these considerations is sketched and a prototype implementation\ndiscussed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9301109v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Andrew W. Smith"
    ], 
    "lead_author": "Andrew W. Smith", 
    "arxiv-id": "cs/9301109v1", 
    "title": "Logic Programming, Functional Programming, and Inductive Definitions", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "An attempt at unifying logic and functional programming is reported. As a\nstarting point, we take the view that \"logic programs\" are not about logic but\nconstitute inductive definitions of sets and relations. A skeletal language\ndesign based on these considerations is sketched and a prototype implementation\ndiscussed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9301109v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Andrew W. Smith"
    ], 
    "lead_author": "Andrew W. Smith", 
    "arxiv-id": "cs/9301109v1", 
    "title": "Logic Programming, Functional Programming, and Inductive Definitions", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "An attempt at unifying logic and functional programming is reported. As a\nstarting point, we take the view that \"logic programs\" are not about logic but\nconstitute inductive definitions of sets and relations. A skeletal language\ndesign based on these considerations is sketched and a prototype implementation\ndiscussed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9301109v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Andrew W. Smith"
    ], 
    "lead_author": "Andrew W. Smith", 
    "arxiv-id": "cs/9301109v1", 
    "title": "Logic Programming, Functional Programming, and Inductive Definitions", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "An attempt at unifying logic and functional programming is reported. As a\nstarting point, we take the view that \"logic programs\" are not about logic but\nconstitute inductive definitions of sets and relations. A skeletal language\ndesign based on these considerations is sketched and a prototype implementation\ndiscussed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9301109v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Andrew W. Smith"
    ], 
    "lead_author": "Andrew W. Smith", 
    "arxiv-id": "cs/9301109v1", 
    "title": "Logic Programming, Functional Programming, and Inductive Definitions", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "An attempt at unifying logic and functional programming is reported. As a\nstarting point, we take the view that \"logic programs\" are not about logic but\nconstitute inductive definitions of sets and relations. A skeletal language\ndesign based on these considerations is sketched and a prototype implementation\ndiscussed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9301109v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Andrew W. Smith"
    ], 
    "lead_author": "Andrew W. Smith", 
    "arxiv-id": "cs/9301109v1", 
    "title": "Logic Programming, Functional Programming, and Inductive Definitions", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "An attempt at unifying logic and functional programming is reported. As a\nstarting point, we take the view that \"logic programs\" are not about logic but\nconstitute inductive definitions of sets and relations. A skeletal language\ndesign based on these considerations is sketched and a prototype implementation\ndiscussed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9301109v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Andrew W. Smith"
    ], 
    "lead_author": "Andrew W. Smith", 
    "arxiv-id": "cs/9301109v1", 
    "title": "Logic Programming, Functional Programming, and Inductive Definitions", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "An attempt at unifying logic and functional programming is reported. As a\nstarting point, we take the view that \"logic programs\" are not about logic but\nconstitute inductive definitions of sets and relations. A skeletal language\ndesign based on these considerations is sketched and a prototype implementation\ndiscussed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9301109v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Andrew W. Smith"
    ], 
    "lead_author": "Andrew W. Smith", 
    "arxiv-id": "cs/9301109v1", 
    "title": "Logic Programming, Functional Programming, and Inductive Definitions", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "An attempt at unifying logic and functional programming is reported. As a\nstarting point, we take the view that \"logic programs\" are not about logic but\nconstitute inductive definitions of sets and relations. A skeletal language\ndesign based on these considerations is sketched and a prototype implementation\ndiscussed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9301109v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Andrew W. Smith"
    ], 
    "lead_author": "Andrew W. Smith", 
    "arxiv-id": "cs/9301109v1", 
    "title": "Logic Programming, Functional Programming, and Inductive Definitions", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "An attempt at unifying logic and functional programming is reported. As a\nstarting point, we take the view that \"logic programs\" are not about logic but\nconstitute inductive definitions of sets and relations. A skeletal language\ndesign based on these considerations is sketched and a prototype implementation\ndiscussed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9301109v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Andrew W. Smith"
    ], 
    "lead_author": "Andrew W. Smith", 
    "arxiv-id": "cs/9301109v1", 
    "title": "Logic Programming, Functional Programming, and Inductive Definitions", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "An attempt at unifying logic and functional programming is reported. As a\nstarting point, we take the view that \"logic programs\" are not about logic but\nconstitute inductive definitions of sets and relations. A skeletal language\ndesign based on these considerations is sketched and a prototype implementation\ndiscussed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9301109v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Andrew W. Smith"
    ], 
    "lead_author": "Andrew W. Smith", 
    "arxiv-id": "cs/9301109v1", 
    "title": "Logic Programming, Functional Programming, and Inductive Definitions", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "An attempt at unifying logic and functional programming is reported. As a\nstarting point, we take the view that \"logic programs\" are not about logic but\nconstitute inductive definitions of sets and relations. A skeletal language\ndesign based on these considerations is sketched and a prototype implementation\ndiscussed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9301109v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Andrew W. Smith"
    ], 
    "lead_author": "Andrew W. Smith", 
    "arxiv-id": "cs/9301109v1", 
    "title": "Logic Programming, Functional Programming, and Inductive Definitions", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "An attempt at unifying logic and functional programming is reported. As a\nstarting point, we take the view that \"logic programs\" are not about logic but\nconstitute inductive definitions of sets and relations. A skeletal language\ndesign based on these considerations is sketched and a prototype implementation\ndiscussed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9301109v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Andrew W. Smith"
    ], 
    "lead_author": "Andrew W. Smith", 
    "arxiv-id": "cs/9301109v1", 
    "title": "Logic Programming, Functional Programming, and Inductive Definitions", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "An attempt at unifying logic and functional programming is reported. As a\nstarting point, we take the view that \"logic programs\" are not about logic but\nconstitute inductive definitions of sets and relations. A skeletal language\ndesign based on these considerations is sketched and a prototype implementation\ndiscussed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9301109v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Andrew W. Smith"
    ], 
    "lead_author": "Andrew W. Smith", 
    "arxiv-id": "cs/9301109v1", 
    "title": "Logic Programming, Functional Programming, and Inductive Definitions", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "An attempt at unifying logic and functional programming is reported. As a\nstarting point, we take the view that \"logic programs\" are not about logic but\nconstitute inductive definitions of sets and relations. A skeletal language\ndesign based on these considerations is sketched and a prototype implementation\ndiscussed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9301109v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Andrew W. Smith"
    ], 
    "lead_author": "Andrew W. Smith", 
    "arxiv-id": "cs/9301109v1", 
    "title": "Logic Programming, Functional Programming, and Inductive Definitions", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "An attempt at unifying logic and functional programming is reported. As a\nstarting point, we take the view that \"logic programs\" are not about logic but\nconstitute inductive definitions of sets and relations. A skeletal language\ndesign based on these considerations is sketched and a prototype implementation\ndiscussed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9301109v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Andrew W. Smith"
    ], 
    "lead_author": "Andrew W. Smith", 
    "arxiv-id": "cs/9301109v1", 
    "title": "Logic Programming, Functional Programming, and Inductive Definitions", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "An attempt at unifying logic and functional programming is reported. As a\nstarting point, we take the view that \"logic programs\" are not about logic but\nconstitute inductive definitions of sets and relations. A skeletal language\ndesign based on these considerations is sketched and a prototype implementation\ndiscussed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9301109v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Andrew W. Smith"
    ], 
    "lead_author": "Andrew W. Smith", 
    "arxiv-id": "cs/9301109v1", 
    "title": "Logic Programming, Functional Programming, and Inductive Definitions", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "An attempt at unifying logic and functional programming is reported. As a\nstarting point, we take the view that \"logic programs\" are not about logic but\nconstitute inductive definitions of sets and relations. A skeletal language\ndesign based on these considerations is sketched and a prototype implementation\ndiscussed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9301109v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Andrew W. Smith"
    ], 
    "lead_author": "Andrew W. Smith", 
    "arxiv-id": "cs/9301109v1", 
    "title": "Logic Programming, Functional Programming, and Inductive Definitions", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "An attempt at unifying logic and functional programming is reported. As a\nstarting point, we take the view that \"logic programs\" are not about logic but\nconstitute inductive definitions of sets and relations. A skeletal language\ndesign based on these considerations is sketched and a prototype implementation\ndiscussed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9301109v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Andrew W. Smith"
    ], 
    "lead_author": "Andrew W. Smith", 
    "arxiv-id": "cs/9301109v1", 
    "title": "Logic Programming, Functional Programming, and Inductive Definitions", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "An attempt at unifying logic and functional programming is reported. As a\nstarting point, we take the view that \"logic programs\" are not about logic but\nconstitute inductive definitions of sets and relations. A skeletal language\ndesign based on these considerations is sketched and a prototype implementation\ndiscussed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9301109v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Andrew W. Smith"
    ], 
    "lead_author": "Andrew W. Smith", 
    "arxiv-id": "cs/9301109v1", 
    "title": "Logic Programming, Functional Programming, and Inductive Definitions", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "An attempt at unifying logic and functional programming is reported. As a\nstarting point, we take the view that \"logic programs\" are not about logic but\nconstitute inductive definitions of sets and relations. A skeletal language\ndesign based on these considerations is sketched and a prototype implementation\ndiscussed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9301109v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Andrew W. Smith"
    ], 
    "lead_author": "Andrew W. Smith", 
    "arxiv-id": "cs/9301109v1", 
    "title": "Logic Programming, Functional Programming, and Inductive Definitions", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "An attempt at unifying logic and functional programming is reported. As a\nstarting point, we take the view that \"logic programs\" are not about logic but\nconstitute inductive definitions of sets and relations. A skeletal language\ndesign based on these considerations is sketched and a prototype implementation\ndiscussed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9301109v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Andrew W. Smith"
    ], 
    "lead_author": "Andrew W. Smith", 
    "arxiv-id": "cs/9301109v1", 
    "title": "Logic Programming, Functional Programming, and Inductive Definitions", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "An attempt at unifying logic and functional programming is reported. As a\nstarting point, we take the view that \"logic programs\" are not about logic but\nconstitute inductive definitions of sets and relations. A skeletal language\ndesign based on these considerations is sketched and a prototype implementation\ndiscussed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9301109v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Andrew W. Smith"
    ], 
    "lead_author": "Andrew W. Smith", 
    "arxiv-id": "cs/9301109v1", 
    "title": "Logic Programming, Functional Programming, and Inductive Definitions", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "An attempt at unifying logic and functional programming is reported. As a\nstarting point, we take the view that \"logic programs\" are not about logic but\nconstitute inductive definitions of sets and relations. A skeletal language\ndesign based on these considerations is sketched and a prototype implementation\ndiscussed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9301109v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Andrew W. Smith"
    ], 
    "lead_author": "Andrew W. Smith", 
    "arxiv-id": "cs/9301109v1", 
    "title": "Logic Programming, Functional Programming, and Inductive Definitions", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "An attempt at unifying logic and functional programming is reported. As a\nstarting point, we take the view that \"logic programs\" are not about logic but\nconstitute inductive definitions of sets and relations. A skeletal language\ndesign based on these considerations is sketched and a prototype implementation\ndiscussed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9301109v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Andrew W. Smith"
    ], 
    "lead_author": "Andrew W. Smith", 
    "arxiv-id": "cs/9301109v1", 
    "title": "Logic Programming, Functional Programming, and Inductive Definitions", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "An attempt at unifying logic and functional programming is reported. As a\nstarting point, we take the view that \"logic programs\" are not about logic but\nconstitute inductive definitions of sets and relations. A skeletal language\ndesign based on these considerations is sketched and a prototype implementation\ndiscussed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9301109v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Andrew W. Smith"
    ], 
    "lead_author": "Andrew W. Smith", 
    "arxiv-id": "cs/9301109v1", 
    "title": "Logic Programming, Functional Programming, and Inductive Definitions", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "An attempt at unifying logic and functional programming is reported. As a\nstarting point, we take the view that \"logic programs\" are not about logic but\nconstitute inductive definitions of sets and relations. A skeletal language\ndesign based on these considerations is sketched and a prototype implementation\ndiscussed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9301109v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Andrew W. Smith"
    ], 
    "lead_author": "Andrew W. Smith", 
    "arxiv-id": "cs/9301109v1", 
    "title": "Logic Programming, Functional Programming, and Inductive Definitions", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "An attempt at unifying logic and functional programming is reported. As a\nstarting point, we take the view that \"logic programs\" are not about logic but\nconstitute inductive definitions of sets and relations. A skeletal language\ndesign based on these considerations is sketched and a prototype implementation\ndiscussed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9301109v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Andrew W. Smith"
    ], 
    "lead_author": "Andrew W. Smith", 
    "arxiv-id": "cs/9301109v1", 
    "title": "Logic Programming, Functional Programming, and Inductive Definitions", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "An attempt at unifying logic and functional programming is reported. As a\nstarting point, we take the view that \"logic programs\" are not about logic but\nconstitute inductive definitions of sets and relations. A skeletal language\ndesign based on these considerations is sketched and a prototype implementation\ndiscussed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9301109v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Andrew W. Smith"
    ], 
    "lead_author": "Andrew W. Smith", 
    "arxiv-id": "cs/9301109v1", 
    "title": "Logic Programming, Functional Programming, and Inductive Definitions", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "An attempt at unifying logic and functional programming is reported. As a\nstarting point, we take the view that \"logic programs\" are not about logic but\nconstitute inductive definitions of sets and relations. A skeletal language\ndesign based on these considerations is sketched and a prototype implementation\ndiscussed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9301109v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Andrew W. Smith"
    ], 
    "lead_author": "Andrew W. Smith", 
    "arxiv-id": "cs/9301109v1", 
    "title": "Logic Programming, Functional Programming, and Inductive Definitions", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "An attempt at unifying logic and functional programming is reported. As a\nstarting point, we take the view that \"logic programs\" are not about logic but\nconstitute inductive definitions of sets and relations. A skeletal language\ndesign based on these considerations is sketched and a prototype implementation\ndiscussed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9301109v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Andrew W. Smith"
    ], 
    "lead_author": "Andrew W. Smith", 
    "arxiv-id": "cs/9301109v1", 
    "title": "Logic Programming, Functional Programming, and Inductive Definitions", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "An attempt at unifying logic and functional programming is reported. As a\nstarting point, we take the view that \"logic programs\" are not about logic but\nconstitute inductive definitions of sets and relations. A skeletal language\ndesign based on these considerations is sketched and a prototype implementation\ndiscussed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9612104v1", 
    "other_authors": [
        "Lawrence C. Paulson", 
        "Krzysztof Grabczewski"
    ], 
    "lead_author": "Krzysztof Grabczewski", 
    "arxiv-id": "cs/9612104v1", 
    "title": "Mechanizing Set Theory: Cardinal Arithmetic and the Axiom of Choice.", 
    "publish": "2001-03-29T00:00:00Z", 
    "summary": "Fairly deep results of Zermelo-Frenkel (ZF) set theory have been mechanized\nusing the proof assistant Isabelle. The results concern cardinal arithmetic and\nthe Axiom of Choice (AC). A key result about cardinal multiplication is K*K =\nK, where K is any infinite cardinal. Proving this result required developing\ntheories of orders, order-isomorphisms, order types, ordinal arithmetic,\ncardinals, etc.; this covers most of Kunen, Set Theory, Chapter I. Furthermore,\nwe have proved the equivalence of 7 formulations of the Well-ordering Theorem\nand 20 formulations of AC; this covers the first two chapters of Rubin and\nRubin, Equivalents of the Axiom of Choice, and involves highly technical\nmaterial. The definitions used in the proofs are largely faithful in style to\nthe original mathematics."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9809014v1", 
    "other_authors": [
        "Gopalan Nadathur"
    ], 
    "lead_author": "Gopalan Nadathur", 
    "arxiv-id": "cs/9809014v1", 
    "title": "Uniform Provability in Classical Logic", 
    "publish": "1998-09-10T15:17:05Z", 
    "summary": "Uniform proofs are sequent calculus proofs with the following characteristic:\nthe last step in the derivation of a complex formula at any stage in the proof\nis always the introduction of the top-level logical symbol of that formula. We\ninvestigate the relevance of this uniform proof notion to structuring proof\nsearch in classical logic. A logical language in whose context provability is\nequivalent to uniform provability admits of a goal-directed proof procedure\nthat interprets logical symbols as search directives whose meanings are given\nby the corresponding inference rules. While this uniform provability property\ndoes not hold directly of classical logic, we show that it holds of a fragment\nof it that only excludes essentially positive occurrences of universal\nquantifiers under a modest, sound, modification to the set of assumptions: the\naddition to them of the negation of the formula being proved. We further note\nthat all uses of the added formula can be factored into certain derived rules.\nThe resulting proof system and the uniform provability property that holds of\nit are used to outline a proof procedure for classical logic. An interesting\naspect of this proof procedure is that it incorporates within it previously\nproposed mechanisms for dealing with disjunctive information in assumptions and\nfor handling hypotheticals. Our analysis sheds light on the relationship\nbetween these mechanisms and the notion of uniform proofs."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9809014v1", 
    "other_authors": [
        "Gopalan Nadathur"
    ], 
    "lead_author": "Gopalan Nadathur", 
    "arxiv-id": "cs/9809014v1", 
    "title": "Uniform Provability in Classical Logic", 
    "publish": "1998-09-10T15:17:05Z", 
    "summary": "Uniform proofs are sequent calculus proofs with the following characteristic:\nthe last step in the derivation of a complex formula at any stage in the proof\nis always the introduction of the top-level logical symbol of that formula. We\ninvestigate the relevance of this uniform proof notion to structuring proof\nsearch in classical logic. A logical language in whose context provability is\nequivalent to uniform provability admits of a goal-directed proof procedure\nthat interprets logical symbols as search directives whose meanings are given\nby the corresponding inference rules. While this uniform provability property\ndoes not hold directly of classical logic, we show that it holds of a fragment\nof it that only excludes essentially positive occurrences of universal\nquantifiers under a modest, sound, modification to the set of assumptions: the\naddition to them of the negation of the formula being proved. We further note\nthat all uses of the added formula can be factored into certain derived rules.\nThe resulting proof system and the uniform provability property that holds of\nit are used to outline a proof procedure for classical logic. An interesting\naspect of this proof procedure is that it incorporates within it previously\nproposed mechanisms for dealing with disjunctive information in assumptions and\nfor handling hypotheticals. Our analysis sheds light on the relationship\nbetween these mechanisms and the notion of uniform proofs."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9809014v1", 
    "other_authors": [
        "Gopalan Nadathur"
    ], 
    "lead_author": "Gopalan Nadathur", 
    "arxiv-id": "cs/9809014v1", 
    "title": "Uniform Provability in Classical Logic", 
    "publish": "1998-09-10T15:17:05Z", 
    "summary": "Uniform proofs are sequent calculus proofs with the following characteristic:\nthe last step in the derivation of a complex formula at any stage in the proof\nis always the introduction of the top-level logical symbol of that formula. We\ninvestigate the relevance of this uniform proof notion to structuring proof\nsearch in classical logic. A logical language in whose context provability is\nequivalent to uniform provability admits of a goal-directed proof procedure\nthat interprets logical symbols as search directives whose meanings are given\nby the corresponding inference rules. While this uniform provability property\ndoes not hold directly of classical logic, we show that it holds of a fragment\nof it that only excludes essentially positive occurrences of universal\nquantifiers under a modest, sound, modification to the set of assumptions: the\naddition to them of the negation of the formula being proved. We further note\nthat all uses of the added formula can be factored into certain derived rules.\nThe resulting proof system and the uniform provability property that holds of\nit are used to outline a proof procedure for classical logic. An interesting\naspect of this proof procedure is that it incorporates within it previously\nproposed mechanisms for dealing with disjunctive information in assumptions and\nfor handling hypotheticals. Our analysis sheds light on the relationship\nbetween these mechanisms and the notion of uniform proofs."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9809014v1", 
    "other_authors": [
        "Gopalan Nadathur"
    ], 
    "lead_author": "Gopalan Nadathur", 
    "arxiv-id": "cs/9809014v1", 
    "title": "Uniform Provability in Classical Logic", 
    "publish": "1998-09-10T15:17:05Z", 
    "summary": "Uniform proofs are sequent calculus proofs with the following characteristic:\nthe last step in the derivation of a complex formula at any stage in the proof\nis always the introduction of the top-level logical symbol of that formula. We\ninvestigate the relevance of this uniform proof notion to structuring proof\nsearch in classical logic. A logical language in whose context provability is\nequivalent to uniform provability admits of a goal-directed proof procedure\nthat interprets logical symbols as search directives whose meanings are given\nby the corresponding inference rules. While this uniform provability property\ndoes not hold directly of classical logic, we show that it holds of a fragment\nof it that only excludes essentially positive occurrences of universal\nquantifiers under a modest, sound, modification to the set of assumptions: the\naddition to them of the negation of the formula being proved. We further note\nthat all uses of the added formula can be factored into certain derived rules.\nThe resulting proof system and the uniform provability property that holds of\nit are used to outline a proof procedure for classical logic. An interesting\naspect of this proof procedure is that it incorporates within it previously\nproposed mechanisms for dealing with disjunctive information in assumptions and\nfor handling hypotheticals. Our analysis sheds light on the relationship\nbetween these mechanisms and the notion of uniform proofs."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9809014v1", 
    "other_authors": [
        "Gopalan Nadathur"
    ], 
    "lead_author": "Gopalan Nadathur", 
    "arxiv-id": "cs/9809014v1", 
    "title": "Uniform Provability in Classical Logic", 
    "publish": "1998-09-10T15:17:05Z", 
    "summary": "Uniform proofs are sequent calculus proofs with the following characteristic:\nthe last step in the derivation of a complex formula at any stage in the proof\nis always the introduction of the top-level logical symbol of that formula. We\ninvestigate the relevance of this uniform proof notion to structuring proof\nsearch in classical logic. A logical language in whose context provability is\nequivalent to uniform provability admits of a goal-directed proof procedure\nthat interprets logical symbols as search directives whose meanings are given\nby the corresponding inference rules. While this uniform provability property\ndoes not hold directly of classical logic, we show that it holds of a fragment\nof it that only excludes essentially positive occurrences of universal\nquantifiers under a modest, sound, modification to the set of assumptions: the\naddition to them of the negation of the formula being proved. We further note\nthat all uses of the added formula can be factored into certain derived rules.\nThe resulting proof system and the uniform provability property that holds of\nit are used to outline a proof procedure for classical logic. An interesting\naspect of this proof procedure is that it incorporates within it previously\nproposed mechanisms for dealing with disjunctive information in assumptions and\nfor handling hypotheticals. Our analysis sheds light on the relationship\nbetween these mechanisms and the notion of uniform proofs."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9809014v1", 
    "other_authors": [
        "Gopalan Nadathur"
    ], 
    "lead_author": "Gopalan Nadathur", 
    "arxiv-id": "cs/9809014v1", 
    "title": "Uniform Provability in Classical Logic", 
    "publish": "1998-09-10T15:17:05Z", 
    "summary": "Uniform proofs are sequent calculus proofs with the following characteristic:\nthe last step in the derivation of a complex formula at any stage in the proof\nis always the introduction of the top-level logical symbol of that formula. We\ninvestigate the relevance of this uniform proof notion to structuring proof\nsearch in classical logic. A logical language in whose context provability is\nequivalent to uniform provability admits of a goal-directed proof procedure\nthat interprets logical symbols as search directives whose meanings are given\nby the corresponding inference rules. While this uniform provability property\ndoes not hold directly of classical logic, we show that it holds of a fragment\nof it that only excludes essentially positive occurrences of universal\nquantifiers under a modest, sound, modification to the set of assumptions: the\naddition to them of the negation of the formula being proved. We further note\nthat all uses of the added formula can be factored into certain derived rules.\nThe resulting proof system and the uniform provability property that holds of\nit are used to outline a proof procedure for classical logic. An interesting\naspect of this proof procedure is that it incorporates within it previously\nproposed mechanisms for dealing with disjunctive information in assumptions and\nfor handling hypotheticals. Our analysis sheds light on the relationship\nbetween these mechanisms and the notion of uniform proofs."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9809014v1", 
    "other_authors": [
        "Gopalan Nadathur"
    ], 
    "lead_author": "Gopalan Nadathur", 
    "arxiv-id": "cs/9809014v1", 
    "title": "Uniform Provability in Classical Logic", 
    "publish": "1998-09-10T15:17:05Z", 
    "summary": "Uniform proofs are sequent calculus proofs with the following characteristic:\nthe last step in the derivation of a complex formula at any stage in the proof\nis always the introduction of the top-level logical symbol of that formula. We\ninvestigate the relevance of this uniform proof notion to structuring proof\nsearch in classical logic. A logical language in whose context provability is\nequivalent to uniform provability admits of a goal-directed proof procedure\nthat interprets logical symbols as search directives whose meanings are given\nby the corresponding inference rules. While this uniform provability property\ndoes not hold directly of classical logic, we show that it holds of a fragment\nof it that only excludes essentially positive occurrences of universal\nquantifiers under a modest, sound, modification to the set of assumptions: the\naddition to them of the negation of the formula being proved. We further note\nthat all uses of the added formula can be factored into certain derived rules.\nThe resulting proof system and the uniform provability property that holds of\nit are used to outline a proof procedure for classical logic. An interesting\naspect of this proof procedure is that it incorporates within it previously\nproposed mechanisms for dealing with disjunctive information in assumptions and\nfor handling hypotheticals. Our analysis sheds light on the relationship\nbetween these mechanisms and the notion of uniform proofs."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9809014v1", 
    "other_authors": [
        "Gopalan Nadathur"
    ], 
    "lead_author": "Gopalan Nadathur", 
    "arxiv-id": "cs/9809014v1", 
    "title": "Uniform Provability in Classical Logic", 
    "publish": "1998-09-10T15:17:05Z", 
    "summary": "Uniform proofs are sequent calculus proofs with the following characteristic:\nthe last step in the derivation of a complex formula at any stage in the proof\nis always the introduction of the top-level logical symbol of that formula. We\ninvestigate the relevance of this uniform proof notion to structuring proof\nsearch in classical logic. A logical language in whose context provability is\nequivalent to uniform provability admits of a goal-directed proof procedure\nthat interprets logical symbols as search directives whose meanings are given\nby the corresponding inference rules. While this uniform provability property\ndoes not hold directly of classical logic, we show that it holds of a fragment\nof it that only excludes essentially positive occurrences of universal\nquantifiers under a modest, sound, modification to the set of assumptions: the\naddition to them of the negation of the formula being proved. We further note\nthat all uses of the added formula can be factored into certain derived rules.\nThe resulting proof system and the uniform provability property that holds of\nit are used to outline a proof procedure for classical logic. An interesting\naspect of this proof procedure is that it incorporates within it previously\nproposed mechanisms for dealing with disjunctive information in assumptions and\nfor handling hypotheticals. Our analysis sheds light on the relationship\nbetween these mechanisms and the notion of uniform proofs."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9809014v1", 
    "other_authors": [
        "Gopalan Nadathur"
    ], 
    "lead_author": "Gopalan Nadathur", 
    "arxiv-id": "cs/9809014v1", 
    "title": "Uniform Provability in Classical Logic", 
    "publish": "1998-09-10T15:17:05Z", 
    "summary": "Uniform proofs are sequent calculus proofs with the following characteristic:\nthe last step in the derivation of a complex formula at any stage in the proof\nis always the introduction of the top-level logical symbol of that formula. We\ninvestigate the relevance of this uniform proof notion to structuring proof\nsearch in classical logic. A logical language in whose context provability is\nequivalent to uniform provability admits of a goal-directed proof procedure\nthat interprets logical symbols as search directives whose meanings are given\nby the corresponding inference rules. While this uniform provability property\ndoes not hold directly of classical logic, we show that it holds of a fragment\nof it that only excludes essentially positive occurrences of universal\nquantifiers under a modest, sound, modification to the set of assumptions: the\naddition to them of the negation of the formula being proved. We further note\nthat all uses of the added formula can be factored into certain derived rules.\nThe resulting proof system and the uniform provability property that holds of\nit are used to outline a proof procedure for classical logic. An interesting\naspect of this proof procedure is that it incorporates within it previously\nproposed mechanisms for dealing with disjunctive information in assumptions and\nfor handling hypotheticals. Our analysis sheds light on the relationship\nbetween these mechanisms and the notion of uniform proofs."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9809014v1", 
    "other_authors": [
        "Gopalan Nadathur"
    ], 
    "lead_author": "Gopalan Nadathur", 
    "arxiv-id": "cs/9809014v1", 
    "title": "Uniform Provability in Classical Logic", 
    "publish": "1998-09-10T15:17:05Z", 
    "summary": "Uniform proofs are sequent calculus proofs with the following characteristic:\nthe last step in the derivation of a complex formula at any stage in the proof\nis always the introduction of the top-level logical symbol of that formula. We\ninvestigate the relevance of this uniform proof notion to structuring proof\nsearch in classical logic. A logical language in whose context provability is\nequivalent to uniform provability admits of a goal-directed proof procedure\nthat interprets logical symbols as search directives whose meanings are given\nby the corresponding inference rules. While this uniform provability property\ndoes not hold directly of classical logic, we show that it holds of a fragment\nof it that only excludes essentially positive occurrences of universal\nquantifiers under a modest, sound, modification to the set of assumptions: the\naddition to them of the negation of the formula being proved. We further note\nthat all uses of the added formula can be factored into certain derived rules.\nThe resulting proof system and the uniform provability property that holds of\nit are used to outline a proof procedure for classical logic. An interesting\naspect of this proof procedure is that it incorporates within it previously\nproposed mechanisms for dealing with disjunctive information in assumptions and\nfor handling hypotheticals. Our analysis sheds light on the relationship\nbetween these mechanisms and the notion of uniform proofs."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9809014v1", 
    "other_authors": [
        "Gopalan Nadathur"
    ], 
    "lead_author": "Gopalan Nadathur", 
    "arxiv-id": "cs/9809014v1", 
    "title": "Uniform Provability in Classical Logic", 
    "publish": "1998-09-10T15:17:05Z", 
    "summary": "Uniform proofs are sequent calculus proofs with the following characteristic:\nthe last step in the derivation of a complex formula at any stage in the proof\nis always the introduction of the top-level logical symbol of that formula. We\ninvestigate the relevance of this uniform proof notion to structuring proof\nsearch in classical logic. A logical language in whose context provability is\nequivalent to uniform provability admits of a goal-directed proof procedure\nthat interprets logical symbols as search directives whose meanings are given\nby the corresponding inference rules. While this uniform provability property\ndoes not hold directly of classical logic, we show that it holds of a fragment\nof it that only excludes essentially positive occurrences of universal\nquantifiers under a modest, sound, modification to the set of assumptions: the\naddition to them of the negation of the formula being proved. We further note\nthat all uses of the added formula can be factored into certain derived rules.\nThe resulting proof system and the uniform provability property that holds of\nit are used to outline a proof procedure for classical logic. An interesting\naspect of this proof procedure is that it incorporates within it previously\nproposed mechanisms for dealing with disjunctive information in assumptions and\nfor handling hypotheticals. Our analysis sheds light on the relationship\nbetween these mechanisms and the notion of uniform proofs."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9809014v1", 
    "other_authors": [
        "Gopalan Nadathur"
    ], 
    "lead_author": "Gopalan Nadathur", 
    "arxiv-id": "cs/9809014v1", 
    "title": "Uniform Provability in Classical Logic", 
    "publish": "1998-09-10T15:17:05Z", 
    "summary": "Uniform proofs are sequent calculus proofs with the following characteristic:\nthe last step in the derivation of a complex formula at any stage in the proof\nis always the introduction of the top-level logical symbol of that formula. We\ninvestigate the relevance of this uniform proof notion to structuring proof\nsearch in classical logic. A logical language in whose context provability is\nequivalent to uniform provability admits of a goal-directed proof procedure\nthat interprets logical symbols as search directives whose meanings are given\nby the corresponding inference rules. While this uniform provability property\ndoes not hold directly of classical logic, we show that it holds of a fragment\nof it that only excludes essentially positive occurrences of universal\nquantifiers under a modest, sound, modification to the set of assumptions: the\naddition to them of the negation of the formula being proved. We further note\nthat all uses of the added formula can be factored into certain derived rules.\nThe resulting proof system and the uniform provability property that holds of\nit are used to outline a proof procedure for classical logic. An interesting\naspect of this proof procedure is that it incorporates within it previously\nproposed mechanisms for dealing with disjunctive information in assumptions and\nfor handling hypotheticals. Our analysis sheds light on the relationship\nbetween these mechanisms and the notion of uniform proofs."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9809014v1", 
    "other_authors": [
        "Gopalan Nadathur"
    ], 
    "lead_author": "Gopalan Nadathur", 
    "arxiv-id": "cs/9809014v1", 
    "title": "Uniform Provability in Classical Logic", 
    "publish": "1998-09-10T15:17:05Z", 
    "summary": "Uniform proofs are sequent calculus proofs with the following characteristic:\nthe last step in the derivation of a complex formula at any stage in the proof\nis always the introduction of the top-level logical symbol of that formula. We\ninvestigate the relevance of this uniform proof notion to structuring proof\nsearch in classical logic. A logical language in whose context provability is\nequivalent to uniform provability admits of a goal-directed proof procedure\nthat interprets logical symbols as search directives whose meanings are given\nby the corresponding inference rules. While this uniform provability property\ndoes not hold directly of classical logic, we show that it holds of a fragment\nof it that only excludes essentially positive occurrences of universal\nquantifiers under a modest, sound, modification to the set of assumptions: the\naddition to them of the negation of the formula being proved. We further note\nthat all uses of the added formula can be factored into certain derived rules.\nThe resulting proof system and the uniform provability property that holds of\nit are used to outline a proof procedure for classical logic. An interesting\naspect of this proof procedure is that it incorporates within it previously\nproposed mechanisms for dealing with disjunctive information in assumptions and\nfor handling hypotheticals. Our analysis sheds light on the relationship\nbetween these mechanisms and the notion of uniform proofs."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9809014v1", 
    "other_authors": [
        "Gopalan Nadathur"
    ], 
    "lead_author": "Gopalan Nadathur", 
    "arxiv-id": "cs/9809014v1", 
    "title": "Uniform Provability in Classical Logic", 
    "publish": "1998-09-10T15:17:05Z", 
    "summary": "Uniform proofs are sequent calculus proofs with the following characteristic:\nthe last step in the derivation of a complex formula at any stage in the proof\nis always the introduction of the top-level logical symbol of that formula. We\ninvestigate the relevance of this uniform proof notion to structuring proof\nsearch in classical logic. A logical language in whose context provability is\nequivalent to uniform provability admits of a goal-directed proof procedure\nthat interprets logical symbols as search directives whose meanings are given\nby the corresponding inference rules. While this uniform provability property\ndoes not hold directly of classical logic, we show that it holds of a fragment\nof it that only excludes essentially positive occurrences of universal\nquantifiers under a modest, sound, modification to the set of assumptions: the\naddition to them of the negation of the formula being proved. We further note\nthat all uses of the added formula can be factored into certain derived rules.\nThe resulting proof system and the uniform provability property that holds of\nit are used to outline a proof procedure for classical logic. An interesting\naspect of this proof procedure is that it incorporates within it previously\nproposed mechanisms for dealing with disjunctive information in assumptions and\nfor handling hypotheticals. Our analysis sheds light on the relationship\nbetween these mechanisms and the notion of uniform proofs."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9809014v1", 
    "other_authors": [
        "Gopalan Nadathur"
    ], 
    "lead_author": "Gopalan Nadathur", 
    "arxiv-id": "cs/9809014v1", 
    "title": "Uniform Provability in Classical Logic", 
    "publish": "1998-09-10T15:17:05Z", 
    "summary": "Uniform proofs are sequent calculus proofs with the following characteristic:\nthe last step in the derivation of a complex formula at any stage in the proof\nis always the introduction of the top-level logical symbol of that formula. We\ninvestigate the relevance of this uniform proof notion to structuring proof\nsearch in classical logic. A logical language in whose context provability is\nequivalent to uniform provability admits of a goal-directed proof procedure\nthat interprets logical symbols as search directives whose meanings are given\nby the corresponding inference rules. While this uniform provability property\ndoes not hold directly of classical logic, we show that it holds of a fragment\nof it that only excludes essentially positive occurrences of universal\nquantifiers under a modest, sound, modification to the set of assumptions: the\naddition to them of the negation of the formula being proved. We further note\nthat all uses of the added formula can be factored into certain derived rules.\nThe resulting proof system and the uniform provability property that holds of\nit are used to outline a proof procedure for classical logic. An interesting\naspect of this proof procedure is that it incorporates within it previously\nproposed mechanisms for dealing with disjunctive information in assumptions and\nfor handling hypotheticals. Our analysis sheds light on the relationship\nbetween these mechanisms and the notion of uniform proofs."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9809014v1", 
    "other_authors": [
        "Gopalan Nadathur"
    ], 
    "lead_author": "Gopalan Nadathur", 
    "arxiv-id": "cs/9809014v1", 
    "title": "Uniform Provability in Classical Logic", 
    "publish": "1998-09-10T15:17:05Z", 
    "summary": "Uniform proofs are sequent calculus proofs with the following characteristic:\nthe last step in the derivation of a complex formula at any stage in the proof\nis always the introduction of the top-level logical symbol of that formula. We\ninvestigate the relevance of this uniform proof notion to structuring proof\nsearch in classical logic. A logical language in whose context provability is\nequivalent to uniform provability admits of a goal-directed proof procedure\nthat interprets logical symbols as search directives whose meanings are given\nby the corresponding inference rules. While this uniform provability property\ndoes not hold directly of classical logic, we show that it holds of a fragment\nof it that only excludes essentially positive occurrences of universal\nquantifiers under a modest, sound, modification to the set of assumptions: the\naddition to them of the negation of the formula being proved. We further note\nthat all uses of the added formula can be factored into certain derived rules.\nThe resulting proof system and the uniform provability property that holds of\nit are used to outline a proof procedure for classical logic. An interesting\naspect of this proof procedure is that it incorporates within it previously\nproposed mechanisms for dealing with disjunctive information in assumptions and\nfor handling hypotheticals. Our analysis sheds light on the relationship\nbetween these mechanisms and the notion of uniform proofs."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9809014v1", 
    "other_authors": [
        "Gopalan Nadathur"
    ], 
    "lead_author": "Gopalan Nadathur", 
    "arxiv-id": "cs/9809014v1", 
    "title": "Uniform Provability in Classical Logic", 
    "publish": "1998-09-10T15:17:05Z", 
    "summary": "Uniform proofs are sequent calculus proofs with the following characteristic:\nthe last step in the derivation of a complex formula at any stage in the proof\nis always the introduction of the top-level logical symbol of that formula. We\ninvestigate the relevance of this uniform proof notion to structuring proof\nsearch in classical logic. A logical language in whose context provability is\nequivalent to uniform provability admits of a goal-directed proof procedure\nthat interprets logical symbols as search directives whose meanings are given\nby the corresponding inference rules. While this uniform provability property\ndoes not hold directly of classical logic, we show that it holds of a fragment\nof it that only excludes essentially positive occurrences of universal\nquantifiers under a modest, sound, modification to the set of assumptions: the\naddition to them of the negation of the formula being proved. We further note\nthat all uses of the added formula can be factored into certain derived rules.\nThe resulting proof system and the uniform provability property that holds of\nit are used to outline a proof procedure for classical logic. An interesting\naspect of this proof procedure is that it incorporates within it previously\nproposed mechanisms for dealing with disjunctive information in assumptions and\nfor handling hypotheticals. Our analysis sheds light on the relationship\nbetween these mechanisms and the notion of uniform proofs."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9809014v1", 
    "other_authors": [
        "Gopalan Nadathur"
    ], 
    "lead_author": "Gopalan Nadathur", 
    "arxiv-id": "cs/9809014v1", 
    "title": "Uniform Provability in Classical Logic", 
    "publish": "1998-09-10T15:17:05Z", 
    "summary": "Uniform proofs are sequent calculus proofs with the following characteristic:\nthe last step in the derivation of a complex formula at any stage in the proof\nis always the introduction of the top-level logical symbol of that formula. We\ninvestigate the relevance of this uniform proof notion to structuring proof\nsearch in classical logic. A logical language in whose context provability is\nequivalent to uniform provability admits of a goal-directed proof procedure\nthat interprets logical symbols as search directives whose meanings are given\nby the corresponding inference rules. While this uniform provability property\ndoes not hold directly of classical logic, we show that it holds of a fragment\nof it that only excludes essentially positive occurrences of universal\nquantifiers under a modest, sound, modification to the set of assumptions: the\naddition to them of the negation of the formula being proved. We further note\nthat all uses of the added formula can be factored into certain derived rules.\nThe resulting proof system and the uniform provability property that holds of\nit are used to outline a proof procedure for classical logic. An interesting\naspect of this proof procedure is that it incorporates within it previously\nproposed mechanisms for dealing with disjunctive information in assumptions and\nfor handling hypotheticals. Our analysis sheds light on the relationship\nbetween these mechanisms and the notion of uniform proofs."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9809014v1", 
    "other_authors": [
        "Gopalan Nadathur"
    ], 
    "lead_author": "Gopalan Nadathur", 
    "arxiv-id": "cs/9809014v1", 
    "title": "Uniform Provability in Classical Logic", 
    "publish": "1998-09-10T15:17:05Z", 
    "summary": "Uniform proofs are sequent calculus proofs with the following characteristic:\nthe last step in the derivation of a complex formula at any stage in the proof\nis always the introduction of the top-level logical symbol of that formula. We\ninvestigate the relevance of this uniform proof notion to structuring proof\nsearch in classical logic. A logical language in whose context provability is\nequivalent to uniform provability admits of a goal-directed proof procedure\nthat interprets logical symbols as search directives whose meanings are given\nby the corresponding inference rules. While this uniform provability property\ndoes not hold directly of classical logic, we show that it holds of a fragment\nof it that only excludes essentially positive occurrences of universal\nquantifiers under a modest, sound, modification to the set of assumptions: the\naddition to them of the negation of the formula being proved. We further note\nthat all uses of the added formula can be factored into certain derived rules.\nThe resulting proof system and the uniform provability property that holds of\nit are used to outline a proof procedure for classical logic. An interesting\naspect of this proof procedure is that it incorporates within it previously\nproposed mechanisms for dealing with disjunctive information in assumptions and\nfor handling hypotheticals. Our analysis sheds light on the relationship\nbetween these mechanisms and the notion of uniform proofs."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9809015v1", 
    "other_authors": [
        "Gopalan Nadathur"
    ], 
    "lead_author": "Gopalan Nadathur", 
    "arxiv-id": "cs/9809015v1", 
    "title": "Correspondences between Classical, Intuitionistic and Uniform   Provability", 
    "publish": "1998-09-10T15:39:30Z", 
    "summary": "Based on an analysis of the inference rules used, we provide a\ncharacterization of the situations in which classical provability entails\nintuitionistic provability. We then examine the relationship of these\nderivability notions to uniform provability, a restriction of intuitionistic\nprovability that embodies a special form of goal-directedness. We determine,\nfirst, the circumstances in which the former relations imply the latter. Using\nthis result, we identify the richest versions of the so-called abstract logic\nprogramming languages in classical and intuitionistic logic. We then study the\nreduction of classical and, derivatively, intuitionistic provability to uniform\nprovability via the addition to the assumption set of the negation of the\nformula to be proved. Our focus here is on understanding the situations in\nwhich this reduction is achieved. However, our discussions indicate the\nstructure of a proof procedure based on the reduction, a matter also considered\nexplicitly elsewhere."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9809015v1", 
    "other_authors": [
        "Gopalan Nadathur"
    ], 
    "lead_author": "Gopalan Nadathur", 
    "arxiv-id": "cs/9809015v1", 
    "title": "Correspondences between Classical, Intuitionistic and Uniform   Provability", 
    "publish": "1998-09-10T15:39:30Z", 
    "summary": "Based on an analysis of the inference rules used, we provide a\ncharacterization of the situations in which classical provability entails\nintuitionistic provability. We then examine the relationship of these\nderivability notions to uniform provability, a restriction of intuitionistic\nprovability that embodies a special form of goal-directedness. We determine,\nfirst, the circumstances in which the former relations imply the latter. Using\nthis result, we identify the richest versions of the so-called abstract logic\nprogramming languages in classical and intuitionistic logic. We then study the\nreduction of classical and, derivatively, intuitionistic provability to uniform\nprovability via the addition to the assumption set of the negation of the\nformula to be proved. Our focus here is on understanding the situations in\nwhich this reduction is achieved. However, our discussions indicate the\nstructure of a proof procedure based on the reduction, a matter also considered\nexplicitly elsewhere."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9809015v1", 
    "other_authors": [
        "Gopalan Nadathur"
    ], 
    "lead_author": "Gopalan Nadathur", 
    "arxiv-id": "cs/9809015v1", 
    "title": "Correspondences between Classical, Intuitionistic and Uniform   Provability", 
    "publish": "1998-09-10T15:39:30Z", 
    "summary": "Based on an analysis of the inference rules used, we provide a\ncharacterization of the situations in which classical provability entails\nintuitionistic provability. We then examine the relationship of these\nderivability notions to uniform provability, a restriction of intuitionistic\nprovability that embodies a special form of goal-directedness. We determine,\nfirst, the circumstances in which the former relations imply the latter. Using\nthis result, we identify the richest versions of the so-called abstract logic\nprogramming languages in classical and intuitionistic logic. We then study the\nreduction of classical and, derivatively, intuitionistic provability to uniform\nprovability via the addition to the assumption set of the negation of the\nformula to be proved. Our focus here is on understanding the situations in\nwhich this reduction is achieved. However, our discussions indicate the\nstructure of a proof procedure based on the reduction, a matter also considered\nexplicitly elsewhere."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9809015v1", 
    "other_authors": [
        "Gopalan Nadathur"
    ], 
    "lead_author": "Gopalan Nadathur", 
    "arxiv-id": "cs/9809015v1", 
    "title": "Correspondences between Classical, Intuitionistic and Uniform   Provability", 
    "publish": "1998-09-10T15:39:30Z", 
    "summary": "Based on an analysis of the inference rules used, we provide a\ncharacterization of the situations in which classical provability entails\nintuitionistic provability. We then examine the relationship of these\nderivability notions to uniform provability, a restriction of intuitionistic\nprovability that embodies a special form of goal-directedness. We determine,\nfirst, the circumstances in which the former relations imply the latter. Using\nthis result, we identify the richest versions of the so-called abstract logic\nprogramming languages in classical and intuitionistic logic. We then study the\nreduction of classical and, derivatively, intuitionistic provability to uniform\nprovability via the addition to the assumption set of the negation of the\nformula to be proved. Our focus here is on understanding the situations in\nwhich this reduction is achieved. However, our discussions indicate the\nstructure of a proof procedure based on the reduction, a matter also considered\nexplicitly elsewhere."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9809015v1", 
    "other_authors": [
        "Gopalan Nadathur"
    ], 
    "lead_author": "Gopalan Nadathur", 
    "arxiv-id": "cs/9809015v1", 
    "title": "Correspondences between Classical, Intuitionistic and Uniform   Provability", 
    "publish": "1998-09-10T15:39:30Z", 
    "summary": "Based on an analysis of the inference rules used, we provide a\ncharacterization of the situations in which classical provability entails\nintuitionistic provability. We then examine the relationship of these\nderivability notions to uniform provability, a restriction of intuitionistic\nprovability that embodies a special form of goal-directedness. We determine,\nfirst, the circumstances in which the former relations imply the latter. Using\nthis result, we identify the richest versions of the so-called abstract logic\nprogramming languages in classical and intuitionistic logic. We then study the\nreduction of classical and, derivatively, intuitionistic provability to uniform\nprovability via the addition to the assumption set of the negation of the\nformula to be proved. Our focus here is on understanding the situations in\nwhich this reduction is achieved. However, our discussions indicate the\nstructure of a proof procedure based on the reduction, a matter also considered\nexplicitly elsewhere."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9809015v1", 
    "other_authors": [
        "Gopalan Nadathur"
    ], 
    "lead_author": "Gopalan Nadathur", 
    "arxiv-id": "cs/9809015v1", 
    "title": "Correspondences between Classical, Intuitionistic and Uniform   Provability", 
    "publish": "1998-09-10T15:39:30Z", 
    "summary": "Based on an analysis of the inference rules used, we provide a\ncharacterization of the situations in which classical provability entails\nintuitionistic provability. We then examine the relationship of these\nderivability notions to uniform provability, a restriction of intuitionistic\nprovability that embodies a special form of goal-directedness. We determine,\nfirst, the circumstances in which the former relations imply the latter. Using\nthis result, we identify the richest versions of the so-called abstract logic\nprogramming languages in classical and intuitionistic logic. We then study the\nreduction of classical and, derivatively, intuitionistic provability to uniform\nprovability via the addition to the assumption set of the negation of the\nformula to be proved. Our focus here is on understanding the situations in\nwhich this reduction is achieved. However, our discussions indicate the\nstructure of a proof procedure based on the reduction, a matter also considered\nexplicitly elsewhere."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9809015v1", 
    "other_authors": [
        "Gopalan Nadathur"
    ], 
    "lead_author": "Gopalan Nadathur", 
    "arxiv-id": "cs/9809015v1", 
    "title": "Correspondences between Classical, Intuitionistic and Uniform   Provability", 
    "publish": "1998-09-10T15:39:30Z", 
    "summary": "Based on an analysis of the inference rules used, we provide a\ncharacterization of the situations in which classical provability entails\nintuitionistic provability. We then examine the relationship of these\nderivability notions to uniform provability, a restriction of intuitionistic\nprovability that embodies a special form of goal-directedness. We determine,\nfirst, the circumstances in which the former relations imply the latter. Using\nthis result, we identify the richest versions of the so-called abstract logic\nprogramming languages in classical and intuitionistic logic. We then study the\nreduction of classical and, derivatively, intuitionistic provability to uniform\nprovability via the addition to the assumption set of the negation of the\nformula to be proved. Our focus here is on understanding the situations in\nwhich this reduction is achieved. However, our discussions indicate the\nstructure of a proof procedure based on the reduction, a matter also considered\nexplicitly elsewhere."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9809015v1", 
    "other_authors": [
        "Gopalan Nadathur"
    ], 
    "lead_author": "Gopalan Nadathur", 
    "arxiv-id": "cs/9809015v1", 
    "title": "Correspondences between Classical, Intuitionistic and Uniform   Provability", 
    "publish": "1998-09-10T15:39:30Z", 
    "summary": "Based on an analysis of the inference rules used, we provide a\ncharacterization of the situations in which classical provability entails\nintuitionistic provability. We then examine the relationship of these\nderivability notions to uniform provability, a restriction of intuitionistic\nprovability that embodies a special form of goal-directedness. We determine,\nfirst, the circumstances in which the former relations imply the latter. Using\nthis result, we identify the richest versions of the so-called abstract logic\nprogramming languages in classical and intuitionistic logic. We then study the\nreduction of classical and, derivatively, intuitionistic provability to uniform\nprovability via the addition to the assumption set of the negation of the\nformula to be proved. Our focus here is on understanding the situations in\nwhich this reduction is achieved. However, our discussions indicate the\nstructure of a proof procedure based on the reduction, a matter also considered\nexplicitly elsewhere."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9809015v1", 
    "other_authors": [
        "Gopalan Nadathur"
    ], 
    "lead_author": "Gopalan Nadathur", 
    "arxiv-id": "cs/9809015v1", 
    "title": "Correspondences between Classical, Intuitionistic and Uniform   Provability", 
    "publish": "1998-09-10T15:39:30Z", 
    "summary": "Based on an analysis of the inference rules used, we provide a\ncharacterization of the situations in which classical provability entails\nintuitionistic provability. We then examine the relationship of these\nderivability notions to uniform provability, a restriction of intuitionistic\nprovability that embodies a special form of goal-directedness. We determine,\nfirst, the circumstances in which the former relations imply the latter. Using\nthis result, we identify the richest versions of the so-called abstract logic\nprogramming languages in classical and intuitionistic logic. We then study the\nreduction of classical and, derivatively, intuitionistic provability to uniform\nprovability via the addition to the assumption set of the negation of the\nformula to be proved. Our focus here is on understanding the situations in\nwhich this reduction is achieved. However, our discussions indicate the\nstructure of a proof procedure based on the reduction, a matter also considered\nexplicitly elsewhere."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9809015v1", 
    "other_authors": [
        "Gopalan Nadathur"
    ], 
    "lead_author": "Gopalan Nadathur", 
    "arxiv-id": "cs/9809015v1", 
    "title": "Correspondences between Classical, Intuitionistic and Uniform   Provability", 
    "publish": "1998-09-10T15:39:30Z", 
    "summary": "Based on an analysis of the inference rules used, we provide a\ncharacterization of the situations in which classical provability entails\nintuitionistic provability. We then examine the relationship of these\nderivability notions to uniform provability, a restriction of intuitionistic\nprovability that embodies a special form of goal-directedness. We determine,\nfirst, the circumstances in which the former relations imply the latter. Using\nthis result, we identify the richest versions of the so-called abstract logic\nprogramming languages in classical and intuitionistic logic. We then study the\nreduction of classical and, derivatively, intuitionistic provability to uniform\nprovability via the addition to the assumption set of the negation of the\nformula to be proved. Our focus here is on understanding the situations in\nwhich this reduction is achieved. However, our discussions indicate the\nstructure of a proof procedure based on the reduction, a matter also considered\nexplicitly elsewhere."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9809015v1", 
    "other_authors": [
        "Gopalan Nadathur"
    ], 
    "lead_author": "Gopalan Nadathur", 
    "arxiv-id": "cs/9809015v1", 
    "title": "Correspondences between Classical, Intuitionistic and Uniform   Provability", 
    "publish": "1998-09-10T15:39:30Z", 
    "summary": "Based on an analysis of the inference rules used, we provide a\ncharacterization of the situations in which classical provability entails\nintuitionistic provability. We then examine the relationship of these\nderivability notions to uniform provability, a restriction of intuitionistic\nprovability that embodies a special form of goal-directedness. We determine,\nfirst, the circumstances in which the former relations imply the latter. Using\nthis result, we identify the richest versions of the so-called abstract logic\nprogramming languages in classical and intuitionistic logic. We then study the\nreduction of classical and, derivatively, intuitionistic provability to uniform\nprovability via the addition to the assumption set of the negation of the\nformula to be proved. Our focus here is on understanding the situations in\nwhich this reduction is achieved. However, our discussions indicate the\nstructure of a proof procedure based on the reduction, a matter also considered\nexplicitly elsewhere."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9809015v1", 
    "other_authors": [
        "Gopalan Nadathur"
    ], 
    "lead_author": "Gopalan Nadathur", 
    "arxiv-id": "cs/9809015v1", 
    "title": "Correspondences between Classical, Intuitionistic and Uniform   Provability", 
    "publish": "1998-09-10T15:39:30Z", 
    "summary": "Based on an analysis of the inference rules used, we provide a\ncharacterization of the situations in which classical provability entails\nintuitionistic provability. We then examine the relationship of these\nderivability notions to uniform provability, a restriction of intuitionistic\nprovability that embodies a special form of goal-directedness. We determine,\nfirst, the circumstances in which the former relations imply the latter. Using\nthis result, we identify the richest versions of the so-called abstract logic\nprogramming languages in classical and intuitionistic logic. We then study the\nreduction of classical and, derivatively, intuitionistic provability to uniform\nprovability via the addition to the assumption set of the negation of the\nformula to be proved. Our focus here is on understanding the situations in\nwhich this reduction is achieved. However, our discussions indicate the\nstructure of a proof procedure based on the reduction, a matter also considered\nexplicitly elsewhere."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9809015v1", 
    "other_authors": [
        "Gopalan Nadathur"
    ], 
    "lead_author": "Gopalan Nadathur", 
    "arxiv-id": "cs/9809015v1", 
    "title": "Correspondences between Classical, Intuitionistic and Uniform   Provability", 
    "publish": "1998-09-10T15:39:30Z", 
    "summary": "Based on an analysis of the inference rules used, we provide a\ncharacterization of the situations in which classical provability entails\nintuitionistic provability. We then examine the relationship of these\nderivability notions to uniform provability, a restriction of intuitionistic\nprovability that embodies a special form of goal-directedness. We determine,\nfirst, the circumstances in which the former relations imply the latter. Using\nthis result, we identify the richest versions of the so-called abstract logic\nprogramming languages in classical and intuitionistic logic. We then study the\nreduction of classical and, derivatively, intuitionistic provability to uniform\nprovability via the addition to the assumption set of the negation of the\nformula to be proved. Our focus here is on understanding the situations in\nwhich this reduction is achieved. However, our discussions indicate the\nstructure of a proof procedure based on the reduction, a matter also considered\nexplicitly elsewhere."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9809015v1", 
    "other_authors": [
        "Gopalan Nadathur"
    ], 
    "lead_author": "Gopalan Nadathur", 
    "arxiv-id": "cs/9809015v1", 
    "title": "Correspondences between Classical, Intuitionistic and Uniform   Provability", 
    "publish": "1998-09-10T15:39:30Z", 
    "summary": "Based on an analysis of the inference rules used, we provide a\ncharacterization of the situations in which classical provability entails\nintuitionistic provability. We then examine the relationship of these\nderivability notions to uniform provability, a restriction of intuitionistic\nprovability that embodies a special form of goal-directedness. We determine,\nfirst, the circumstances in which the former relations imply the latter. Using\nthis result, we identify the richest versions of the so-called abstract logic\nprogramming languages in classical and intuitionistic logic. We then study the\nreduction of classical and, derivatively, intuitionistic provability to uniform\nprovability via the addition to the assumption set of the negation of the\nformula to be proved. Our focus here is on understanding the situations in\nwhich this reduction is achieved. However, our discussions indicate the\nstructure of a proof procedure based on the reduction, a matter also considered\nexplicitly elsewhere."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9809015v1", 
    "other_authors": [
        "Gopalan Nadathur"
    ], 
    "lead_author": "Gopalan Nadathur", 
    "arxiv-id": "cs/9809015v1", 
    "title": "Correspondences between Classical, Intuitionistic and Uniform   Provability", 
    "publish": "1998-09-10T15:39:30Z", 
    "summary": "Based on an analysis of the inference rules used, we provide a\ncharacterization of the situations in which classical provability entails\nintuitionistic provability. We then examine the relationship of these\nderivability notions to uniform provability, a restriction of intuitionistic\nprovability that embodies a special form of goal-directedness. We determine,\nfirst, the circumstances in which the former relations imply the latter. Using\nthis result, we identify the richest versions of the so-called abstract logic\nprogramming languages in classical and intuitionistic logic. We then study the\nreduction of classical and, derivatively, intuitionistic provability to uniform\nprovability via the addition to the assumption set of the negation of the\nformula to be proved. Our focus here is on understanding the situations in\nwhich this reduction is achieved. However, our discussions indicate the\nstructure of a proof procedure based on the reduction, a matter also considered\nexplicitly elsewhere."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9809015v1", 
    "other_authors": [
        "Gopalan Nadathur"
    ], 
    "lead_author": "Gopalan Nadathur", 
    "arxiv-id": "cs/9809015v1", 
    "title": "Correspondences between Classical, Intuitionistic and Uniform   Provability", 
    "publish": "1998-09-10T15:39:30Z", 
    "summary": "Based on an analysis of the inference rules used, we provide a\ncharacterization of the situations in which classical provability entails\nintuitionistic provability. We then examine the relationship of these\nderivability notions to uniform provability, a restriction of intuitionistic\nprovability that embodies a special form of goal-directedness. We determine,\nfirst, the circumstances in which the former relations imply the latter. Using\nthis result, we identify the richest versions of the so-called abstract logic\nprogramming languages in classical and intuitionistic logic. We then study the\nreduction of classical and, derivatively, intuitionistic provability to uniform\nprovability via the addition to the assumption set of the negation of the\nformula to be proved. Our focus here is on understanding the situations in\nwhich this reduction is achieved. However, our discussions indicate the\nstructure of a proof procedure based on the reduction, a matter also considered\nexplicitly elsewhere."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9809015v1", 
    "other_authors": [
        "Gopalan Nadathur"
    ], 
    "lead_author": "Gopalan Nadathur", 
    "arxiv-id": "cs/9809015v1", 
    "title": "Correspondences between Classical, Intuitionistic and Uniform   Provability", 
    "publish": "1998-09-10T15:39:30Z", 
    "summary": "Based on an analysis of the inference rules used, we provide a\ncharacterization of the situations in which classical provability entails\nintuitionistic provability. We then examine the relationship of these\nderivability notions to uniform provability, a restriction of intuitionistic\nprovability that embodies a special form of goal-directedness. We determine,\nfirst, the circumstances in which the former relations imply the latter. Using\nthis result, we identify the richest versions of the so-called abstract logic\nprogramming languages in classical and intuitionistic logic. We then study the\nreduction of classical and, derivatively, intuitionistic provability to uniform\nprovability via the addition to the assumption set of the negation of the\nformula to be proved. Our focus here is on understanding the situations in\nwhich this reduction is achieved. However, our discussions indicate the\nstructure of a proof procedure based on the reduction, a matter also considered\nexplicitly elsewhere."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9809015v1", 
    "other_authors": [
        "Gopalan Nadathur"
    ], 
    "lead_author": "Gopalan Nadathur", 
    "arxiv-id": "cs/9809015v1", 
    "title": "Correspondences between Classical, Intuitionistic and Uniform   Provability", 
    "publish": "1998-09-10T15:39:30Z", 
    "summary": "Based on an analysis of the inference rules used, we provide a\ncharacterization of the situations in which classical provability entails\nintuitionistic provability. We then examine the relationship of these\nderivability notions to uniform provability, a restriction of intuitionistic\nprovability that embodies a special form of goal-directedness. We determine,\nfirst, the circumstances in which the former relations imply the latter. Using\nthis result, we identify the richest versions of the so-called abstract logic\nprogramming languages in classical and intuitionistic logic. We then study the\nreduction of classical and, derivatively, intuitionistic provability to uniform\nprovability via the addition to the assumption set of the negation of the\nformula to be proved. Our focus here is on understanding the situations in\nwhich this reduction is achieved. However, our discussions indicate the\nstructure of a proof procedure based on the reduction, a matter also considered\nexplicitly elsewhere."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9809015v1", 
    "other_authors": [
        "Gopalan Nadathur"
    ], 
    "lead_author": "Gopalan Nadathur", 
    "arxiv-id": "cs/9809015v1", 
    "title": "Correspondences between Classical, Intuitionistic and Uniform   Provability", 
    "publish": "1998-09-10T15:39:30Z", 
    "summary": "Based on an analysis of the inference rules used, we provide a\ncharacterization of the situations in which classical provability entails\nintuitionistic provability. We then examine the relationship of these\nderivability notions to uniform provability, a restriction of intuitionistic\nprovability that embodies a special form of goal-directedness. We determine,\nfirst, the circumstances in which the former relations imply the latter. Using\nthis result, we identify the richest versions of the so-called abstract logic\nprogramming languages in classical and intuitionistic logic. We then study the\nreduction of classical and, derivatively, intuitionistic provability to uniform\nprovability via the addition to the assumption set of the negation of the\nformula to be proved. Our focus here is on understanding the situations in\nwhich this reduction is achieved. However, our discussions indicate the\nstructure of a proof procedure based on the reduction, a matter also considered\nexplicitly elsewhere."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9809120v1", 
    "other_authors": [
        "Marino Miculan"
    ], 
    "lead_author": "Marino Miculan", 
    "arxiv-id": "cs/9809120v1", 
    "title": "A Natural Deduction style proof system for propositional $\u03bc$-calculus   and its formalization in inductive type theories", 
    "publish": "1998-09-29T11:57:32Z", 
    "summary": "In this paper, we present a formalization of Kozen's propositional modal\n$\\mu$-calculus, in the Calculus of Inductive Constructions. We address several\nproblematic issues, such as the use of higher-order abstract syntax in\ninductive sets in presence of recursive constructors, the encoding of modal\n(``proof'') rules and of context sensitive grammars. The encoding can be used\nin the \\Coq system, providing an experimental computer-aided proof environment\nfor the interactive development of error-free proofs in the $\\mu$-calculus. The\ntechniques we adopted can be readily ported to other languages and proof\nsystems featuring similar problematic issues."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9809120v1", 
    "other_authors": [
        "Marino Miculan"
    ], 
    "lead_author": "Marino Miculan", 
    "arxiv-id": "cs/9809120v1", 
    "title": "A Natural Deduction style proof system for propositional $\u03bc$-calculus   and its formalization in inductive type theories", 
    "publish": "1998-09-29T11:57:32Z", 
    "summary": "In this paper, we present a formalization of Kozen's propositional modal\n$\\mu$-calculus, in the Calculus of Inductive Constructions. We address several\nproblematic issues, such as the use of higher-order abstract syntax in\ninductive sets in presence of recursive constructors, the encoding of modal\n(``proof'') rules and of context sensitive grammars. The encoding can be used\nin the \\Coq system, providing an experimental computer-aided proof environment\nfor the interactive development of error-free proofs in the $\\mu$-calculus. The\ntechniques we adopted can be readily ported to other languages and proof\nsystems featuring similar problematic issues."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9809120v1", 
    "other_authors": [
        "Marino Miculan"
    ], 
    "lead_author": "Marino Miculan", 
    "arxiv-id": "cs/9809120v1", 
    "title": "A Natural Deduction style proof system for propositional $\u03bc$-calculus   and its formalization in inductive type theories", 
    "publish": "1998-09-29T11:57:32Z", 
    "summary": "In this paper, we present a formalization of Kozen's propositional modal\n$\\mu$-calculus, in the Calculus of Inductive Constructions. We address several\nproblematic issues, such as the use of higher-order abstract syntax in\ninductive sets in presence of recursive constructors, the encoding of modal\n(``proof'') rules and of context sensitive grammars. The encoding can be used\nin the \\Coq system, providing an experimental computer-aided proof environment\nfor the interactive development of error-free proofs in the $\\mu$-calculus. The\ntechniques we adopted can be readily ported to other languages and proof\nsystems featuring similar problematic issues."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9809120v1", 
    "other_authors": [
        "Marino Miculan"
    ], 
    "lead_author": "Marino Miculan", 
    "arxiv-id": "cs/9809120v1", 
    "title": "A Natural Deduction style proof system for propositional $\u03bc$-calculus   and its formalization in inductive type theories", 
    "publish": "1998-09-29T11:57:32Z", 
    "summary": "In this paper, we present a formalization of Kozen's propositional modal\n$\\mu$-calculus, in the Calculus of Inductive Constructions. We address several\nproblematic issues, such as the use of higher-order abstract syntax in\ninductive sets in presence of recursive constructors, the encoding of modal\n(``proof'') rules and of context sensitive grammars. The encoding can be used\nin the \\Coq system, providing an experimental computer-aided proof environment\nfor the interactive development of error-free proofs in the $\\mu$-calculus. The\ntechniques we adopted can be readily ported to other languages and proof\nsystems featuring similar problematic issues."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9809120v1", 
    "other_authors": [
        "Marino Miculan"
    ], 
    "lead_author": "Marino Miculan", 
    "arxiv-id": "cs/9809120v1", 
    "title": "A Natural Deduction style proof system for propositional $\u03bc$-calculus   and its formalization in inductive type theories", 
    "publish": "1998-09-29T11:57:32Z", 
    "summary": "In this paper, we present a formalization of Kozen's propositional modal\n$\\mu$-calculus, in the Calculus of Inductive Constructions. We address several\nproblematic issues, such as the use of higher-order abstract syntax in\ninductive sets in presence of recursive constructors, the encoding of modal\n(``proof'') rules and of context sensitive grammars. The encoding can be used\nin the \\Coq system, providing an experimental computer-aided proof environment\nfor the interactive development of error-free proofs in the $\\mu$-calculus. The\ntechniques we adopted can be readily ported to other languages and proof\nsystems featuring similar problematic issues."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9809120v1", 
    "other_authors": [
        "Marino Miculan"
    ], 
    "lead_author": "Marino Miculan", 
    "arxiv-id": "cs/9809120v1", 
    "title": "A Natural Deduction style proof system for propositional $\u03bc$-calculus   and its formalization in inductive type theories", 
    "publish": "1998-09-29T11:57:32Z", 
    "summary": "In this paper, we present a formalization of Kozen's propositional modal\n$\\mu$-calculus, in the Calculus of Inductive Constructions. We address several\nproblematic issues, such as the use of higher-order abstract syntax in\ninductive sets in presence of recursive constructors, the encoding of modal\n(``proof'') rules and of context sensitive grammars. The encoding can be used\nin the \\Coq system, providing an experimental computer-aided proof environment\nfor the interactive development of error-free proofs in the $\\mu$-calculus. The\ntechniques we adopted can be readily ported to other languages and proof\nsystems featuring similar problematic issues."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9809120v1", 
    "other_authors": [
        "Marino Miculan"
    ], 
    "lead_author": "Marino Miculan", 
    "arxiv-id": "cs/9809120v1", 
    "title": "A Natural Deduction style proof system for propositional $\u03bc$-calculus   and its formalization in inductive type theories", 
    "publish": "1998-09-29T11:57:32Z", 
    "summary": "In this paper, we present a formalization of Kozen's propositional modal\n$\\mu$-calculus, in the Calculus of Inductive Constructions. We address several\nproblematic issues, such as the use of higher-order abstract syntax in\ninductive sets in presence of recursive constructors, the encoding of modal\n(``proof'') rules and of context sensitive grammars. The encoding can be used\nin the \\Coq system, providing an experimental computer-aided proof environment\nfor the interactive development of error-free proofs in the $\\mu$-calculus. The\ntechniques we adopted can be readily ported to other languages and proof\nsystems featuring similar problematic issues."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9809120v1", 
    "other_authors": [
        "Marino Miculan"
    ], 
    "lead_author": "Marino Miculan", 
    "arxiv-id": "cs/9809120v1", 
    "title": "A Natural Deduction style proof system for propositional $\u03bc$-calculus   and its formalization in inductive type theories", 
    "publish": "1998-09-29T11:57:32Z", 
    "summary": "In this paper, we present a formalization of Kozen's propositional modal\n$\\mu$-calculus, in the Calculus of Inductive Constructions. We address several\nproblematic issues, such as the use of higher-order abstract syntax in\ninductive sets in presence of recursive constructors, the encoding of modal\n(``proof'') rules and of context sensitive grammars. The encoding can be used\nin the \\Coq system, providing an experimental computer-aided proof environment\nfor the interactive development of error-free proofs in the $\\mu$-calculus. The\ntechniques we adopted can be readily ported to other languages and proof\nsystems featuring similar problematic issues."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9809120v1", 
    "other_authors": [
        "Marino Miculan"
    ], 
    "lead_author": "Marino Miculan", 
    "arxiv-id": "cs/9809120v1", 
    "title": "A Natural Deduction style proof system for propositional $\u03bc$-calculus   and its formalization in inductive type theories", 
    "publish": "1998-09-29T11:57:32Z", 
    "summary": "In this paper, we present a formalization of Kozen's propositional modal\n$\\mu$-calculus, in the Calculus of Inductive Constructions. We address several\nproblematic issues, such as the use of higher-order abstract syntax in\ninductive sets in presence of recursive constructors, the encoding of modal\n(``proof'') rules and of context sensitive grammars. The encoding can be used\nin the \\Coq system, providing an experimental computer-aided proof environment\nfor the interactive development of error-free proofs in the $\\mu$-calculus. The\ntechniques we adopted can be readily ported to other languages and proof\nsystems featuring similar problematic issues."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9809120v1", 
    "other_authors": [
        "Marino Miculan"
    ], 
    "lead_author": "Marino Miculan", 
    "arxiv-id": "cs/9809120v1", 
    "title": "A Natural Deduction style proof system for propositional $\u03bc$-calculus   and its formalization in inductive type theories", 
    "publish": "1998-09-29T11:57:32Z", 
    "summary": "In this paper, we present a formalization of Kozen's propositional modal\n$\\mu$-calculus, in the Calculus of Inductive Constructions. We address several\nproblematic issues, such as the use of higher-order abstract syntax in\ninductive sets in presence of recursive constructors, the encoding of modal\n(``proof'') rules and of context sensitive grammars. The encoding can be used\nin the \\Coq system, providing an experimental computer-aided proof environment\nfor the interactive development of error-free proofs in the $\\mu$-calculus. The\ntechniques we adopted can be readily ported to other languages and proof\nsystems featuring similar problematic issues."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9809120v1", 
    "other_authors": [
        "Marino Miculan"
    ], 
    "lead_author": "Marino Miculan", 
    "arxiv-id": "cs/9809120v1", 
    "title": "A Natural Deduction style proof system for propositional $\u03bc$-calculus   and its formalization in inductive type theories", 
    "publish": "1998-09-29T11:57:32Z", 
    "summary": "In this paper, we present a formalization of Kozen's propositional modal\n$\\mu$-calculus, in the Calculus of Inductive Constructions. We address several\nproblematic issues, such as the use of higher-order abstract syntax in\ninductive sets in presence of recursive constructors, the encoding of modal\n(``proof'') rules and of context sensitive grammars. The encoding can be used\nin the \\Coq system, providing an experimental computer-aided proof environment\nfor the interactive development of error-free proofs in the $\\mu$-calculus. The\ntechniques we adopted can be readily ported to other languages and proof\nsystems featuring similar problematic issues."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9809120v1", 
    "other_authors": [
        "Marino Miculan"
    ], 
    "lead_author": "Marino Miculan", 
    "arxiv-id": "cs/9809120v1", 
    "title": "A Natural Deduction style proof system for propositional $\u03bc$-calculus   and its formalization in inductive type theories", 
    "publish": "1998-09-29T11:57:32Z", 
    "summary": "In this paper, we present a formalization of Kozen's propositional modal\n$\\mu$-calculus, in the Calculus of Inductive Constructions. We address several\nproblematic issues, such as the use of higher-order abstract syntax in\ninductive sets in presence of recursive constructors, the encoding of modal\n(``proof'') rules and of context sensitive grammars. The encoding can be used\nin the \\Coq system, providing an experimental computer-aided proof environment\nfor the interactive development of error-free proofs in the $\\mu$-calculus. The\ntechniques we adopted can be readily ported to other languages and proof\nsystems featuring similar problematic issues."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9809120v1", 
    "other_authors": [
        "Marino Miculan"
    ], 
    "lead_author": "Marino Miculan", 
    "arxiv-id": "cs/9809120v1", 
    "title": "A Natural Deduction style proof system for propositional $\u03bc$-calculus   and its formalization in inductive type theories", 
    "publish": "1998-09-29T11:57:32Z", 
    "summary": "In this paper, we present a formalization of Kozen's propositional modal\n$\\mu$-calculus, in the Calculus of Inductive Constructions. We address several\nproblematic issues, such as the use of higher-order abstract syntax in\ninductive sets in presence of recursive constructors, the encoding of modal\n(``proof'') rules and of context sensitive grammars. The encoding can be used\nin the \\Coq system, providing an experimental computer-aided proof environment\nfor the interactive development of error-free proofs in the $\\mu$-calculus. The\ntechniques we adopted can be readily ported to other languages and proof\nsystems featuring similar problematic issues."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9809120v1", 
    "other_authors": [
        "Marino Miculan"
    ], 
    "lead_author": "Marino Miculan", 
    "arxiv-id": "cs/9809120v1", 
    "title": "A Natural Deduction style proof system for propositional $\u03bc$-calculus   and its formalization in inductive type theories", 
    "publish": "1998-09-29T11:57:32Z", 
    "summary": "In this paper, we present a formalization of Kozen's propositional modal\n$\\mu$-calculus, in the Calculus of Inductive Constructions. We address several\nproblematic issues, such as the use of higher-order abstract syntax in\ninductive sets in presence of recursive constructors, the encoding of modal\n(``proof'') rules and of context sensitive grammars. The encoding can be used\nin the \\Coq system, providing an experimental computer-aided proof environment\nfor the interactive development of error-free proofs in the $\\mu$-calculus. The\ntechniques we adopted can be readily ported to other languages and proof\nsystems featuring similar problematic issues."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9809120v1", 
    "other_authors": [
        "Marino Miculan"
    ], 
    "lead_author": "Marino Miculan", 
    "arxiv-id": "cs/9809120v1", 
    "title": "A Natural Deduction style proof system for propositional $\u03bc$-calculus   and its formalization in inductive type theories", 
    "publish": "1998-09-29T11:57:32Z", 
    "summary": "In this paper, we present a formalization of Kozen's propositional modal\n$\\mu$-calculus, in the Calculus of Inductive Constructions. We address several\nproblematic issues, such as the use of higher-order abstract syntax in\ninductive sets in presence of recursive constructors, the encoding of modal\n(``proof'') rules and of context sensitive grammars. The encoding can be used\nin the \\Coq system, providing an experimental computer-aided proof environment\nfor the interactive development of error-free proofs in the $\\mu$-calculus. The\ntechniques we adopted can be readily ported to other languages and proof\nsystems featuring similar problematic issues."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9809120v1", 
    "other_authors": [
        "Marino Miculan"
    ], 
    "lead_author": "Marino Miculan", 
    "arxiv-id": "cs/9809120v1", 
    "title": "A Natural Deduction style proof system for propositional $\u03bc$-calculus   and its formalization in inductive type theories", 
    "publish": "1998-09-29T11:57:32Z", 
    "summary": "In this paper, we present a formalization of Kozen's propositional modal\n$\\mu$-calculus, in the Calculus of Inductive Constructions. We address several\nproblematic issues, such as the use of higher-order abstract syntax in\ninductive sets in presence of recursive constructors, the encoding of modal\n(``proof'') rules and of context sensitive grammars. The encoding can be used\nin the \\Coq system, providing an experimental computer-aided proof environment\nfor the interactive development of error-free proofs in the $\\mu$-calculus. The\ntechniques we adopted can be readily ported to other languages and proof\nsystems featuring similar problematic issues."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9903006v1", 
    "other_authors": [
        "Anatoly D. Plotnikov"
    ], 
    "lead_author": "Anatoly D. Plotnikov", 
    "arxiv-id": "cs/9903006v1", 
    "title": "Designing SAT for HCP", 
    "publish": "1999-03-05T16:10:41Z", 
    "summary": "For arbitrary undirected graph $G$, we are designing SATISFIABILITY problem\n(SAT) for HCP, using tools of Boolean algebra only. The obtained SAT be the\nlogic formulation of conditions for Hamiltonian cycle existence, and use $m$\nBoolean variables, where $m$ is the number of graph edges. This Boolean\nexpression is true if and only if an initial graph is Hamiltonian. That is,\neach satisfying assignment of the Boolean variables determines a Hamiltonian\ncycle of $G$, and each Hamiltonian cycle of $G$ corresponds to a satisfying\nassignment of the Boolean variables. In common case, the obtained Boolean\nexpression may has an exponential length (the number of Boolean literals)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9903006v1", 
    "other_authors": [
        "Anatoly D. Plotnikov"
    ], 
    "lead_author": "Anatoly D. Plotnikov", 
    "arxiv-id": "cs/9903006v1", 
    "title": "Designing SAT for HCP", 
    "publish": "1999-03-05T16:10:41Z", 
    "summary": "For arbitrary undirected graph $G$, we are designing SATISFIABILITY problem\n(SAT) for HCP, using tools of Boolean algebra only. The obtained SAT be the\nlogic formulation of conditions for Hamiltonian cycle existence, and use $m$\nBoolean variables, where $m$ is the number of graph edges. This Boolean\nexpression is true if and only if an initial graph is Hamiltonian. That is,\neach satisfying assignment of the Boolean variables determines a Hamiltonian\ncycle of $G$, and each Hamiltonian cycle of $G$ corresponds to a satisfying\nassignment of the Boolean variables. In common case, the obtained Boolean\nexpression may has an exponential length (the number of Boolean literals)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9903006v1", 
    "other_authors": [
        "Anatoly D. Plotnikov"
    ], 
    "lead_author": "Anatoly D. Plotnikov", 
    "arxiv-id": "cs/9903006v1", 
    "title": "Designing SAT for HCP", 
    "publish": "1999-03-05T16:10:41Z", 
    "summary": "For arbitrary undirected graph $G$, we are designing SATISFIABILITY problem\n(SAT) for HCP, using tools of Boolean algebra only. The obtained SAT be the\nlogic formulation of conditions for Hamiltonian cycle existence, and use $m$\nBoolean variables, where $m$ is the number of graph edges. This Boolean\nexpression is true if and only if an initial graph is Hamiltonian. That is,\neach satisfying assignment of the Boolean variables determines a Hamiltonian\ncycle of $G$, and each Hamiltonian cycle of $G$ corresponds to a satisfying\nassignment of the Boolean variables. In common case, the obtained Boolean\nexpression may has an exponential length (the number of Boolean literals)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9903006v1", 
    "other_authors": [
        "Anatoly D. Plotnikov"
    ], 
    "lead_author": "Anatoly D. Plotnikov", 
    "arxiv-id": "cs/9903006v1", 
    "title": "Designing SAT for HCP", 
    "publish": "1999-03-05T16:10:41Z", 
    "summary": "For arbitrary undirected graph $G$, we are designing SATISFIABILITY problem\n(SAT) for HCP, using tools of Boolean algebra only. The obtained SAT be the\nlogic formulation of conditions for Hamiltonian cycle existence, and use $m$\nBoolean variables, where $m$ is the number of graph edges. This Boolean\nexpression is true if and only if an initial graph is Hamiltonian. That is,\neach satisfying assignment of the Boolean variables determines a Hamiltonian\ncycle of $G$, and each Hamiltonian cycle of $G$ corresponds to a satisfying\nassignment of the Boolean variables. In common case, the obtained Boolean\nexpression may has an exponential length (the number of Boolean literals)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9907022v1", 
    "other_authors": [
        "Satoru Kuroda"
    ], 
    "lead_author": "Satoru Kuroda", 
    "arxiv-id": "cs/9907022v1", 
    "title": "Weak length induction and slow growing depth boolean circuits", 
    "publish": "1999-07-16T08:41:25Z", 
    "summary": "We define a hierarchy of circuit complexity classes LD^i, whose depth are the\ninverse of a function in Ackermann hierarchy. Then we introduce extremely weak\nversions of length induction and construct a bounded arithmetic theory L^i_2\nwhose provably total functions exactly correspond to functions computable by\nLD^i circuits. Finally, we prove a non-conservation result between L^i_2 and a\nweaker theory AC^0CA which corresponds to the class AC^0. Our proof utilizes\nKPT witnessing theorem."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9907022v1", 
    "other_authors": [
        "Satoru Kuroda"
    ], 
    "lead_author": "Satoru Kuroda", 
    "arxiv-id": "cs/9907022v1", 
    "title": "Weak length induction and slow growing depth boolean circuits", 
    "publish": "1999-07-16T08:41:25Z", 
    "summary": "We define a hierarchy of circuit complexity classes LD^i, whose depth are the\ninverse of a function in Ackermann hierarchy. Then we introduce extremely weak\nversions of length induction and construct a bounded arithmetic theory L^i_2\nwhose provably total functions exactly correspond to functions computable by\nLD^i circuits. Finally, we prove a non-conservation result between L^i_2 and a\nweaker theory AC^0CA which corresponds to the class AC^0. Our proof utilizes\nKPT witnessing theorem."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9907022v1", 
    "other_authors": [
        "Satoru Kuroda"
    ], 
    "lead_author": "Satoru Kuroda", 
    "arxiv-id": "cs/9907022v1", 
    "title": "Weak length induction and slow growing depth boolean circuits", 
    "publish": "1999-07-16T08:41:25Z", 
    "summary": "We define a hierarchy of circuit complexity classes LD^i, whose depth are the\ninverse of a function in Ackermann hierarchy. Then we introduce extremely weak\nversions of length induction and construct a bounded arithmetic theory L^i_2\nwhose provably total functions exactly correspond to functions computable by\nLD^i circuits. Finally, we prove a non-conservation result between L^i_2 and a\nweaker theory AC^0CA which corresponds to the class AC^0. Our proof utilizes\nKPT witnessing theorem."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9907022v1", 
    "other_authors": [
        "Satoru Kuroda"
    ], 
    "lead_author": "Satoru Kuroda", 
    "arxiv-id": "cs/9907022v1", 
    "title": "Weak length induction and slow growing depth boolean circuits", 
    "publish": "1999-07-16T08:41:25Z", 
    "summary": "We define a hierarchy of circuit complexity classes LD^i, whose depth are the\ninverse of a function in Ackermann hierarchy. Then we introduce extremely weak\nversions of length induction and construct a bounded arithmetic theory L^i_2\nwhose provably total functions exactly correspond to functions computable by\nLD^i circuits. Finally, we prove a non-conservation result between L^i_2 and a\nweaker theory AC^0CA which corresponds to the class AC^0. Our proof utilizes\nKPT witnessing theorem."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9907022v1", 
    "other_authors": [
        "Satoru Kuroda"
    ], 
    "lead_author": "Satoru Kuroda", 
    "arxiv-id": "cs/9907022v1", 
    "title": "Weak length induction and slow growing depth boolean circuits", 
    "publish": "1999-07-16T08:41:25Z", 
    "summary": "We define a hierarchy of circuit complexity classes LD^i, whose depth are the\ninverse of a function in Ackermann hierarchy. Then we introduce extremely weak\nversions of length induction and construct a bounded arithmetic theory L^i_2\nwhose provably total functions exactly correspond to functions computable by\nLD^i circuits. Finally, we prove a non-conservation result between L^i_2 and a\nweaker theory AC^0CA which corresponds to the class AC^0. Our proof utilizes\nKPT witnessing theorem."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9907022v1", 
    "other_authors": [
        "Satoru Kuroda"
    ], 
    "lead_author": "Satoru Kuroda", 
    "arxiv-id": "cs/9907022v1", 
    "title": "Weak length induction and slow growing depth boolean circuits", 
    "publish": "1999-07-16T08:41:25Z", 
    "summary": "We define a hierarchy of circuit complexity classes LD^i, whose depth are the\ninverse of a function in Ackermann hierarchy. Then we introduce extremely weak\nversions of length induction and construct a bounded arithmetic theory L^i_2\nwhose provably total functions exactly correspond to functions computable by\nLD^i circuits. Finally, we prove a non-conservation result between L^i_2 and a\nweaker theory AC^0CA which corresponds to the class AC^0. Our proof utilizes\nKPT witnessing theorem."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9907022v1", 
    "other_authors": [
        "Satoru Kuroda"
    ], 
    "lead_author": "Satoru Kuroda", 
    "arxiv-id": "cs/9907022v1", 
    "title": "Weak length induction and slow growing depth boolean circuits", 
    "publish": "1999-07-16T08:41:25Z", 
    "summary": "We define a hierarchy of circuit complexity classes LD^i, whose depth are the\ninverse of a function in Ackermann hierarchy. Then we introduce extremely weak\nversions of length induction and construct a bounded arithmetic theory L^i_2\nwhose provably total functions exactly correspond to functions computable by\nLD^i circuits. Finally, we prove a non-conservation result between L^i_2 and a\nweaker theory AC^0CA which corresponds to the class AC^0. Our proof utilizes\nKPT witnessing theorem."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9907022v1", 
    "other_authors": [
        "Satoru Kuroda"
    ], 
    "lead_author": "Satoru Kuroda", 
    "arxiv-id": "cs/9907022v1", 
    "title": "Weak length induction and slow growing depth boolean circuits", 
    "publish": "1999-07-16T08:41:25Z", 
    "summary": "We define a hierarchy of circuit complexity classes LD^i, whose depth are the\ninverse of a function in Ackermann hierarchy. Then we introduce extremely weak\nversions of length induction and construct a bounded arithmetic theory L^i_2\nwhose provably total functions exactly correspond to functions computable by\nLD^i circuits. Finally, we prove a non-conservation result between L^i_2 and a\nweaker theory AC^0CA which corresponds to the class AC^0. Our proof utilizes\nKPT witnessing theorem."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9907022v1", 
    "other_authors": [
        "Satoru Kuroda"
    ], 
    "lead_author": "Satoru Kuroda", 
    "arxiv-id": "cs/9907022v1", 
    "title": "Weak length induction and slow growing depth boolean circuits", 
    "publish": "1999-07-16T08:41:25Z", 
    "summary": "We define a hierarchy of circuit complexity classes LD^i, whose depth are the\ninverse of a function in Ackermann hierarchy. Then we introduce extremely weak\nversions of length induction and construct a bounded arithmetic theory L^i_2\nwhose provably total functions exactly correspond to functions computable by\nLD^i circuits. Finally, we prove a non-conservation result between L^i_2 and a\nweaker theory AC^0CA which corresponds to the class AC^0. Our proof utilizes\nKPT witnessing theorem."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9907022v1", 
    "other_authors": [
        "Satoru Kuroda"
    ], 
    "lead_author": "Satoru Kuroda", 
    "arxiv-id": "cs/9907022v1", 
    "title": "Weak length induction and slow growing depth boolean circuits", 
    "publish": "1999-07-16T08:41:25Z", 
    "summary": "We define a hierarchy of circuit complexity classes LD^i, whose depth are the\ninverse of a function in Ackermann hierarchy. Then we introduce extremely weak\nversions of length induction and construct a bounded arithmetic theory L^i_2\nwhose provably total functions exactly correspond to functions computable by\nLD^i circuits. Finally, we prove a non-conservation result between L^i_2 and a\nweaker theory AC^0CA which corresponds to the class AC^0. Our proof utilizes\nKPT witnessing theorem."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9907022v1", 
    "other_authors": [
        "Satoru Kuroda"
    ], 
    "lead_author": "Satoru Kuroda", 
    "arxiv-id": "cs/9907022v1", 
    "title": "Weak length induction and slow growing depth boolean circuits", 
    "publish": "1999-07-16T08:41:25Z", 
    "summary": "We define a hierarchy of circuit complexity classes LD^i, whose depth are the\ninverse of a function in Ackermann hierarchy. Then we introduce extremely weak\nversions of length induction and construct a bounded arithmetic theory L^i_2\nwhose provably total functions exactly correspond to functions computable by\nLD^i circuits. Finally, we prove a non-conservation result between L^i_2 and a\nweaker theory AC^0CA which corresponds to the class AC^0. Our proof utilizes\nKPT witnessing theorem."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9907022v1", 
    "other_authors": [
        "Satoru Kuroda"
    ], 
    "lead_author": "Satoru Kuroda", 
    "arxiv-id": "cs/9907022v1", 
    "title": "Weak length induction and slow growing depth boolean circuits", 
    "publish": "1999-07-16T08:41:25Z", 
    "summary": "We define a hierarchy of circuit complexity classes LD^i, whose depth are the\ninverse of a function in Ackermann hierarchy. Then we introduce extremely weak\nversions of length induction and construct a bounded arithmetic theory L^i_2\nwhose provably total functions exactly correspond to functions computable by\nLD^i circuits. Finally, we prove a non-conservation result between L^i_2 and a\nweaker theory AC^0CA which corresponds to the class AC^0. Our proof utilizes\nKPT witnessing theorem."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9907022v1", 
    "other_authors": [
        "Satoru Kuroda"
    ], 
    "lead_author": "Satoru Kuroda", 
    "arxiv-id": "cs/9907022v1", 
    "title": "Weak length induction and slow growing depth boolean circuits", 
    "publish": "1999-07-16T08:41:25Z", 
    "summary": "We define a hierarchy of circuit complexity classes LD^i, whose depth are the\ninverse of a function in Ackermann hierarchy. Then we introduce extremely weak\nversions of length induction and construct a bounded arithmetic theory L^i_2\nwhose provably total functions exactly correspond to functions computable by\nLD^i circuits. Finally, we prove a non-conservation result between L^i_2 and a\nweaker theory AC^0CA which corresponds to the class AC^0. Our proof utilizes\nKPT witnessing theorem."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9907022v1", 
    "other_authors": [
        "Satoru Kuroda"
    ], 
    "lead_author": "Satoru Kuroda", 
    "arxiv-id": "cs/9907022v1", 
    "title": "Weak length induction and slow growing depth boolean circuits", 
    "publish": "1999-07-16T08:41:25Z", 
    "summary": "We define a hierarchy of circuit complexity classes LD^i, whose depth are the\ninverse of a function in Ackermann hierarchy. Then we introduce extremely weak\nversions of length induction and construct a bounded arithmetic theory L^i_2\nwhose provably total functions exactly correspond to functions computable by\nLD^i circuits. Finally, we prove a non-conservation result between L^i_2 and a\nweaker theory AC^0CA which corresponds to the class AC^0. Our proof utilizes\nKPT witnessing theorem."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9907022v1", 
    "other_authors": [
        "Satoru Kuroda"
    ], 
    "lead_author": "Satoru Kuroda", 
    "arxiv-id": "cs/9907022v1", 
    "title": "Weak length induction and slow growing depth boolean circuits", 
    "publish": "1999-07-16T08:41:25Z", 
    "summary": "We define a hierarchy of circuit complexity classes LD^i, whose depth are the\ninverse of a function in Ackermann hierarchy. Then we introduce extremely weak\nversions of length induction and construct a bounded arithmetic theory L^i_2\nwhose provably total functions exactly correspond to functions computable by\nLD^i circuits. Finally, we prove a non-conservation result between L^i_2 and a\nweaker theory AC^0CA which corresponds to the class AC^0. Our proof utilizes\nKPT witnessing theorem."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9907022v1", 
    "other_authors": [
        "Satoru Kuroda"
    ], 
    "lead_author": "Satoru Kuroda", 
    "arxiv-id": "cs/9907022v1", 
    "title": "Weak length induction and slow growing depth boolean circuits", 
    "publish": "1999-07-16T08:41:25Z", 
    "summary": "We define a hierarchy of circuit complexity classes LD^i, whose depth are the\ninverse of a function in Ackermann hierarchy. Then we introduce extremely weak\nversions of length induction and construct a bounded arithmetic theory L^i_2\nwhose provably total functions exactly correspond to functions computable by\nLD^i circuits. Finally, we prove a non-conservation result between L^i_2 and a\nweaker theory AC^0CA which corresponds to the class AC^0. Our proof utilizes\nKPT witnessing theorem."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9907022v1", 
    "other_authors": [
        "Satoru Kuroda"
    ], 
    "lead_author": "Satoru Kuroda", 
    "arxiv-id": "cs/9907022v1", 
    "title": "Weak length induction and slow growing depth boolean circuits", 
    "publish": "1999-07-16T08:41:25Z", 
    "summary": "We define a hierarchy of circuit complexity classes LD^i, whose depth are the\ninverse of a function in Ackermann hierarchy. Then we introduce extremely weak\nversions of length induction and construct a bounded arithmetic theory L^i_2\nwhose provably total functions exactly correspond to functions computable by\nLD^i circuits. Finally, we prove a non-conservation result between L^i_2 and a\nweaker theory AC^0CA which corresponds to the class AC^0. Our proof utilizes\nKPT witnessing theorem."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9907022v1", 
    "other_authors": [
        "Satoru Kuroda"
    ], 
    "lead_author": "Satoru Kuroda", 
    "arxiv-id": "cs/9907022v1", 
    "title": "Weak length induction and slow growing depth boolean circuits", 
    "publish": "1999-07-16T08:41:25Z", 
    "summary": "We define a hierarchy of circuit complexity classes LD^i, whose depth are the\ninverse of a function in Ackermann hierarchy. Then we introduce extremely weak\nversions of length induction and construct a bounded arithmetic theory L^i_2\nwhose provably total functions exactly correspond to functions computable by\nLD^i circuits. Finally, we prove a non-conservation result between L^i_2 and a\nweaker theory AC^0CA which corresponds to the class AC^0. Our proof utilizes\nKPT witnessing theorem."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9907022v1", 
    "other_authors": [
        "Satoru Kuroda"
    ], 
    "lead_author": "Satoru Kuroda", 
    "arxiv-id": "cs/9907022v1", 
    "title": "Weak length induction and slow growing depth boolean circuits", 
    "publish": "1999-07-16T08:41:25Z", 
    "summary": "We define a hierarchy of circuit complexity classes LD^i, whose depth are the\ninverse of a function in Ackermann hierarchy. Then we introduce extremely weak\nversions of length induction and construct a bounded arithmetic theory L^i_2\nwhose provably total functions exactly correspond to functions computable by\nLD^i circuits. Finally, we prove a non-conservation result between L^i_2 and a\nweaker theory AC^0CA which corresponds to the class AC^0. Our proof utilizes\nKPT witnessing theorem."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9907022v1", 
    "other_authors": [
        "Satoru Kuroda"
    ], 
    "lead_author": "Satoru Kuroda", 
    "arxiv-id": "cs/9907022v1", 
    "title": "Weak length induction and slow growing depth boolean circuits", 
    "publish": "1999-07-16T08:41:25Z", 
    "summary": "We define a hierarchy of circuit complexity classes LD^i, whose depth are the\ninverse of a function in Ackermann hierarchy. Then we introduce extremely weak\nversions of length induction and construct a bounded arithmetic theory L^i_2\nwhose provably total functions exactly correspond to functions computable by\nLD^i circuits. Finally, we prove a non-conservation result between L^i_2 and a\nweaker theory AC^0CA which corresponds to the class AC^0. Our proof utilizes\nKPT witnessing theorem."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9907022v1", 
    "other_authors": [
        "Satoru Kuroda"
    ], 
    "lead_author": "Satoru Kuroda", 
    "arxiv-id": "cs/9907022v1", 
    "title": "Weak length induction and slow growing depth boolean circuits", 
    "publish": "1999-07-16T08:41:25Z", 
    "summary": "We define a hierarchy of circuit complexity classes LD^i, whose depth are the\ninverse of a function in Ackermann hierarchy. Then we introduce extremely weak\nversions of length induction and construct a bounded arithmetic theory L^i_2\nwhose provably total functions exactly correspond to functions computable by\nLD^i circuits. Finally, we prove a non-conservation result between L^i_2 and a\nweaker theory AC^0CA which corresponds to the class AC^0. Our proof utilizes\nKPT witnessing theorem."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9907022v1", 
    "other_authors": [
        "Satoru Kuroda"
    ], 
    "lead_author": "Satoru Kuroda", 
    "arxiv-id": "cs/9907022v1", 
    "title": "Weak length induction and slow growing depth boolean circuits", 
    "publish": "1999-07-16T08:41:25Z", 
    "summary": "We define a hierarchy of circuit complexity classes LD^i, whose depth are the\ninverse of a function in Ackermann hierarchy. Then we introduce extremely weak\nversions of length induction and construct a bounded arithmetic theory L^i_2\nwhose provably total functions exactly correspond to functions computable by\nLD^i circuits. Finally, we prove a non-conservation result between L^i_2 and a\nweaker theory AC^0CA which corresponds to the class AC^0. Our proof utilizes\nKPT witnessing theorem."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9907022v1", 
    "other_authors": [
        "Satoru Kuroda"
    ], 
    "lead_author": "Satoru Kuroda", 
    "arxiv-id": "cs/9907022v1", 
    "title": "Weak length induction and slow growing depth boolean circuits", 
    "publish": "1999-07-16T08:41:25Z", 
    "summary": "We define a hierarchy of circuit complexity classes LD^i, whose depth are the\ninverse of a function in Ackermann hierarchy. Then we introduce extremely weak\nversions of length induction and construct a bounded arithmetic theory L^i_2\nwhose provably total functions exactly correspond to functions computable by\nLD^i circuits. Finally, we prove a non-conservation result between L^i_2 and a\nweaker theory AC^0CA which corresponds to the class AC^0. Our proof utilizes\nKPT witnessing theorem."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9907022v1", 
    "other_authors": [
        "Satoru Kuroda"
    ], 
    "lead_author": "Satoru Kuroda", 
    "arxiv-id": "cs/9907022v1", 
    "title": "Weak length induction and slow growing depth boolean circuits", 
    "publish": "1999-07-16T08:41:25Z", 
    "summary": "We define a hierarchy of circuit complexity classes LD^i, whose depth are the\ninverse of a function in Ackermann hierarchy. Then we introduce extremely weak\nversions of length induction and construct a bounded arithmetic theory L^i_2\nwhose provably total functions exactly correspond to functions computable by\nLD^i circuits. Finally, we prove a non-conservation result between L^i_2 and a\nweaker theory AC^0CA which corresponds to the class AC^0. Our proof utilizes\nKPT witnessing theorem."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9907022v1", 
    "other_authors": [
        "Satoru Kuroda"
    ], 
    "lead_author": "Satoru Kuroda", 
    "arxiv-id": "cs/9907022v1", 
    "title": "Weak length induction and slow growing depth boolean circuits", 
    "publish": "1999-07-16T08:41:25Z", 
    "summary": "We define a hierarchy of circuit complexity classes LD^i, whose depth are the\ninverse of a function in Ackermann hierarchy. Then we introduce extremely weak\nversions of length induction and construct a bounded arithmetic theory L^i_2\nwhose provably total functions exactly correspond to functions computable by\nLD^i circuits. Finally, we prove a non-conservation result between L^i_2 and a\nweaker theory AC^0CA which corresponds to the class AC^0. Our proof utilizes\nKPT witnessing theorem."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9907022v1", 
    "other_authors": [
        "Satoru Kuroda"
    ], 
    "lead_author": "Satoru Kuroda", 
    "arxiv-id": "cs/9907022v1", 
    "title": "Weak length induction and slow growing depth boolean circuits", 
    "publish": "1999-07-16T08:41:25Z", 
    "summary": "We define a hierarchy of circuit complexity classes LD^i, whose depth are the\ninverse of a function in Ackermann hierarchy. Then we introduce extremely weak\nversions of length induction and construct a bounded arithmetic theory L^i_2\nwhose provably total functions exactly correspond to functions computable by\nLD^i circuits. Finally, we prove a non-conservation result between L^i_2 and a\nweaker theory AC^0CA which corresponds to the class AC^0. Our proof utilizes\nKPT witnessing theorem."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9907022v1", 
    "other_authors": [
        "Satoru Kuroda"
    ], 
    "lead_author": "Satoru Kuroda", 
    "arxiv-id": "cs/9907022v1", 
    "title": "Weak length induction and slow growing depth boolean circuits", 
    "publish": "1999-07-16T08:41:25Z", 
    "summary": "We define a hierarchy of circuit complexity classes LD^i, whose depth are the\ninverse of a function in Ackermann hierarchy. Then we introduce extremely weak\nversions of length induction and construct a bounded arithmetic theory L^i_2\nwhose provably total functions exactly correspond to functions computable by\nLD^i circuits. Finally, we prove a non-conservation result between L^i_2 and a\nweaker theory AC^0CA which corresponds to the class AC^0. Our proof utilizes\nKPT witnessing theorem."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9907022v1", 
    "other_authors": [
        "Satoru Kuroda"
    ], 
    "lead_author": "Satoru Kuroda", 
    "arxiv-id": "cs/9907022v1", 
    "title": "Weak length induction and slow growing depth boolean circuits", 
    "publish": "1999-07-16T08:41:25Z", 
    "summary": "We define a hierarchy of circuit complexity classes LD^i, whose depth are the\ninverse of a function in Ackermann hierarchy. Then we introduce extremely weak\nversions of length induction and construct a bounded arithmetic theory L^i_2\nwhose provably total functions exactly correspond to functions computable by\nLD^i circuits. Finally, we prove a non-conservation result between L^i_2 and a\nweaker theory AC^0CA which corresponds to the class AC^0. Our proof utilizes\nKPT witnessing theorem."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9907022v1", 
    "other_authors": [
        "Satoru Kuroda"
    ], 
    "lead_author": "Satoru Kuroda", 
    "arxiv-id": "cs/9907022v1", 
    "title": "Weak length induction and slow growing depth boolean circuits", 
    "publish": "1999-07-16T08:41:25Z", 
    "summary": "We define a hierarchy of circuit complexity classes LD^i, whose depth are the\ninverse of a function in Ackermann hierarchy. Then we introduce extremely weak\nversions of length induction and construct a bounded arithmetic theory L^i_2\nwhose provably total functions exactly correspond to functions computable by\nLD^i circuits. Finally, we prove a non-conservation result between L^i_2 and a\nweaker theory AC^0CA which corresponds to the class AC^0. Our proof utilizes\nKPT witnessing theorem."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9907022v1", 
    "other_authors": [
        "Satoru Kuroda"
    ], 
    "lead_author": "Satoru Kuroda", 
    "arxiv-id": "cs/9907022v1", 
    "title": "Weak length induction and slow growing depth boolean circuits", 
    "publish": "1999-07-16T08:41:25Z", 
    "summary": "We define a hierarchy of circuit complexity classes LD^i, whose depth are the\ninverse of a function in Ackermann hierarchy. Then we introduce extremely weak\nversions of length induction and construct a bounded arithmetic theory L^i_2\nwhose provably total functions exactly correspond to functions computable by\nLD^i circuits. Finally, we prove a non-conservation result between L^i_2 and a\nweaker theory AC^0CA which corresponds to the class AC^0. Our proof utilizes\nKPT witnessing theorem."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9907022v1", 
    "other_authors": [
        "Satoru Kuroda"
    ], 
    "lead_author": "Satoru Kuroda", 
    "arxiv-id": "cs/9907022v1", 
    "title": "Weak length induction and slow growing depth boolean circuits", 
    "publish": "1999-07-16T08:41:25Z", 
    "summary": "We define a hierarchy of circuit complexity classes LD^i, whose depth are the\ninverse of a function in Ackermann hierarchy. Then we introduce extremely weak\nversions of length induction and construct a bounded arithmetic theory L^i_2\nwhose provably total functions exactly correspond to functions computable by\nLD^i circuits. Finally, we prove a non-conservation result between L^i_2 and a\nweaker theory AC^0CA which corresponds to the class AC^0. Our proof utilizes\nKPT witnessing theorem."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9907022v1", 
    "other_authors": [
        "Satoru Kuroda"
    ], 
    "lead_author": "Satoru Kuroda", 
    "arxiv-id": "cs/9907022v1", 
    "title": "Weak length induction and slow growing depth boolean circuits", 
    "publish": "1999-07-16T08:41:25Z", 
    "summary": "We define a hierarchy of circuit complexity classes LD^i, whose depth are the\ninverse of a function in Ackermann hierarchy. Then we introduce extremely weak\nversions of length induction and construct a bounded arithmetic theory L^i_2\nwhose provably total functions exactly correspond to functions computable by\nLD^i circuits. Finally, we prove a non-conservation result between L^i_2 and a\nweaker theory AC^0CA which corresponds to the class AC^0. Our proof utilizes\nKPT witnessing theorem."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9907022v1", 
    "other_authors": [
        "Satoru Kuroda"
    ], 
    "lead_author": "Satoru Kuroda", 
    "arxiv-id": "cs/9907022v1", 
    "title": "Weak length induction and slow growing depth boolean circuits", 
    "publish": "1999-07-16T08:41:25Z", 
    "summary": "We define a hierarchy of circuit complexity classes LD^i, whose depth are the\ninverse of a function in Ackermann hierarchy. Then we introduce extremely weak\nversions of length induction and construct a bounded arithmetic theory L^i_2\nwhose provably total functions exactly correspond to functions computable by\nLD^i circuits. Finally, we prove a non-conservation result between L^i_2 and a\nweaker theory AC^0CA which corresponds to the class AC^0. Our proof utilizes\nKPT witnessing theorem."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9910023v4", 
    "other_authors": [
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/9910023v4", 
    "title": "A System of Interaction and Structure", 
    "publish": "1999-10-28T09:17:34Z", 
    "summary": "This paper introduces a logical system, called BV, which extends\nmultiplicative linear logic by a non-commutative self-dual logical operator.\nThis extension is particularly challenging for the sequent calculus, and so far\nit is not achieved therein. It becomes very natural in a new formalism, called\nthe calculus of structures, which is the main contribution of this work.\nStructures are formulae submitted to certain equational laws typical of\nsequents. The calculus of structures is obtained by generalising the sequent\ncalculus in such a way that a new top-down symmetry of derivations is observed,\nand it employs inference rules that rewrite inside structures at any depth.\nThese properties, in addition to allow the design of BV, yield a modular proof\nof cut elimination."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9910023v4", 
    "other_authors": [
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/9910023v4", 
    "title": "A System of Interaction and Structure", 
    "publish": "1999-10-28T09:17:34Z", 
    "summary": "This paper introduces a logical system, called BV, which extends\nmultiplicative linear logic by a non-commutative self-dual logical operator.\nThis extension is particularly challenging for the sequent calculus, and so far\nit is not achieved therein. It becomes very natural in a new formalism, called\nthe calculus of structures, which is the main contribution of this work.\nStructures are formulae submitted to certain equational laws typical of\nsequents. The calculus of structures is obtained by generalising the sequent\ncalculus in such a way that a new top-down symmetry of derivations is observed,\nand it employs inference rules that rewrite inside structures at any depth.\nThese properties, in addition to allow the design of BV, yield a modular proof\nof cut elimination."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9910023v4", 
    "other_authors": [
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/9910023v4", 
    "title": "A System of Interaction and Structure", 
    "publish": "1999-10-28T09:17:34Z", 
    "summary": "This paper introduces a logical system, called BV, which extends\nmultiplicative linear logic by a non-commutative self-dual logical operator.\nThis extension is particularly challenging for the sequent calculus, and so far\nit is not achieved therein. It becomes very natural in a new formalism, called\nthe calculus of structures, which is the main contribution of this work.\nStructures are formulae submitted to certain equational laws typical of\nsequents. The calculus of structures is obtained by generalising the sequent\ncalculus in such a way that a new top-down symmetry of derivations is observed,\nand it employs inference rules that rewrite inside structures at any depth.\nThese properties, in addition to allow the design of BV, yield a modular proof\nof cut elimination."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9910023v4", 
    "other_authors": [
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/9910023v4", 
    "title": "A System of Interaction and Structure", 
    "publish": "1999-10-28T09:17:34Z", 
    "summary": "This paper introduces a logical system, called BV, which extends\nmultiplicative linear logic by a non-commutative self-dual logical operator.\nThis extension is particularly challenging for the sequent calculus, and so far\nit is not achieved therein. It becomes very natural in a new formalism, called\nthe calculus of structures, which is the main contribution of this work.\nStructures are formulae submitted to certain equational laws typical of\nsequents. The calculus of structures is obtained by generalising the sequent\ncalculus in such a way that a new top-down symmetry of derivations is observed,\nand it employs inference rules that rewrite inside structures at any depth.\nThese properties, in addition to allow the design of BV, yield a modular proof\nof cut elimination."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9910023v4", 
    "other_authors": [
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/9910023v4", 
    "title": "A System of Interaction and Structure", 
    "publish": "1999-10-28T09:17:34Z", 
    "summary": "This paper introduces a logical system, called BV, which extends\nmultiplicative linear logic by a non-commutative self-dual logical operator.\nThis extension is particularly challenging for the sequent calculus, and so far\nit is not achieved therein. It becomes very natural in a new formalism, called\nthe calculus of structures, which is the main contribution of this work.\nStructures are formulae submitted to certain equational laws typical of\nsequents. The calculus of structures is obtained by generalising the sequent\ncalculus in such a way that a new top-down symmetry of derivations is observed,\nand it employs inference rules that rewrite inside structures at any depth.\nThese properties, in addition to allow the design of BV, yield a modular proof\nof cut elimination."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9910023v4", 
    "other_authors": [
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/9910023v4", 
    "title": "A System of Interaction and Structure", 
    "publish": "1999-10-28T09:17:34Z", 
    "summary": "This paper introduces a logical system, called BV, which extends\nmultiplicative linear logic by a non-commutative self-dual logical operator.\nThis extension is particularly challenging for the sequent calculus, and so far\nit is not achieved therein. It becomes very natural in a new formalism, called\nthe calculus of structures, which is the main contribution of this work.\nStructures are formulae submitted to certain equational laws typical of\nsequents. The calculus of structures is obtained by generalising the sequent\ncalculus in such a way that a new top-down symmetry of derivations is observed,\nand it employs inference rules that rewrite inside structures at any depth.\nThese properties, in addition to allow the design of BV, yield a modular proof\nof cut elimination."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9910023v4", 
    "other_authors": [
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/9910023v4", 
    "title": "A System of Interaction and Structure", 
    "publish": "1999-10-28T09:17:34Z", 
    "summary": "This paper introduces a logical system, called BV, which extends\nmultiplicative linear logic by a non-commutative self-dual logical operator.\nThis extension is particularly challenging for the sequent calculus, and so far\nit is not achieved therein. It becomes very natural in a new formalism, called\nthe calculus of structures, which is the main contribution of this work.\nStructures are formulae submitted to certain equational laws typical of\nsequents. The calculus of structures is obtained by generalising the sequent\ncalculus in such a way that a new top-down symmetry of derivations is observed,\nand it employs inference rules that rewrite inside structures at any depth.\nThese properties, in addition to allow the design of BV, yield a modular proof\nof cut elimination."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9910023v4", 
    "other_authors": [
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/9910023v4", 
    "title": "A System of Interaction and Structure", 
    "publish": "1999-10-28T09:17:34Z", 
    "summary": "This paper introduces a logical system, called BV, which extends\nmultiplicative linear logic by a non-commutative self-dual logical operator.\nThis extension is particularly challenging for the sequent calculus, and so far\nit is not achieved therein. It becomes very natural in a new formalism, called\nthe calculus of structures, which is the main contribution of this work.\nStructures are formulae submitted to certain equational laws typical of\nsequents. The calculus of structures is obtained by generalising the sequent\ncalculus in such a way that a new top-down symmetry of derivations is observed,\nand it employs inference rules that rewrite inside structures at any depth.\nThese properties, in addition to allow the design of BV, yield a modular proof\nof cut elimination."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9910023v4", 
    "other_authors": [
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/9910023v4", 
    "title": "A System of Interaction and Structure", 
    "publish": "1999-10-28T09:17:34Z", 
    "summary": "This paper introduces a logical system, called BV, which extends\nmultiplicative linear logic by a non-commutative self-dual logical operator.\nThis extension is particularly challenging for the sequent calculus, and so far\nit is not achieved therein. It becomes very natural in a new formalism, called\nthe calculus of structures, which is the main contribution of this work.\nStructures are formulae submitted to certain equational laws typical of\nsequents. The calculus of structures is obtained by generalising the sequent\ncalculus in such a way that a new top-down symmetry of derivations is observed,\nand it employs inference rules that rewrite inside structures at any depth.\nThese properties, in addition to allow the design of BV, yield a modular proof\nof cut elimination."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9910023v4", 
    "other_authors": [
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/9910023v4", 
    "title": "A System of Interaction and Structure", 
    "publish": "1999-10-28T09:17:34Z", 
    "summary": "This paper introduces a logical system, called BV, which extends\nmultiplicative linear logic by a non-commutative self-dual logical operator.\nThis extension is particularly challenging for the sequent calculus, and so far\nit is not achieved therein. It becomes very natural in a new formalism, called\nthe calculus of structures, which is the main contribution of this work.\nStructures are formulae submitted to certain equational laws typical of\nsequents. The calculus of structures is obtained by generalising the sequent\ncalculus in such a way that a new top-down symmetry of derivations is observed,\nand it employs inference rules that rewrite inside structures at any depth.\nThese properties, in addition to allow the design of BV, yield a modular proof\nof cut elimination."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9910023v4", 
    "other_authors": [
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/9910023v4", 
    "title": "A System of Interaction and Structure", 
    "publish": "1999-10-28T09:17:34Z", 
    "summary": "This paper introduces a logical system, called BV, which extends\nmultiplicative linear logic by a non-commutative self-dual logical operator.\nThis extension is particularly challenging for the sequent calculus, and so far\nit is not achieved therein. It becomes very natural in a new formalism, called\nthe calculus of structures, which is the main contribution of this work.\nStructures are formulae submitted to certain equational laws typical of\nsequents. The calculus of structures is obtained by generalising the sequent\ncalculus in such a way that a new top-down symmetry of derivations is observed,\nand it employs inference rules that rewrite inside structures at any depth.\nThese properties, in addition to allow the design of BV, yield a modular proof\nof cut elimination."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9910023v4", 
    "other_authors": [
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/9910023v4", 
    "title": "A System of Interaction and Structure", 
    "publish": "1999-10-28T09:17:34Z", 
    "summary": "This paper introduces a logical system, called BV, which extends\nmultiplicative linear logic by a non-commutative self-dual logical operator.\nThis extension is particularly challenging for the sequent calculus, and so far\nit is not achieved therein. It becomes very natural in a new formalism, called\nthe calculus of structures, which is the main contribution of this work.\nStructures are formulae submitted to certain equational laws typical of\nsequents. The calculus of structures is obtained by generalising the sequent\ncalculus in such a way that a new top-down symmetry of derivations is observed,\nand it employs inference rules that rewrite inside structures at any depth.\nThese properties, in addition to allow the design of BV, yield a modular proof\nof cut elimination."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9910023v4", 
    "other_authors": [
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/9910023v4", 
    "title": "A System of Interaction and Structure", 
    "publish": "1999-10-28T09:17:34Z", 
    "summary": "This paper introduces a logical system, called BV, which extends\nmultiplicative linear logic by a non-commutative self-dual logical operator.\nThis extension is particularly challenging for the sequent calculus, and so far\nit is not achieved therein. It becomes very natural in a new formalism, called\nthe calculus of structures, which is the main contribution of this work.\nStructures are formulae submitted to certain equational laws typical of\nsequents. The calculus of structures is obtained by generalising the sequent\ncalculus in such a way that a new top-down symmetry of derivations is observed,\nand it employs inference rules that rewrite inside structures at any depth.\nThese properties, in addition to allow the design of BV, yield a modular proof\nof cut elimination."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9910023v4", 
    "other_authors": [
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/9910023v4", 
    "title": "A System of Interaction and Structure", 
    "publish": "1999-10-28T09:17:34Z", 
    "summary": "This paper introduces a logical system, called BV, which extends\nmultiplicative linear logic by a non-commutative self-dual logical operator.\nThis extension is particularly challenging for the sequent calculus, and so far\nit is not achieved therein. It becomes very natural in a new formalism, called\nthe calculus of structures, which is the main contribution of this work.\nStructures are formulae submitted to certain equational laws typical of\nsequents. The calculus of structures is obtained by generalising the sequent\ncalculus in such a way that a new top-down symmetry of derivations is observed,\nand it employs inference rules that rewrite inside structures at any depth.\nThese properties, in addition to allow the design of BV, yield a modular proof\nof cut elimination."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9910023v4", 
    "other_authors": [
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/9910023v4", 
    "title": "A System of Interaction and Structure", 
    "publish": "1999-10-28T09:17:34Z", 
    "summary": "This paper introduces a logical system, called BV, which extends\nmultiplicative linear logic by a non-commutative self-dual logical operator.\nThis extension is particularly challenging for the sequent calculus, and so far\nit is not achieved therein. It becomes very natural in a new formalism, called\nthe calculus of structures, which is the main contribution of this work.\nStructures are formulae submitted to certain equational laws typical of\nsequents. The calculus of structures is obtained by generalising the sequent\ncalculus in such a way that a new top-down symmetry of derivations is observed,\nand it employs inference rules that rewrite inside structures at any depth.\nThese properties, in addition to allow the design of BV, yield a modular proof\nof cut elimination."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9910023v4", 
    "other_authors": [
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/9910023v4", 
    "title": "A System of Interaction and Structure", 
    "publish": "1999-10-28T09:17:34Z", 
    "summary": "This paper introduces a logical system, called BV, which extends\nmultiplicative linear logic by a non-commutative self-dual logical operator.\nThis extension is particularly challenging for the sequent calculus, and so far\nit is not achieved therein. It becomes very natural in a new formalism, called\nthe calculus of structures, which is the main contribution of this work.\nStructures are formulae submitted to certain equational laws typical of\nsequents. The calculus of structures is obtained by generalising the sequent\ncalculus in such a way that a new top-down symmetry of derivations is observed,\nand it employs inference rules that rewrite inside structures at any depth.\nThese properties, in addition to allow the design of BV, yield a modular proof\nof cut elimination."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9910023v4", 
    "other_authors": [
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/9910023v4", 
    "title": "A System of Interaction and Structure", 
    "publish": "1999-10-28T09:17:34Z", 
    "summary": "This paper introduces a logical system, called BV, which extends\nmultiplicative linear logic by a non-commutative self-dual logical operator.\nThis extension is particularly challenging for the sequent calculus, and so far\nit is not achieved therein. It becomes very natural in a new formalism, called\nthe calculus of structures, which is the main contribution of this work.\nStructures are formulae submitted to certain equational laws typical of\nsequents. The calculus of structures is obtained by generalising the sequent\ncalculus in such a way that a new top-down symmetry of derivations is observed,\nand it employs inference rules that rewrite inside structures at any depth.\nThese properties, in addition to allow the design of BV, yield a modular proof\nof cut elimination."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9910023v4", 
    "other_authors": [
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/9910023v4", 
    "title": "A System of Interaction and Structure", 
    "publish": "1999-10-28T09:17:34Z", 
    "summary": "This paper introduces a logical system, called BV, which extends\nmultiplicative linear logic by a non-commutative self-dual logical operator.\nThis extension is particularly challenging for the sequent calculus, and so far\nit is not achieved therein. It becomes very natural in a new formalism, called\nthe calculus of structures, which is the main contribution of this work.\nStructures are formulae submitted to certain equational laws typical of\nsequents. The calculus of structures is obtained by generalising the sequent\ncalculus in such a way that a new top-down symmetry of derivations is observed,\nand it employs inference rules that rewrite inside structures at any depth.\nThese properties, in addition to allow the design of BV, yield a modular proof\nof cut elimination."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9910023v4", 
    "other_authors": [
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/9910023v4", 
    "title": "A System of Interaction and Structure", 
    "publish": "1999-10-28T09:17:34Z", 
    "summary": "This paper introduces a logical system, called BV, which extends\nmultiplicative linear logic by a non-commutative self-dual logical operator.\nThis extension is particularly challenging for the sequent calculus, and so far\nit is not achieved therein. It becomes very natural in a new formalism, called\nthe calculus of structures, which is the main contribution of this work.\nStructures are formulae submitted to certain equational laws typical of\nsequents. The calculus of structures is obtained by generalising the sequent\ncalculus in such a way that a new top-down symmetry of derivations is observed,\nand it employs inference rules that rewrite inside structures at any depth.\nThese properties, in addition to allow the design of BV, yield a modular proof\nof cut elimination."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9910023v4", 
    "other_authors": [
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/9910023v4", 
    "title": "A System of Interaction and Structure", 
    "publish": "1999-10-28T09:17:34Z", 
    "summary": "This paper introduces a logical system, called BV, which extends\nmultiplicative linear logic by a non-commutative self-dual logical operator.\nThis extension is particularly challenging for the sequent calculus, and so far\nit is not achieved therein. It becomes very natural in a new formalism, called\nthe calculus of structures, which is the main contribution of this work.\nStructures are formulae submitted to certain equational laws typical of\nsequents. The calculus of structures is obtained by generalising the sequent\ncalculus in such a way that a new top-down symmetry of derivations is observed,\nand it employs inference rules that rewrite inside structures at any depth.\nThese properties, in addition to allow the design of BV, yield a modular proof\nof cut elimination."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9910023v4", 
    "other_authors": [
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/9910023v4", 
    "title": "A System of Interaction and Structure", 
    "publish": "1999-10-28T09:17:34Z", 
    "summary": "This paper introduces a logical system, called BV, which extends\nmultiplicative linear logic by a non-commutative self-dual logical operator.\nThis extension is particularly challenging for the sequent calculus, and so far\nit is not achieved therein. It becomes very natural in a new formalism, called\nthe calculus of structures, which is the main contribution of this work.\nStructures are formulae submitted to certain equational laws typical of\nsequents. The calculus of structures is obtained by generalising the sequent\ncalculus in such a way that a new top-down symmetry of derivations is observed,\nand it employs inference rules that rewrite inside structures at any depth.\nThese properties, in addition to allow the design of BV, yield a modular proof\nof cut elimination."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9910023v4", 
    "other_authors": [
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/9910023v4", 
    "title": "A System of Interaction and Structure", 
    "publish": "1999-10-28T09:17:34Z", 
    "summary": "This paper introduces a logical system, called BV, which extends\nmultiplicative linear logic by a non-commutative self-dual logical operator.\nThis extension is particularly challenging for the sequent calculus, and so far\nit is not achieved therein. It becomes very natural in a new formalism, called\nthe calculus of structures, which is the main contribution of this work.\nStructures are formulae submitted to certain equational laws typical of\nsequents. The calculus of structures is obtained by generalising the sequent\ncalculus in such a way that a new top-down symmetry of derivations is observed,\nand it employs inference rules that rewrite inside structures at any depth.\nThese properties, in addition to allow the design of BV, yield a modular proof\nof cut elimination."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9910023v4", 
    "other_authors": [
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/9910023v4", 
    "title": "A System of Interaction and Structure", 
    "publish": "1999-10-28T09:17:34Z", 
    "summary": "This paper introduces a logical system, called BV, which extends\nmultiplicative linear logic by a non-commutative self-dual logical operator.\nThis extension is particularly challenging for the sequent calculus, and so far\nit is not achieved therein. It becomes very natural in a new formalism, called\nthe calculus of structures, which is the main contribution of this work.\nStructures are formulae submitted to certain equational laws typical of\nsequents. The calculus of structures is obtained by generalising the sequent\ncalculus in such a way that a new top-down symmetry of derivations is observed,\nand it employs inference rules that rewrite inside structures at any depth.\nThese properties, in addition to allow the design of BV, yield a modular proof\nof cut elimination."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9910023v4", 
    "other_authors": [
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/9910023v4", 
    "title": "A System of Interaction and Structure", 
    "publish": "1999-10-28T09:17:34Z", 
    "summary": "This paper introduces a logical system, called BV, which extends\nmultiplicative linear logic by a non-commutative self-dual logical operator.\nThis extension is particularly challenging for the sequent calculus, and so far\nit is not achieved therein. It becomes very natural in a new formalism, called\nthe calculus of structures, which is the main contribution of this work.\nStructures are formulae submitted to certain equational laws typical of\nsequents. The calculus of structures is obtained by generalising the sequent\ncalculus in such a way that a new top-down symmetry of derivations is observed,\nand it employs inference rules that rewrite inside structures at any depth.\nThese properties, in addition to allow the design of BV, yield a modular proof\nof cut elimination."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9910023v4", 
    "other_authors": [
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/9910023v4", 
    "title": "A System of Interaction and Structure", 
    "publish": "1999-10-28T09:17:34Z", 
    "summary": "This paper introduces a logical system, called BV, which extends\nmultiplicative linear logic by a non-commutative self-dual logical operator.\nThis extension is particularly challenging for the sequent calculus, and so far\nit is not achieved therein. It becomes very natural in a new formalism, called\nthe calculus of structures, which is the main contribution of this work.\nStructures are formulae submitted to certain equational laws typical of\nsequents. The calculus of structures is obtained by generalising the sequent\ncalculus in such a way that a new top-down symmetry of derivations is observed,\nand it employs inference rules that rewrite inside structures at any depth.\nThese properties, in addition to allow the design of BV, yield a modular proof\nof cut elimination."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9910023v4", 
    "other_authors": [
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/9910023v4", 
    "title": "A System of Interaction and Structure", 
    "publish": "1999-10-28T09:17:34Z", 
    "summary": "This paper introduces a logical system, called BV, which extends\nmultiplicative linear logic by a non-commutative self-dual logical operator.\nThis extension is particularly challenging for the sequent calculus, and so far\nit is not achieved therein. It becomes very natural in a new formalism, called\nthe calculus of structures, which is the main contribution of this work.\nStructures are formulae submitted to certain equational laws typical of\nsequents. The calculus of structures is obtained by generalising the sequent\ncalculus in such a way that a new top-down symmetry of derivations is observed,\nand it employs inference rules that rewrite inside structures at any depth.\nThese properties, in addition to allow the design of BV, yield a modular proof\nof cut elimination."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9910023v4", 
    "other_authors": [
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/9910023v4", 
    "title": "A System of Interaction and Structure", 
    "publish": "1999-10-28T09:17:34Z", 
    "summary": "This paper introduces a logical system, called BV, which extends\nmultiplicative linear logic by a non-commutative self-dual logical operator.\nThis extension is particularly challenging for the sequent calculus, and so far\nit is not achieved therein. It becomes very natural in a new formalism, called\nthe calculus of structures, which is the main contribution of this work.\nStructures are formulae submitted to certain equational laws typical of\nsequents. The calculus of structures is obtained by generalising the sequent\ncalculus in such a way that a new top-down symmetry of derivations is observed,\nand it employs inference rules that rewrite inside structures at any depth.\nThese properties, in addition to allow the design of BV, yield a modular proof\nof cut elimination."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9910023v4", 
    "other_authors": [
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/9910023v4", 
    "title": "A System of Interaction and Structure", 
    "publish": "1999-10-28T09:17:34Z", 
    "summary": "This paper introduces a logical system, called BV, which extends\nmultiplicative linear logic by a non-commutative self-dual logical operator.\nThis extension is particularly challenging for the sequent calculus, and so far\nit is not achieved therein. It becomes very natural in a new formalism, called\nthe calculus of structures, which is the main contribution of this work.\nStructures are formulae submitted to certain equational laws typical of\nsequents. The calculus of structures is obtained by generalising the sequent\ncalculus in such a way that a new top-down symmetry of derivations is observed,\nand it employs inference rules that rewrite inside structures at any depth.\nThese properties, in addition to allow the design of BV, yield a modular proof\nof cut elimination."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9910023v4", 
    "other_authors": [
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/9910023v4", 
    "title": "A System of Interaction and Structure", 
    "publish": "1999-10-28T09:17:34Z", 
    "summary": "This paper introduces a logical system, called BV, which extends\nmultiplicative linear logic by a non-commutative self-dual logical operator.\nThis extension is particularly challenging for the sequent calculus, and so far\nit is not achieved therein. It becomes very natural in a new formalism, called\nthe calculus of structures, which is the main contribution of this work.\nStructures are formulae submitted to certain equational laws typical of\nsequents. The calculus of structures is obtained by generalising the sequent\ncalculus in such a way that a new top-down symmetry of derivations is observed,\nand it employs inference rules that rewrite inside structures at any depth.\nThese properties, in addition to allow the design of BV, yield a modular proof\nof cut elimination."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9910023v4", 
    "other_authors": [
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/9910023v4", 
    "title": "A System of Interaction and Structure", 
    "publish": "1999-10-28T09:17:34Z", 
    "summary": "This paper introduces a logical system, called BV, which extends\nmultiplicative linear logic by a non-commutative self-dual logical operator.\nThis extension is particularly challenging for the sequent calculus, and so far\nit is not achieved therein. It becomes very natural in a new formalism, called\nthe calculus of structures, which is the main contribution of this work.\nStructures are formulae submitted to certain equational laws typical of\nsequents. The calculus of structures is obtained by generalising the sequent\ncalculus in such a way that a new top-down symmetry of derivations is observed,\nand it employs inference rules that rewrite inside structures at any depth.\nThese properties, in addition to allow the design of BV, yield a modular proof\nof cut elimination."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9910023v4", 
    "other_authors": [
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/9910023v4", 
    "title": "A System of Interaction and Structure", 
    "publish": "1999-10-28T09:17:34Z", 
    "summary": "This paper introduces a logical system, called BV, which extends\nmultiplicative linear logic by a non-commutative self-dual logical operator.\nThis extension is particularly challenging for the sequent calculus, and so far\nit is not achieved therein. It becomes very natural in a new formalism, called\nthe calculus of structures, which is the main contribution of this work.\nStructures are formulae submitted to certain equational laws typical of\nsequents. The calculus of structures is obtained by generalising the sequent\ncalculus in such a way that a new top-down symmetry of derivations is observed,\nand it employs inference rules that rewrite inside structures at any depth.\nThese properties, in addition to allow the design of BV, yield a modular proof\nof cut elimination."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9910023v4", 
    "other_authors": [
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/9910023v4", 
    "title": "A System of Interaction and Structure", 
    "publish": "1999-10-28T09:17:34Z", 
    "summary": "This paper introduces a logical system, called BV, which extends\nmultiplicative linear logic by a non-commutative self-dual logical operator.\nThis extension is particularly challenging for the sequent calculus, and so far\nit is not achieved therein. It becomes very natural in a new formalism, called\nthe calculus of structures, which is the main contribution of this work.\nStructures are formulae submitted to certain equational laws typical of\nsequents. The calculus of structures is obtained by generalising the sequent\ncalculus in such a way that a new top-down symmetry of derivations is observed,\nand it employs inference rules that rewrite inside structures at any depth.\nThese properties, in addition to allow the design of BV, yield a modular proof\nof cut elimination."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9910023v4", 
    "other_authors": [
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/9910023v4", 
    "title": "A System of Interaction and Structure", 
    "publish": "1999-10-28T09:17:34Z", 
    "summary": "This paper introduces a logical system, called BV, which extends\nmultiplicative linear logic by a non-commutative self-dual logical operator.\nThis extension is particularly challenging for the sequent calculus, and so far\nit is not achieved therein. It becomes very natural in a new formalism, called\nthe calculus of structures, which is the main contribution of this work.\nStructures are formulae submitted to certain equational laws typical of\nsequents. The calculus of structures is obtained by generalising the sequent\ncalculus in such a way that a new top-down symmetry of derivations is observed,\nand it employs inference rules that rewrite inside structures at any depth.\nThese properties, in addition to allow the design of BV, yield a modular proof\nof cut elimination."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9910023v4", 
    "other_authors": [
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/9910023v4", 
    "title": "A System of Interaction and Structure", 
    "publish": "1999-10-28T09:17:34Z", 
    "summary": "This paper introduces a logical system, called BV, which extends\nmultiplicative linear logic by a non-commutative self-dual logical operator.\nThis extension is particularly challenging for the sequent calculus, and so far\nit is not achieved therein. It becomes very natural in a new formalism, called\nthe calculus of structures, which is the main contribution of this work.\nStructures are formulae submitted to certain equational laws typical of\nsequents. The calculus of structures is obtained by generalising the sequent\ncalculus in such a way that a new top-down symmetry of derivations is observed,\nand it employs inference rules that rewrite inside structures at any depth.\nThese properties, in addition to allow the design of BV, yield a modular proof\nof cut elimination."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9910023v4", 
    "other_authors": [
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/9910023v4", 
    "title": "A System of Interaction and Structure", 
    "publish": "1999-10-28T09:17:34Z", 
    "summary": "This paper introduces a logical system, called BV, which extends\nmultiplicative linear logic by a non-commutative self-dual logical operator.\nThis extension is particularly challenging for the sequent calculus, and so far\nit is not achieved therein. It becomes very natural in a new formalism, called\nthe calculus of structures, which is the main contribution of this work.\nStructures are formulae submitted to certain equational laws typical of\nsequents. The calculus of structures is obtained by generalising the sequent\ncalculus in such a way that a new top-down symmetry of derivations is observed,\nand it employs inference rules that rewrite inside structures at any depth.\nThese properties, in addition to allow the design of BV, yield a modular proof\nof cut elimination."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9910023v4", 
    "other_authors": [
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/9910023v4", 
    "title": "A System of Interaction and Structure", 
    "publish": "1999-10-28T09:17:34Z", 
    "summary": "This paper introduces a logical system, called BV, which extends\nmultiplicative linear logic by a non-commutative self-dual logical operator.\nThis extension is particularly challenging for the sequent calculus, and so far\nit is not achieved therein. It becomes very natural in a new formalism, called\nthe calculus of structures, which is the main contribution of this work.\nStructures are formulae submitted to certain equational laws typical of\nsequents. The calculus of structures is obtained by generalising the sequent\ncalculus in such a way that a new top-down symmetry of derivations is observed,\nand it employs inference rules that rewrite inside structures at any depth.\nThese properties, in addition to allow the design of BV, yield a modular proof\nof cut elimination."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9910023v4", 
    "other_authors": [
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/9910023v4", 
    "title": "A System of Interaction and Structure", 
    "publish": "1999-10-28T09:17:34Z", 
    "summary": "This paper introduces a logical system, called BV, which extends\nmultiplicative linear logic by a non-commutative self-dual logical operator.\nThis extension is particularly challenging for the sequent calculus, and so far\nit is not achieved therein. It becomes very natural in a new formalism, called\nthe calculus of structures, which is the main contribution of this work.\nStructures are formulae submitted to certain equational laws typical of\nsequents. The calculus of structures is obtained by generalising the sequent\ncalculus in such a way that a new top-down symmetry of derivations is observed,\nand it employs inference rules that rewrite inside structures at any depth.\nThese properties, in addition to allow the design of BV, yield a modular proof\nof cut elimination."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9910023v4", 
    "other_authors": [
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/9910023v4", 
    "title": "A System of Interaction and Structure", 
    "publish": "1999-10-28T09:17:34Z", 
    "summary": "This paper introduces a logical system, called BV, which extends\nmultiplicative linear logic by a non-commutative self-dual logical operator.\nThis extension is particularly challenging for the sequent calculus, and so far\nit is not achieved therein. It becomes very natural in a new formalism, called\nthe calculus of structures, which is the main contribution of this work.\nStructures are formulae submitted to certain equational laws typical of\nsequents. The calculus of structures is obtained by generalising the sequent\ncalculus in such a way that a new top-down symmetry of derivations is observed,\nand it employs inference rules that rewrite inside structures at any depth.\nThese properties, in addition to allow the design of BV, yield a modular proof\nof cut elimination."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9910023v4", 
    "other_authors": [
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/9910023v4", 
    "title": "A System of Interaction and Structure", 
    "publish": "1999-10-28T09:17:34Z", 
    "summary": "This paper introduces a logical system, called BV, which extends\nmultiplicative linear logic by a non-commutative self-dual logical operator.\nThis extension is particularly challenging for the sequent calculus, and so far\nit is not achieved therein. It becomes very natural in a new formalism, called\nthe calculus of structures, which is the main contribution of this work.\nStructures are formulae submitted to certain equational laws typical of\nsequents. The calculus of structures is obtained by generalising the sequent\ncalculus in such a way that a new top-down symmetry of derivations is observed,\nand it employs inference rules that rewrite inside structures at any depth.\nThese properties, in addition to allow the design of BV, yield a modular proof\nof cut elimination."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9910023v4", 
    "other_authors": [
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/9910023v4", 
    "title": "A System of Interaction and Structure", 
    "publish": "1999-10-28T09:17:34Z", 
    "summary": "This paper introduces a logical system, called BV, which extends\nmultiplicative linear logic by a non-commutative self-dual logical operator.\nThis extension is particularly challenging for the sequent calculus, and so far\nit is not achieved therein. It becomes very natural in a new formalism, called\nthe calculus of structures, which is the main contribution of this work.\nStructures are formulae submitted to certain equational laws typical of\nsequents. The calculus of structures is obtained by generalising the sequent\ncalculus in such a way that a new top-down symmetry of derivations is observed,\nand it employs inference rules that rewrite inside structures at any depth.\nThese properties, in addition to allow the design of BV, yield a modular proof\nof cut elimination."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9910023v4", 
    "other_authors": [
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/9910023v4", 
    "title": "A System of Interaction and Structure", 
    "publish": "1999-10-28T09:17:34Z", 
    "summary": "This paper introduces a logical system, called BV, which extends\nmultiplicative linear logic by a non-commutative self-dual logical operator.\nThis extension is particularly challenging for the sequent calculus, and so far\nit is not achieved therein. It becomes very natural in a new formalism, called\nthe calculus of structures, which is the main contribution of this work.\nStructures are formulae submitted to certain equational laws typical of\nsequents. The calculus of structures is obtained by generalising the sequent\ncalculus in such a way that a new top-down symmetry of derivations is observed,\nand it employs inference rules that rewrite inside structures at any depth.\nThese properties, in addition to allow the design of BV, yield a modular proof\nof cut elimination."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9910023v4", 
    "other_authors": [
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/9910023v4", 
    "title": "A System of Interaction and Structure", 
    "publish": "1999-10-28T09:17:34Z", 
    "summary": "This paper introduces a logical system, called BV, which extends\nmultiplicative linear logic by a non-commutative self-dual logical operator.\nThis extension is particularly challenging for the sequent calculus, and so far\nit is not achieved therein. It becomes very natural in a new formalism, called\nthe calculus of structures, which is the main contribution of this work.\nStructures are formulae submitted to certain equational laws typical of\nsequents. The calculus of structures is obtained by generalising the sequent\ncalculus in such a way that a new top-down symmetry of derivations is observed,\nand it employs inference rules that rewrite inside structures at any depth.\nThese properties, in addition to allow the design of BV, yield a modular proof\nof cut elimination."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9910023v4", 
    "other_authors": [
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/9910023v4", 
    "title": "A System of Interaction and Structure", 
    "publish": "1999-10-28T09:17:34Z", 
    "summary": "This paper introduces a logical system, called BV, which extends\nmultiplicative linear logic by a non-commutative self-dual logical operator.\nThis extension is particularly challenging for the sequent calculus, and so far\nit is not achieved therein. It becomes very natural in a new formalism, called\nthe calculus of structures, which is the main contribution of this work.\nStructures are formulae submitted to certain equational laws typical of\nsequents. The calculus of structures is obtained by generalising the sequent\ncalculus in such a way that a new top-down symmetry of derivations is observed,\nand it employs inference rules that rewrite inside structures at any depth.\nThese properties, in addition to allow the design of BV, yield a modular proof\nof cut elimination."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9910023v4", 
    "other_authors": [
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/9910023v4", 
    "title": "A System of Interaction and Structure", 
    "publish": "1999-10-28T09:17:34Z", 
    "summary": "This paper introduces a logical system, called BV, which extends\nmultiplicative linear logic by a non-commutative self-dual logical operator.\nThis extension is particularly challenging for the sequent calculus, and so far\nit is not achieved therein. It becomes very natural in a new formalism, called\nthe calculus of structures, which is the main contribution of this work.\nStructures are formulae submitted to certain equational laws typical of\nsequents. The calculus of structures is obtained by generalising the sequent\ncalculus in such a way that a new top-down symmetry of derivations is observed,\nand it employs inference rules that rewrite inside structures at any depth.\nThese properties, in addition to allow the design of BV, yield a modular proof\nof cut elimination."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9910023v4", 
    "other_authors": [
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/9910023v4", 
    "title": "A System of Interaction and Structure", 
    "publish": "1999-10-28T09:17:34Z", 
    "summary": "This paper introduces a logical system, called BV, which extends\nmultiplicative linear logic by a non-commutative self-dual logical operator.\nThis extension is particularly challenging for the sequent calculus, and so far\nit is not achieved therein. It becomes very natural in a new formalism, called\nthe calculus of structures, which is the main contribution of this work.\nStructures are formulae submitted to certain equational laws typical of\nsequents. The calculus of structures is obtained by generalising the sequent\ncalculus in such a way that a new top-down symmetry of derivations is observed,\nand it employs inference rules that rewrite inside structures at any depth.\nThese properties, in addition to allow the design of BV, yield a modular proof\nof cut elimination."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9910023v4", 
    "other_authors": [
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/9910023v4", 
    "title": "A System of Interaction and Structure", 
    "publish": "1999-10-28T09:17:34Z", 
    "summary": "This paper introduces a logical system, called BV, which extends\nmultiplicative linear logic by a non-commutative self-dual logical operator.\nThis extension is particularly challenging for the sequent calculus, and so far\nit is not achieved therein. It becomes very natural in a new formalism, called\nthe calculus of structures, which is the main contribution of this work.\nStructures are formulae submitted to certain equational laws typical of\nsequents. The calculus of structures is obtained by generalising the sequent\ncalculus in such a way that a new top-down symmetry of derivations is observed,\nand it employs inference rules that rewrite inside structures at any depth.\nThese properties, in addition to allow the design of BV, yield a modular proof\nof cut elimination."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9910023v4", 
    "other_authors": [
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/9910023v4", 
    "title": "A System of Interaction and Structure", 
    "publish": "1999-10-28T09:17:34Z", 
    "summary": "This paper introduces a logical system, called BV, which extends\nmultiplicative linear logic by a non-commutative self-dual logical operator.\nThis extension is particularly challenging for the sequent calculus, and so far\nit is not achieved therein. It becomes very natural in a new formalism, called\nthe calculus of structures, which is the main contribution of this work.\nStructures are formulae submitted to certain equational laws typical of\nsequents. The calculus of structures is obtained by generalising the sequent\ncalculus in such a way that a new top-down symmetry of derivations is observed,\nand it employs inference rules that rewrite inside structures at any depth.\nThese properties, in addition to allow the design of BV, yield a modular proof\nof cut elimination."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9910023v4", 
    "other_authors": [
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/9910023v4", 
    "title": "A System of Interaction and Structure", 
    "publish": "1999-10-28T09:17:34Z", 
    "summary": "This paper introduces a logical system, called BV, which extends\nmultiplicative linear logic by a non-commutative self-dual logical operator.\nThis extension is particularly challenging for the sequent calculus, and so far\nit is not achieved therein. It becomes very natural in a new formalism, called\nthe calculus of structures, which is the main contribution of this work.\nStructures are formulae submitted to certain equational laws typical of\nsequents. The calculus of structures is obtained by generalising the sequent\ncalculus in such a way that a new top-down symmetry of derivations is observed,\nand it employs inference rules that rewrite inside structures at any depth.\nThese properties, in addition to allow the design of BV, yield a modular proof\nof cut elimination."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9910023v4", 
    "other_authors": [
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/9910023v4", 
    "title": "A System of Interaction and Structure", 
    "publish": "1999-10-28T09:17:34Z", 
    "summary": "This paper introduces a logical system, called BV, which extends\nmultiplicative linear logic by a non-commutative self-dual logical operator.\nThis extension is particularly challenging for the sequent calculus, and so far\nit is not achieved therein. It becomes very natural in a new formalism, called\nthe calculus of structures, which is the main contribution of this work.\nStructures are formulae submitted to certain equational laws typical of\nsequents. The calculus of structures is obtained by generalising the sequent\ncalculus in such a way that a new top-down symmetry of derivations is observed,\nand it employs inference rules that rewrite inside structures at any depth.\nThese properties, in addition to allow the design of BV, yield a modular proof\nof cut elimination."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/9910023v4", 
    "other_authors": [
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/9910023v4", 
    "title": "A System of Interaction and Structure", 
    "publish": "1999-10-28T09:17:34Z", 
    "summary": "This paper introduces a logical system, called BV, which extends\nmultiplicative linear logic by a non-commutative self-dual logical operator.\nThis extension is particularly challenging for the sequent calculus, and so far\nit is not achieved therein. It becomes very natural in a new formalism, called\nthe calculus of structures, which is the main contribution of this work.\nStructures are formulae submitted to certain equational laws typical of\nsequents. The calculus of structures is obtained by generalising the sequent\ncalculus in such a way that a new top-down symmetry of derivations is observed,\nand it employs inference rules that rewrite inside structures at any depth.\nThese properties, in addition to allow the design of BV, yield a modular proof\nof cut elimination."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003026v1", 
    "other_authors": [
        "Nikolay Pelov", 
        "Emmanuel De Mot", 
        "Maurice Bruynooghe"
    ], 
    "lead_author": "Nikolay Pelov", 
    "arxiv-id": "cs/0003026v1", 
    "title": "A Comparison of Logic Programming Approaches for Representation and   Solving of Constraint Satisfaction Problems", 
    "publish": "2000-03-08T12:52:32Z", 
    "summary": "Many logic programming based approaches can be used to describe and solve\ncombinatorial search problems. On the one hand there are definite programs and\nconstraint logic programs that compute a solution as an answer substitution to\na query containing the variables of the constraint satisfaction problem. On the\nother hand there are approaches based on stable model semantics, abduction, and\nfirst-order logic model generation that compute solutions as models of some\ntheory. This paper compares these different approaches from point of view of\nknowledge representation (how declarative are the programs) and from point of\nview of performance (how good are they at solving typical problems)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003026v1", 
    "other_authors": [
        "Nikolay Pelov", 
        "Emmanuel De Mot", 
        "Maurice Bruynooghe"
    ], 
    "lead_author": "Nikolay Pelov", 
    "arxiv-id": "cs/0003026v1", 
    "title": "A Comparison of Logic Programming Approaches for Representation and   Solving of Constraint Satisfaction Problems", 
    "publish": "2000-03-08T12:52:32Z", 
    "summary": "Many logic programming based approaches can be used to describe and solve\ncombinatorial search problems. On the one hand there are definite programs and\nconstraint logic programs that compute a solution as an answer substitution to\na query containing the variables of the constraint satisfaction problem. On the\nother hand there are approaches based on stable model semantics, abduction, and\nfirst-order logic model generation that compute solutions as models of some\ntheory. This paper compares these different approaches from point of view of\nknowledge representation (how declarative are the programs) and from point of\nview of performance (how good are they at solving typical problems)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003026v1", 
    "other_authors": [
        "Nikolay Pelov", 
        "Emmanuel De Mot", 
        "Maurice Bruynooghe"
    ], 
    "lead_author": "Nikolay Pelov", 
    "arxiv-id": "cs/0003026v1", 
    "title": "A Comparison of Logic Programming Approaches for Representation and   Solving of Constraint Satisfaction Problems", 
    "publish": "2000-03-08T12:52:32Z", 
    "summary": "Many logic programming based approaches can be used to describe and solve\ncombinatorial search problems. On the one hand there are definite programs and\nconstraint logic programs that compute a solution as an answer substitution to\na query containing the variables of the constraint satisfaction problem. On the\nother hand there are approaches based on stable model semantics, abduction, and\nfirst-order logic model generation that compute solutions as models of some\ntheory. This paper compares these different approaches from point of view of\nknowledge representation (how declarative are the programs) and from point of\nview of performance (how good are they at solving typical problems)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003026v1", 
    "other_authors": [
        "Nikolay Pelov", 
        "Emmanuel De Mot", 
        "Maurice Bruynooghe"
    ], 
    "lead_author": "Nikolay Pelov", 
    "arxiv-id": "cs/0003026v1", 
    "title": "A Comparison of Logic Programming Approaches for Representation and   Solving of Constraint Satisfaction Problems", 
    "publish": "2000-03-08T12:52:32Z", 
    "summary": "Many logic programming based approaches can be used to describe and solve\ncombinatorial search problems. On the one hand there are definite programs and\nconstraint logic programs that compute a solution as an answer substitution to\na query containing the variables of the constraint satisfaction problem. On the\nother hand there are approaches based on stable model semantics, abduction, and\nfirst-order logic model generation that compute solutions as models of some\ntheory. This paper compares these different approaches from point of view of\nknowledge representation (how declarative are the programs) and from point of\nview of performance (how good are they at solving typical problems)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003026v1", 
    "other_authors": [
        "Nikolay Pelov", 
        "Emmanuel De Mot", 
        "Maurice Bruynooghe"
    ], 
    "lead_author": "Maurice Bruynooghe", 
    "arxiv-id": "cs/0003026v1", 
    "title": "A Comparison of Logic Programming Approaches for Representation and   Solving of Constraint Satisfaction Problems", 
    "publish": "2000-03-08T12:52:32Z", 
    "summary": "Many logic programming based approaches can be used to describe and solve\ncombinatorial search problems. On the one hand there are definite programs and\nconstraint logic programs that compute a solution as an answer substitution to\na query containing the variables of the constraint satisfaction problem. On the\nother hand there are approaches based on stable model semantics, abduction, and\nfirst-order logic model generation that compute solutions as models of some\ntheory. This paper compares these different approaches from point of view of\nknowledge representation (how declarative are the programs) and from point of\nview of performance (how good are they at solving typical problems)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003026v1", 
    "other_authors": [
        "Nikolay Pelov", 
        "Emmanuel De Mot", 
        "Maurice Bruynooghe"
    ], 
    "lead_author": "Maurice Bruynooghe", 
    "arxiv-id": "cs/0003026v1", 
    "title": "A Comparison of Logic Programming Approaches for Representation and   Solving of Constraint Satisfaction Problems", 
    "publish": "2000-03-08T12:52:32Z", 
    "summary": "Many logic programming based approaches can be used to describe and solve\ncombinatorial search problems. On the one hand there are definite programs and\nconstraint logic programs that compute a solution as an answer substitution to\na query containing the variables of the constraint satisfaction problem. On the\nother hand there are approaches based on stable model semantics, abduction, and\nfirst-order logic model generation that compute solutions as models of some\ntheory. This paper compares these different approaches from point of view of\nknowledge representation (how declarative are the programs) and from point of\nview of performance (how good are they at solving typical problems)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003026v1", 
    "other_authors": [
        "Nikolay Pelov", 
        "Emmanuel De Mot", 
        "Maurice Bruynooghe"
    ], 
    "lead_author": "Maurice Bruynooghe", 
    "arxiv-id": "cs/0003026v1", 
    "title": "A Comparison of Logic Programming Approaches for Representation and   Solving of Constraint Satisfaction Problems", 
    "publish": "2000-03-08T12:52:32Z", 
    "summary": "Many logic programming based approaches can be used to describe and solve\ncombinatorial search problems. On the one hand there are definite programs and\nconstraint logic programs that compute a solution as an answer substitution to\na query containing the variables of the constraint satisfaction problem. On the\nother hand there are approaches based on stable model semantics, abduction, and\nfirst-order logic model generation that compute solutions as models of some\ntheory. This paper compares these different approaches from point of view of\nknowledge representation (how declarative are the programs) and from point of\nview of performance (how good are they at solving typical problems)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003026v1", 
    "other_authors": [
        "Nikolay Pelov", 
        "Emmanuel De Mot", 
        "Maurice Bruynooghe"
    ], 
    "lead_author": "Maurice Bruynooghe", 
    "arxiv-id": "cs/0003026v1", 
    "title": "A Comparison of Logic Programming Approaches for Representation and   Solving of Constraint Satisfaction Problems", 
    "publish": "2000-03-08T12:52:32Z", 
    "summary": "Many logic programming based approaches can be used to describe and solve\ncombinatorial search problems. On the one hand there are definite programs and\nconstraint logic programs that compute a solution as an answer substitution to\na query containing the variables of the constraint satisfaction problem. On the\nother hand there are approaches based on stable model semantics, abduction, and\nfirst-order logic model generation that compute solutions as models of some\ntheory. This paper compares these different approaches from point of view of\nknowledge representation (how declarative are the programs) and from point of\nview of performance (how good are they at solving typical problems)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003026v1", 
    "other_authors": [
        "Nikolay Pelov", 
        "Emmanuel De Mot", 
        "Maurice Bruynooghe"
    ], 
    "lead_author": "Maurice Bruynooghe", 
    "arxiv-id": "cs/0003026v1", 
    "title": "A Comparison of Logic Programming Approaches for Representation and   Solving of Constraint Satisfaction Problems", 
    "publish": "2000-03-08T12:52:32Z", 
    "summary": "Many logic programming based approaches can be used to describe and solve\ncombinatorial search problems. On the one hand there are definite programs and\nconstraint logic programs that compute a solution as an answer substitution to\na query containing the variables of the constraint satisfaction problem. On the\nother hand there are approaches based on stable model semantics, abduction, and\nfirst-order logic model generation that compute solutions as models of some\ntheory. This paper compares these different approaches from point of view of\nknowledge representation (how declarative are the programs) and from point of\nview of performance (how good are they at solving typical problems)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003026v1", 
    "other_authors": [
        "Nikolay Pelov", 
        "Emmanuel De Mot", 
        "Maurice Bruynooghe"
    ], 
    "lead_author": "Maurice Bruynooghe", 
    "arxiv-id": "cs/0003026v1", 
    "title": "A Comparison of Logic Programming Approaches for Representation and   Solving of Constraint Satisfaction Problems", 
    "publish": "2000-03-08T12:52:32Z", 
    "summary": "Many logic programming based approaches can be used to describe and solve\ncombinatorial search problems. On the one hand there are definite programs and\nconstraint logic programs that compute a solution as an answer substitution to\na query containing the variables of the constraint satisfaction problem. On the\nother hand there are approaches based on stable model semantics, abduction, and\nfirst-order logic model generation that compute solutions as models of some\ntheory. This paper compares these different approaches from point of view of\nknowledge representation (how declarative are the programs) and from point of\nview of performance (how good are they at solving typical problems)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003026v1", 
    "other_authors": [
        "Nikolay Pelov", 
        "Emmanuel De Mot", 
        "Maurice Bruynooghe"
    ], 
    "lead_author": "Maurice Bruynooghe", 
    "arxiv-id": "cs/0003026v1", 
    "title": "A Comparison of Logic Programming Approaches for Representation and   Solving of Constraint Satisfaction Problems", 
    "publish": "2000-03-08T12:52:32Z", 
    "summary": "Many logic programming based approaches can be used to describe and solve\ncombinatorial search problems. On the one hand there are definite programs and\nconstraint logic programs that compute a solution as an answer substitution to\na query containing the variables of the constraint satisfaction problem. On the\nother hand there are approaches based on stable model semantics, abduction, and\nfirst-order logic model generation that compute solutions as models of some\ntheory. This paper compares these different approaches from point of view of\nknowledge representation (how declarative are the programs) and from point of\nview of performance (how good are they at solving typical problems)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003026v1", 
    "other_authors": [
        "Nikolay Pelov", 
        "Emmanuel De Mot", 
        "Maurice Bruynooghe"
    ], 
    "lead_author": "Maurice Bruynooghe", 
    "arxiv-id": "cs/0003026v1", 
    "title": "A Comparison of Logic Programming Approaches for Representation and   Solving of Constraint Satisfaction Problems", 
    "publish": "2000-03-08T12:52:32Z", 
    "summary": "Many logic programming based approaches can be used to describe and solve\ncombinatorial search problems. On the one hand there are definite programs and\nconstraint logic programs that compute a solution as an answer substitution to\na query containing the variables of the constraint satisfaction problem. On the\nother hand there are approaches based on stable model semantics, abduction, and\nfirst-order logic model generation that compute solutions as models of some\ntheory. This paper compares these different approaches from point of view of\nknowledge representation (how declarative are the programs) and from point of\nview of performance (how good are they at solving typical problems)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003026v1", 
    "other_authors": [
        "Nikolay Pelov", 
        "Emmanuel De Mot", 
        "Maurice Bruynooghe"
    ], 
    "lead_author": "Maurice Bruynooghe", 
    "arxiv-id": "cs/0003026v1", 
    "title": "A Comparison of Logic Programming Approaches for Representation and   Solving of Constraint Satisfaction Problems", 
    "publish": "2000-03-08T12:52:32Z", 
    "summary": "Many logic programming based approaches can be used to describe and solve\ncombinatorial search problems. On the one hand there are definite programs and\nconstraint logic programs that compute a solution as an answer substitution to\na query containing the variables of the constraint satisfaction problem. On the\nother hand there are approaches based on stable model semantics, abduction, and\nfirst-order logic model generation that compute solutions as models of some\ntheory. This paper compares these different approaches from point of view of\nknowledge representation (how declarative are the programs) and from point of\nview of performance (how good are they at solving typical problems)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003026v1", 
    "other_authors": [
        "Nikolay Pelov", 
        "Emmanuel De Mot", 
        "Maurice Bruynooghe"
    ], 
    "lead_author": "Maurice Bruynooghe", 
    "arxiv-id": "cs/0003026v1", 
    "title": "A Comparison of Logic Programming Approaches for Representation and   Solving of Constraint Satisfaction Problems", 
    "publish": "2000-03-08T12:52:32Z", 
    "summary": "Many logic programming based approaches can be used to describe and solve\ncombinatorial search problems. On the one hand there are definite programs and\nconstraint logic programs that compute a solution as an answer substitution to\na query containing the variables of the constraint satisfaction problem. On the\nother hand there are approaches based on stable model semantics, abduction, and\nfirst-order logic model generation that compute solutions as models of some\ntheory. This paper compares these different approaches from point of view of\nknowledge representation (how declarative are the programs) and from point of\nview of performance (how good are they at solving typical problems)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003026v1", 
    "other_authors": [
        "Nikolay Pelov", 
        "Emmanuel De Mot", 
        "Maurice Bruynooghe"
    ], 
    "lead_author": "Maurice Bruynooghe", 
    "arxiv-id": "cs/0003026v1", 
    "title": "A Comparison of Logic Programming Approaches for Representation and   Solving of Constraint Satisfaction Problems", 
    "publish": "2000-03-08T12:52:32Z", 
    "summary": "Many logic programming based approaches can be used to describe and solve\ncombinatorial search problems. On the one hand there are definite programs and\nconstraint logic programs that compute a solution as an answer substitution to\na query containing the variables of the constraint satisfaction problem. On the\nother hand there are approaches based on stable model semantics, abduction, and\nfirst-order logic model generation that compute solutions as models of some\ntheory. This paper compares these different approaches from point of view of\nknowledge representation (how declarative are the programs) and from point of\nview of performance (how good are they at solving typical problems)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003026v1", 
    "other_authors": [
        "Nikolay Pelov", 
        "Emmanuel De Mot", 
        "Maurice Bruynooghe"
    ], 
    "lead_author": "Maurice Bruynooghe", 
    "arxiv-id": "cs/0003026v1", 
    "title": "A Comparison of Logic Programming Approaches for Representation and   Solving of Constraint Satisfaction Problems", 
    "publish": "2000-03-08T12:52:32Z", 
    "summary": "Many logic programming based approaches can be used to describe and solve\ncombinatorial search problems. On the one hand there are definite programs and\nconstraint logic programs that compute a solution as an answer substitution to\na query containing the variables of the constraint satisfaction problem. On the\nother hand there are approaches based on stable model semantics, abduction, and\nfirst-order logic model generation that compute solutions as models of some\ntheory. This paper compares these different approaches from point of view of\nknowledge representation (how declarative are the programs) and from point of\nview of performance (how good are they at solving typical problems)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003026v1", 
    "other_authors": [
        "Nikolay Pelov", 
        "Emmanuel De Mot", 
        "Maurice Bruynooghe"
    ], 
    "lead_author": "Maurice Bruynooghe", 
    "arxiv-id": "cs/0003026v1", 
    "title": "A Comparison of Logic Programming Approaches for Representation and   Solving of Constraint Satisfaction Problems", 
    "publish": "2000-03-08T12:52:32Z", 
    "summary": "Many logic programming based approaches can be used to describe and solve\ncombinatorial search problems. On the one hand there are definite programs and\nconstraint logic programs that compute a solution as an answer substitution to\na query containing the variables of the constraint satisfaction problem. On the\nother hand there are approaches based on stable model semantics, abduction, and\nfirst-order logic model generation that compute solutions as models of some\ntheory. This paper compares these different approaches from point of view of\nknowledge representation (how declarative are the programs) and from point of\nview of performance (how good are they at solving typical problems)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003026v1", 
    "other_authors": [
        "Nikolay Pelov", 
        "Emmanuel De Mot", 
        "Maurice Bruynooghe"
    ], 
    "lead_author": "Maurice Bruynooghe", 
    "arxiv-id": "cs/0003026v1", 
    "title": "A Comparison of Logic Programming Approaches for Representation and   Solving of Constraint Satisfaction Problems", 
    "publish": "2000-03-08T12:52:32Z", 
    "summary": "Many logic programming based approaches can be used to describe and solve\ncombinatorial search problems. On the one hand there are definite programs and\nconstraint logic programs that compute a solution as an answer substitution to\na query containing the variables of the constraint satisfaction problem. On the\nother hand there are approaches based on stable model semantics, abduction, and\nfirst-order logic model generation that compute solutions as models of some\ntheory. This paper compares these different approaches from point of view of\nknowledge representation (how declarative are the programs) and from point of\nview of performance (how good are they at solving typical problems)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003026v1", 
    "other_authors": [
        "Nikolay Pelov", 
        "Emmanuel De Mot", 
        "Maurice Bruynooghe"
    ], 
    "lead_author": "Maurice Bruynooghe", 
    "arxiv-id": "cs/0003026v1", 
    "title": "A Comparison of Logic Programming Approaches for Representation and   Solving of Constraint Satisfaction Problems", 
    "publish": "2000-03-08T12:52:32Z", 
    "summary": "Many logic programming based approaches can be used to describe and solve\ncombinatorial search problems. On the one hand there are definite programs and\nconstraint logic programs that compute a solution as an answer substitution to\na query containing the variables of the constraint satisfaction problem. On the\nother hand there are approaches based on stable model semantics, abduction, and\nfirst-order logic model generation that compute solutions as models of some\ntheory. This paper compares these different approaches from point of view of\nknowledge representation (how declarative are the programs) and from point of\nview of performance (how good are they at solving typical problems)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003026v1", 
    "other_authors": [
        "Nikolay Pelov", 
        "Emmanuel De Mot", 
        "Maurice Bruynooghe"
    ], 
    "lead_author": "Maurice Bruynooghe", 
    "arxiv-id": "cs/0003026v1", 
    "title": "A Comparison of Logic Programming Approaches for Representation and   Solving of Constraint Satisfaction Problems", 
    "publish": "2000-03-08T12:52:32Z", 
    "summary": "Many logic programming based approaches can be used to describe and solve\ncombinatorial search problems. On the one hand there are definite programs and\nconstraint logic programs that compute a solution as an answer substitution to\na query containing the variables of the constraint satisfaction problem. On the\nother hand there are approaches based on stable model semantics, abduction, and\nfirst-order logic model generation that compute solutions as models of some\ntheory. This paper compares these different approaches from point of view of\nknowledge representation (how declarative are the programs) and from point of\nview of performance (how good are they at solving typical problems)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003026v1", 
    "other_authors": [
        "Nikolay Pelov", 
        "Emmanuel De Mot", 
        "Maurice Bruynooghe"
    ], 
    "lead_author": "Maurice Bruynooghe", 
    "arxiv-id": "cs/0003026v1", 
    "title": "A Comparison of Logic Programming Approaches for Representation and   Solving of Constraint Satisfaction Problems", 
    "publish": "2000-03-08T12:52:32Z", 
    "summary": "Many logic programming based approaches can be used to describe and solve\ncombinatorial search problems. On the one hand there are definite programs and\nconstraint logic programs that compute a solution as an answer substitution to\na query containing the variables of the constraint satisfaction problem. On the\nother hand there are approaches based on stable model semantics, abduction, and\nfirst-order logic model generation that compute solutions as models of some\ntheory. This paper compares these different approaches from point of view of\nknowledge representation (how declarative are the programs) and from point of\nview of performance (how good are they at solving typical problems)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003026v1", 
    "other_authors": [
        "Nikolay Pelov", 
        "Emmanuel De Mot", 
        "Maurice Bruynooghe"
    ], 
    "lead_author": "Maurice Bruynooghe", 
    "arxiv-id": "cs/0003026v1", 
    "title": "A Comparison of Logic Programming Approaches for Representation and   Solving of Constraint Satisfaction Problems", 
    "publish": "2000-03-08T12:52:32Z", 
    "summary": "Many logic programming based approaches can be used to describe and solve\ncombinatorial search problems. On the one hand there are definite programs and\nconstraint logic programs that compute a solution as an answer substitution to\na query containing the variables of the constraint satisfaction problem. On the\nother hand there are approaches based on stable model semantics, abduction, and\nfirst-order logic model generation that compute solutions as models of some\ntheory. This paper compares these different approaches from point of view of\nknowledge representation (how declarative are the programs) and from point of\nview of performance (how good are they at solving typical problems)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003026v1", 
    "other_authors": [
        "Nikolay Pelov", 
        "Emmanuel De Mot", 
        "Maurice Bruynooghe"
    ], 
    "lead_author": "Maurice Bruynooghe", 
    "arxiv-id": "cs/0003026v1", 
    "title": "A Comparison of Logic Programming Approaches for Representation and   Solving of Constraint Satisfaction Problems", 
    "publish": "2000-03-08T12:52:32Z", 
    "summary": "Many logic programming based approaches can be used to describe and solve\ncombinatorial search problems. On the one hand there are definite programs and\nconstraint logic programs that compute a solution as an answer substitution to\na query containing the variables of the constraint satisfaction problem. On the\nother hand there are approaches based on stable model semantics, abduction, and\nfirst-order logic model generation that compute solutions as models of some\ntheory. This paper compares these different approaches from point of view of\nknowledge representation (how declarative are the programs) and from point of\nview of performance (how good are they at solving typical problems)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003026v1", 
    "other_authors": [
        "Nikolay Pelov", 
        "Emmanuel De Mot", 
        "Maurice Bruynooghe"
    ], 
    "lead_author": "Maurice Bruynooghe", 
    "arxiv-id": "cs/0003026v1", 
    "title": "A Comparison of Logic Programming Approaches for Representation and   Solving of Constraint Satisfaction Problems", 
    "publish": "2000-03-08T12:52:32Z", 
    "summary": "Many logic programming based approaches can be used to describe and solve\ncombinatorial search problems. On the one hand there are definite programs and\nconstraint logic programs that compute a solution as an answer substitution to\na query containing the variables of the constraint satisfaction problem. On the\nother hand there are approaches based on stable model semantics, abduction, and\nfirst-order logic model generation that compute solutions as models of some\ntheory. This paper compares these different approaches from point of view of\nknowledge representation (how declarative are the programs) and from point of\nview of performance (how good are they at solving typical problems)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003026v1", 
    "other_authors": [
        "Nikolay Pelov", 
        "Emmanuel De Mot", 
        "Maurice Bruynooghe"
    ], 
    "lead_author": "Maurice Bruynooghe", 
    "arxiv-id": "cs/0003026v1", 
    "title": "A Comparison of Logic Programming Approaches for Representation and   Solving of Constraint Satisfaction Problems", 
    "publish": "2000-03-08T12:52:32Z", 
    "summary": "Many logic programming based approaches can be used to describe and solve\ncombinatorial search problems. On the one hand there are definite programs and\nconstraint logic programs that compute a solution as an answer substitution to\na query containing the variables of the constraint satisfaction problem. On the\nother hand there are approaches based on stable model semantics, abduction, and\nfirst-order logic model generation that compute solutions as models of some\ntheory. This paper compares these different approaches from point of view of\nknowledge representation (how declarative are the programs) and from point of\nview of performance (how good are they at solving typical problems)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003026v1", 
    "other_authors": [
        "Nikolay Pelov", 
        "Emmanuel De Mot", 
        "Maurice Bruynooghe"
    ], 
    "lead_author": "Maurice Bruynooghe", 
    "arxiv-id": "cs/0003026v1", 
    "title": "A Comparison of Logic Programming Approaches for Representation and   Solving of Constraint Satisfaction Problems", 
    "publish": "2000-03-08T12:52:32Z", 
    "summary": "Many logic programming based approaches can be used to describe and solve\ncombinatorial search problems. On the one hand there are definite programs and\nconstraint logic programs that compute a solution as an answer substitution to\na query containing the variables of the constraint satisfaction problem. On the\nother hand there are approaches based on stable model semantics, abduction, and\nfirst-order logic model generation that compute solutions as models of some\ntheory. This paper compares these different approaches from point of view of\nknowledge representation (how declarative are the programs) and from point of\nview of performance (how good are they at solving typical problems)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003026v1", 
    "other_authors": [
        "Nikolay Pelov", 
        "Emmanuel De Mot", 
        "Maurice Bruynooghe"
    ], 
    "lead_author": "Maurice Bruynooghe", 
    "arxiv-id": "cs/0003026v1", 
    "title": "A Comparison of Logic Programming Approaches for Representation and   Solving of Constraint Satisfaction Problems", 
    "publish": "2000-03-08T12:52:32Z", 
    "summary": "Many logic programming based approaches can be used to describe and solve\ncombinatorial search problems. On the one hand there are definite programs and\nconstraint logic programs that compute a solution as an answer substitution to\na query containing the variables of the constraint satisfaction problem. On the\nother hand there are approaches based on stable model semantics, abduction, and\nfirst-order logic model generation that compute solutions as models of some\ntheory. This paper compares these different approaches from point of view of\nknowledge representation (how declarative are the programs) and from point of\nview of performance (how good are they at solving typical problems)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003045v1", 
    "other_authors": [
        "Sofie Verbaeten", 
        "Danny De Schreye", 
        "Konstantinos Sagonas"
    ], 
    "lead_author": "Sofie Verbaeten", 
    "arxiv-id": "cs/0003045v1", 
    "title": "Termination Proofs for Logic Programs with Tabling", 
    "publish": "2000-03-09T16:27:22Z", 
    "summary": "Tabled logic programming is receiving increasing attention in the Logic\nProgramming community. It avoids many of the shortcomings of SLD execution and\nprovides a more flexible and often extremely efficient execution mechanism for\nlogic programs. In particular, tabled execution of logic programs terminates\nmore often than execution based on SLD-resolution. In this article, we\nintroduce two notions of universal termination of logic programming with\nTabling: quasi-termination and (the stronger notion of) LG-termination. We\npresent sufficient conditions for these two notions of termination, namely\nquasi-acceptability and LG-acceptability, and we show that these conditions are\nalso necessary in case the tabling is well-chosen. Starting from these\nconditions, we give modular termination proofs, i.e., proofs capable of\ncombining termination proofs of separate programs to obtain termination proofs\nof combined programs. Finally, in the presence of mode information, we state\nsufficient conditions which form the basis for automatically proving\ntermination in a constraint-based way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003045v1", 
    "other_authors": [
        "Sofie Verbaeten", 
        "Danny De Schreye", 
        "Konstantinos Sagonas"
    ], 
    "lead_author": "Danny De Schreye", 
    "arxiv-id": "cs/0003045v1", 
    "title": "Termination Proofs for Logic Programs with Tabling", 
    "publish": "2000-03-09T16:27:22Z", 
    "summary": "Tabled logic programming is receiving increasing attention in the Logic\nProgramming community. It avoids many of the shortcomings of SLD execution and\nprovides a more flexible and often extremely efficient execution mechanism for\nlogic programs. In particular, tabled execution of logic programs terminates\nmore often than execution based on SLD-resolution. In this article, we\nintroduce two notions of universal termination of logic programming with\nTabling: quasi-termination and (the stronger notion of) LG-termination. We\npresent sufficient conditions for these two notions of termination, namely\nquasi-acceptability and LG-acceptability, and we show that these conditions are\nalso necessary in case the tabling is well-chosen. Starting from these\nconditions, we give modular termination proofs, i.e., proofs capable of\ncombining termination proofs of separate programs to obtain termination proofs\nof combined programs. Finally, in the presence of mode information, we state\nsufficient conditions which form the basis for automatically proving\ntermination in a constraint-based way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003045v1", 
    "other_authors": [
        "Sofie Verbaeten", 
        "Danny De Schreye", 
        "Konstantinos Sagonas"
    ], 
    "lead_author": "Danny De Schreye", 
    "arxiv-id": "cs/0003045v1", 
    "title": "Termination Proofs for Logic Programs with Tabling", 
    "publish": "2000-03-09T16:27:22Z", 
    "summary": "Tabled logic programming is receiving increasing attention in the Logic\nProgramming community. It avoids many of the shortcomings of SLD execution and\nprovides a more flexible and often extremely efficient execution mechanism for\nlogic programs. In particular, tabled execution of logic programs terminates\nmore often than execution based on SLD-resolution. In this article, we\nintroduce two notions of universal termination of logic programming with\nTabling: quasi-termination and (the stronger notion of) LG-termination. We\npresent sufficient conditions for these two notions of termination, namely\nquasi-acceptability and LG-acceptability, and we show that these conditions are\nalso necessary in case the tabling is well-chosen. Starting from these\nconditions, we give modular termination proofs, i.e., proofs capable of\ncombining termination proofs of separate programs to obtain termination proofs\nof combined programs. Finally, in the presence of mode information, we state\nsufficient conditions which form the basis for automatically proving\ntermination in a constraint-based way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003045v1", 
    "other_authors": [
        "Sofie Verbaeten", 
        "Danny De Schreye", 
        "Konstantinos Sagonas"
    ], 
    "lead_author": "Danny De Schreye", 
    "arxiv-id": "cs/0003045v1", 
    "title": "Termination Proofs for Logic Programs with Tabling", 
    "publish": "2000-03-09T16:27:22Z", 
    "summary": "Tabled logic programming is receiving increasing attention in the Logic\nProgramming community. It avoids many of the shortcomings of SLD execution and\nprovides a more flexible and often extremely efficient execution mechanism for\nlogic programs. In particular, tabled execution of logic programs terminates\nmore often than execution based on SLD-resolution. In this article, we\nintroduce two notions of universal termination of logic programming with\nTabling: quasi-termination and (the stronger notion of) LG-termination. We\npresent sufficient conditions for these two notions of termination, namely\nquasi-acceptability and LG-acceptability, and we show that these conditions are\nalso necessary in case the tabling is well-chosen. Starting from these\nconditions, we give modular termination proofs, i.e., proofs capable of\ncombining termination proofs of separate programs to obtain termination proofs\nof combined programs. Finally, in the presence of mode information, we state\nsufficient conditions which form the basis for automatically proving\ntermination in a constraint-based way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003045v1", 
    "other_authors": [
        "Sofie Verbaeten", 
        "Danny De Schreye", 
        "Konstantinos Sagonas"
    ], 
    "lead_author": "Danny De Schreye", 
    "arxiv-id": "cs/0003045v1", 
    "title": "Termination Proofs for Logic Programs with Tabling", 
    "publish": "2000-03-09T16:27:22Z", 
    "summary": "Tabled logic programming is receiving increasing attention in the Logic\nProgramming community. It avoids many of the shortcomings of SLD execution and\nprovides a more flexible and often extremely efficient execution mechanism for\nlogic programs. In particular, tabled execution of logic programs terminates\nmore often than execution based on SLD-resolution. In this article, we\nintroduce two notions of universal termination of logic programming with\nTabling: quasi-termination and (the stronger notion of) LG-termination. We\npresent sufficient conditions for these two notions of termination, namely\nquasi-acceptability and LG-acceptability, and we show that these conditions are\nalso necessary in case the tabling is well-chosen. Starting from these\nconditions, we give modular termination proofs, i.e., proofs capable of\ncombining termination proofs of separate programs to obtain termination proofs\nof combined programs. Finally, in the presence of mode information, we state\nsufficient conditions which form the basis for automatically proving\ntermination in a constraint-based way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003045v1", 
    "other_authors": [
        "Sofie Verbaeten", 
        "Danny De Schreye", 
        "Konstantinos Sagonas"
    ], 
    "lead_author": "Danny De Schreye", 
    "arxiv-id": "cs/0003045v1", 
    "title": "Termination Proofs for Logic Programs with Tabling", 
    "publish": "2000-03-09T16:27:22Z", 
    "summary": "Tabled logic programming is receiving increasing attention in the Logic\nProgramming community. It avoids many of the shortcomings of SLD execution and\nprovides a more flexible and often extremely efficient execution mechanism for\nlogic programs. In particular, tabled execution of logic programs terminates\nmore often than execution based on SLD-resolution. In this article, we\nintroduce two notions of universal termination of logic programming with\nTabling: quasi-termination and (the stronger notion of) LG-termination. We\npresent sufficient conditions for these two notions of termination, namely\nquasi-acceptability and LG-acceptability, and we show that these conditions are\nalso necessary in case the tabling is well-chosen. Starting from these\nconditions, we give modular termination proofs, i.e., proofs capable of\ncombining termination proofs of separate programs to obtain termination proofs\nof combined programs. Finally, in the presence of mode information, we state\nsufficient conditions which form the basis for automatically proving\ntermination in a constraint-based way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003045v1", 
    "other_authors": [
        "Sofie Verbaeten", 
        "Danny De Schreye", 
        "Konstantinos Sagonas"
    ], 
    "lead_author": "Danny De Schreye", 
    "arxiv-id": "cs/0003045v1", 
    "title": "Termination Proofs for Logic Programs with Tabling", 
    "publish": "2000-03-09T16:27:22Z", 
    "summary": "Tabled logic programming is receiving increasing attention in the Logic\nProgramming community. It avoids many of the shortcomings of SLD execution and\nprovides a more flexible and often extremely efficient execution mechanism for\nlogic programs. In particular, tabled execution of logic programs terminates\nmore often than execution based on SLD-resolution. In this article, we\nintroduce two notions of universal termination of logic programming with\nTabling: quasi-termination and (the stronger notion of) LG-termination. We\npresent sufficient conditions for these two notions of termination, namely\nquasi-acceptability and LG-acceptability, and we show that these conditions are\nalso necessary in case the tabling is well-chosen. Starting from these\nconditions, we give modular termination proofs, i.e., proofs capable of\ncombining termination proofs of separate programs to obtain termination proofs\nof combined programs. Finally, in the presence of mode information, we state\nsufficient conditions which form the basis for automatically proving\ntermination in a constraint-based way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003045v1", 
    "other_authors": [
        "Sofie Verbaeten", 
        "Danny De Schreye", 
        "Konstantinos Sagonas"
    ], 
    "lead_author": "Danny De Schreye", 
    "arxiv-id": "cs/0003045v1", 
    "title": "Termination Proofs for Logic Programs with Tabling", 
    "publish": "2000-03-09T16:27:22Z", 
    "summary": "Tabled logic programming is receiving increasing attention in the Logic\nProgramming community. It avoids many of the shortcomings of SLD execution and\nprovides a more flexible and often extremely efficient execution mechanism for\nlogic programs. In particular, tabled execution of logic programs terminates\nmore often than execution based on SLD-resolution. In this article, we\nintroduce two notions of universal termination of logic programming with\nTabling: quasi-termination and (the stronger notion of) LG-termination. We\npresent sufficient conditions for these two notions of termination, namely\nquasi-acceptability and LG-acceptability, and we show that these conditions are\nalso necessary in case the tabling is well-chosen. Starting from these\nconditions, we give modular termination proofs, i.e., proofs capable of\ncombining termination proofs of separate programs to obtain termination proofs\nof combined programs. Finally, in the presence of mode information, we state\nsufficient conditions which form the basis for automatically proving\ntermination in a constraint-based way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003045v1", 
    "other_authors": [
        "Sofie Verbaeten", 
        "Danny De Schreye", 
        "Konstantinos Sagonas"
    ], 
    "lead_author": "Danny De Schreye", 
    "arxiv-id": "cs/0003045v1", 
    "title": "Termination Proofs for Logic Programs with Tabling", 
    "publish": "2000-03-09T16:27:22Z", 
    "summary": "Tabled logic programming is receiving increasing attention in the Logic\nProgramming community. It avoids many of the shortcomings of SLD execution and\nprovides a more flexible and often extremely efficient execution mechanism for\nlogic programs. In particular, tabled execution of logic programs terminates\nmore often than execution based on SLD-resolution. In this article, we\nintroduce two notions of universal termination of logic programming with\nTabling: quasi-termination and (the stronger notion of) LG-termination. We\npresent sufficient conditions for these two notions of termination, namely\nquasi-acceptability and LG-acceptability, and we show that these conditions are\nalso necessary in case the tabling is well-chosen. Starting from these\nconditions, we give modular termination proofs, i.e., proofs capable of\ncombining termination proofs of separate programs to obtain termination proofs\nof combined programs. Finally, in the presence of mode information, we state\nsufficient conditions which form the basis for automatically proving\ntermination in a constraint-based way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003045v1", 
    "other_authors": [
        "Sofie Verbaeten", 
        "Danny De Schreye", 
        "Konstantinos Sagonas"
    ], 
    "lead_author": "Danny De Schreye", 
    "arxiv-id": "cs/0003045v1", 
    "title": "Termination Proofs for Logic Programs with Tabling", 
    "publish": "2000-03-09T16:27:22Z", 
    "summary": "Tabled logic programming is receiving increasing attention in the Logic\nProgramming community. It avoids many of the shortcomings of SLD execution and\nprovides a more flexible and often extremely efficient execution mechanism for\nlogic programs. In particular, tabled execution of logic programs terminates\nmore often than execution based on SLD-resolution. In this article, we\nintroduce two notions of universal termination of logic programming with\nTabling: quasi-termination and (the stronger notion of) LG-termination. We\npresent sufficient conditions for these two notions of termination, namely\nquasi-acceptability and LG-acceptability, and we show that these conditions are\nalso necessary in case the tabling is well-chosen. Starting from these\nconditions, we give modular termination proofs, i.e., proofs capable of\ncombining termination proofs of separate programs to obtain termination proofs\nof combined programs. Finally, in the presence of mode information, we state\nsufficient conditions which form the basis for automatically proving\ntermination in a constraint-based way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003045v1", 
    "other_authors": [
        "Sofie Verbaeten", 
        "Danny De Schreye", 
        "Konstantinos Sagonas"
    ], 
    "lead_author": "Danny De Schreye", 
    "arxiv-id": "cs/0003045v1", 
    "title": "Termination Proofs for Logic Programs with Tabling", 
    "publish": "2000-03-09T16:27:22Z", 
    "summary": "Tabled logic programming is receiving increasing attention in the Logic\nProgramming community. It avoids many of the shortcomings of SLD execution and\nprovides a more flexible and often extremely efficient execution mechanism for\nlogic programs. In particular, tabled execution of logic programs terminates\nmore often than execution based on SLD-resolution. In this article, we\nintroduce two notions of universal termination of logic programming with\nTabling: quasi-termination and (the stronger notion of) LG-termination. We\npresent sufficient conditions for these two notions of termination, namely\nquasi-acceptability and LG-acceptability, and we show that these conditions are\nalso necessary in case the tabling is well-chosen. Starting from these\nconditions, we give modular termination proofs, i.e., proofs capable of\ncombining termination proofs of separate programs to obtain termination proofs\nof combined programs. Finally, in the presence of mode information, we state\nsufficient conditions which form the basis for automatically proving\ntermination in a constraint-based way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003045v1", 
    "other_authors": [
        "Sofie Verbaeten", 
        "Danny De Schreye", 
        "Konstantinos Sagonas"
    ], 
    "lead_author": "Danny De Schreye", 
    "arxiv-id": "cs/0003045v1", 
    "title": "Termination Proofs for Logic Programs with Tabling", 
    "publish": "2000-03-09T16:27:22Z", 
    "summary": "Tabled logic programming is receiving increasing attention in the Logic\nProgramming community. It avoids many of the shortcomings of SLD execution and\nprovides a more flexible and often extremely efficient execution mechanism for\nlogic programs. In particular, tabled execution of logic programs terminates\nmore often than execution based on SLD-resolution. In this article, we\nintroduce two notions of universal termination of logic programming with\nTabling: quasi-termination and (the stronger notion of) LG-termination. We\npresent sufficient conditions for these two notions of termination, namely\nquasi-acceptability and LG-acceptability, and we show that these conditions are\nalso necessary in case the tabling is well-chosen. Starting from these\nconditions, we give modular termination proofs, i.e., proofs capable of\ncombining termination proofs of separate programs to obtain termination proofs\nof combined programs. Finally, in the presence of mode information, we state\nsufficient conditions which form the basis for automatically proving\ntermination in a constraint-based way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003045v1", 
    "other_authors": [
        "Sofie Verbaeten", 
        "Danny De Schreye", 
        "Konstantinos Sagonas"
    ], 
    "lead_author": "Konstantinos Sagonas", 
    "arxiv-id": "cs/0003045v1", 
    "title": "Termination Proofs for Logic Programs with Tabling", 
    "publish": "2000-03-09T16:27:22Z", 
    "summary": "Tabled logic programming is receiving increasing attention in the Logic\nProgramming community. It avoids many of the shortcomings of SLD execution and\nprovides a more flexible and often extremely efficient execution mechanism for\nlogic programs. In particular, tabled execution of logic programs terminates\nmore often than execution based on SLD-resolution. In this article, we\nintroduce two notions of universal termination of logic programming with\nTabling: quasi-termination and (the stronger notion of) LG-termination. We\npresent sufficient conditions for these two notions of termination, namely\nquasi-acceptability and LG-acceptability, and we show that these conditions are\nalso necessary in case the tabling is well-chosen. Starting from these\nconditions, we give modular termination proofs, i.e., proofs capable of\ncombining termination proofs of separate programs to obtain termination proofs\nof combined programs. Finally, in the presence of mode information, we state\nsufficient conditions which form the basis for automatically proving\ntermination in a constraint-based way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003045v1", 
    "other_authors": [
        "Sofie Verbaeten", 
        "Danny De Schreye", 
        "Konstantinos Sagonas"
    ], 
    "lead_author": "Konstantinos Sagonas", 
    "arxiv-id": "cs/0003045v1", 
    "title": "Termination Proofs for Logic Programs with Tabling", 
    "publish": "2000-03-09T16:27:22Z", 
    "summary": "Tabled logic programming is receiving increasing attention in the Logic\nProgramming community. It avoids many of the shortcomings of SLD execution and\nprovides a more flexible and often extremely efficient execution mechanism for\nlogic programs. In particular, tabled execution of logic programs terminates\nmore often than execution based on SLD-resolution. In this article, we\nintroduce two notions of universal termination of logic programming with\nTabling: quasi-termination and (the stronger notion of) LG-termination. We\npresent sufficient conditions for these two notions of termination, namely\nquasi-acceptability and LG-acceptability, and we show that these conditions are\nalso necessary in case the tabling is well-chosen. Starting from these\nconditions, we give modular termination proofs, i.e., proofs capable of\ncombining termination proofs of separate programs to obtain termination proofs\nof combined programs. Finally, in the presence of mode information, we state\nsufficient conditions which form the basis for automatically proving\ntermination in a constraint-based way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003045v1", 
    "other_authors": [
        "Sofie Verbaeten", 
        "Danny De Schreye", 
        "Konstantinos Sagonas"
    ], 
    "lead_author": "Konstantinos Sagonas", 
    "arxiv-id": "cs/0003045v1", 
    "title": "Termination Proofs for Logic Programs with Tabling", 
    "publish": "2000-03-09T16:27:22Z", 
    "summary": "Tabled logic programming is receiving increasing attention in the Logic\nProgramming community. It avoids many of the shortcomings of SLD execution and\nprovides a more flexible and often extremely efficient execution mechanism for\nlogic programs. In particular, tabled execution of logic programs terminates\nmore often than execution based on SLD-resolution. In this article, we\nintroduce two notions of universal termination of logic programming with\nTabling: quasi-termination and (the stronger notion of) LG-termination. We\npresent sufficient conditions for these two notions of termination, namely\nquasi-acceptability and LG-acceptability, and we show that these conditions are\nalso necessary in case the tabling is well-chosen. Starting from these\nconditions, we give modular termination proofs, i.e., proofs capable of\ncombining termination proofs of separate programs to obtain termination proofs\nof combined programs. Finally, in the presence of mode information, we state\nsufficient conditions which form the basis for automatically proving\ntermination in a constraint-based way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003045v1", 
    "other_authors": [
        "Sofie Verbaeten", 
        "Danny De Schreye", 
        "Konstantinos Sagonas"
    ], 
    "lead_author": "Konstantinos Sagonas", 
    "arxiv-id": "cs/0003045v1", 
    "title": "Termination Proofs for Logic Programs with Tabling", 
    "publish": "2000-03-09T16:27:22Z", 
    "summary": "Tabled logic programming is receiving increasing attention in the Logic\nProgramming community. It avoids many of the shortcomings of SLD execution and\nprovides a more flexible and often extremely efficient execution mechanism for\nlogic programs. In particular, tabled execution of logic programs terminates\nmore often than execution based on SLD-resolution. In this article, we\nintroduce two notions of universal termination of logic programming with\nTabling: quasi-termination and (the stronger notion of) LG-termination. We\npresent sufficient conditions for these two notions of termination, namely\nquasi-acceptability and LG-acceptability, and we show that these conditions are\nalso necessary in case the tabling is well-chosen. Starting from these\nconditions, we give modular termination proofs, i.e., proofs capable of\ncombining termination proofs of separate programs to obtain termination proofs\nof combined programs. Finally, in the presence of mode information, we state\nsufficient conditions which form the basis for automatically proving\ntermination in a constraint-based way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003045v1", 
    "other_authors": [
        "Sofie Verbaeten", 
        "Danny De Schreye", 
        "Konstantinos Sagonas"
    ], 
    "lead_author": "Konstantinos Sagonas", 
    "arxiv-id": "cs/0003045v1", 
    "title": "Termination Proofs for Logic Programs with Tabling", 
    "publish": "2000-03-09T16:27:22Z", 
    "summary": "Tabled logic programming is receiving increasing attention in the Logic\nProgramming community. It avoids many of the shortcomings of SLD execution and\nprovides a more flexible and often extremely efficient execution mechanism for\nlogic programs. In particular, tabled execution of logic programs terminates\nmore often than execution based on SLD-resolution. In this article, we\nintroduce two notions of universal termination of logic programming with\nTabling: quasi-termination and (the stronger notion of) LG-termination. We\npresent sufficient conditions for these two notions of termination, namely\nquasi-acceptability and LG-acceptability, and we show that these conditions are\nalso necessary in case the tabling is well-chosen. Starting from these\nconditions, we give modular termination proofs, i.e., proofs capable of\ncombining termination proofs of separate programs to obtain termination proofs\nof combined programs. Finally, in the presence of mode information, we state\nsufficient conditions which form the basis for automatically proving\ntermination in a constraint-based way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003045v1", 
    "other_authors": [
        "Sofie Verbaeten", 
        "Danny De Schreye", 
        "Konstantinos Sagonas"
    ], 
    "lead_author": "Konstantinos Sagonas", 
    "arxiv-id": "cs/0003045v1", 
    "title": "Termination Proofs for Logic Programs with Tabling", 
    "publish": "2000-03-09T16:27:22Z", 
    "summary": "Tabled logic programming is receiving increasing attention in the Logic\nProgramming community. It avoids many of the shortcomings of SLD execution and\nprovides a more flexible and often extremely efficient execution mechanism for\nlogic programs. In particular, tabled execution of logic programs terminates\nmore often than execution based on SLD-resolution. In this article, we\nintroduce two notions of universal termination of logic programming with\nTabling: quasi-termination and (the stronger notion of) LG-termination. We\npresent sufficient conditions for these two notions of termination, namely\nquasi-acceptability and LG-acceptability, and we show that these conditions are\nalso necessary in case the tabling is well-chosen. Starting from these\nconditions, we give modular termination proofs, i.e., proofs capable of\ncombining termination proofs of separate programs to obtain termination proofs\nof combined programs. Finally, in the presence of mode information, we state\nsufficient conditions which form the basis for automatically proving\ntermination in a constraint-based way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003069v1", 
    "other_authors": [
        "Nikolay Pelov", 
        "Maurice Bruynooghe"
    ], 
    "lead_author": "Nikolay Pelov", 
    "arxiv-id": "cs/0003069v1", 
    "title": "Proving Failure of Queries for Definite Logic Programs Using XSB-Prolog", 
    "publish": "2000-03-20T09:45:00Z", 
    "summary": "Proving failure of queries for definite logic programs can be done by\nconstructing a finite model of the program in which the query is false. A\ngeneral purpose model generator for first order logic can be used for this. A\nrecent paper presented at PLILP98 shows how the peculiarities of definite\nprograms can be exploited to obtain a better solution. There a procedure is\ndescribed which combines abduction with tabulation and uses a meta-interpreter\nfor heuristic control of the search. The current paper shows how similar\nresults can be obtained by direct execution under the standard tabulation of\nthe XSB-Prolog system. The loss of control is compensated for by better\nintelligent backtracking and more accurate failure analysis."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003069v1", 
    "other_authors": [
        "Nikolay Pelov", 
        "Maurice Bruynooghe"
    ], 
    "lead_author": "Nikolay Pelov", 
    "arxiv-id": "cs/0003069v1", 
    "title": "Proving Failure of Queries for Definite Logic Programs Using XSB-Prolog", 
    "publish": "2000-03-20T09:45:00Z", 
    "summary": "Proving failure of queries for definite logic programs can be done by\nconstructing a finite model of the program in which the query is false. A\ngeneral purpose model generator for first order logic can be used for this. A\nrecent paper presented at PLILP98 shows how the peculiarities of definite\nprograms can be exploited to obtain a better solution. There a procedure is\ndescribed which combines abduction with tabulation and uses a meta-interpreter\nfor heuristic control of the search. The current paper shows how similar\nresults can be obtained by direct execution under the standard tabulation of\nthe XSB-Prolog system. The loss of control is compensated for by better\nintelligent backtracking and more accurate failure analysis."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003069v1", 
    "other_authors": [
        "Nikolay Pelov", 
        "Maurice Bruynooghe"
    ], 
    "lead_author": "Nikolay Pelov", 
    "arxiv-id": "cs/0003069v1", 
    "title": "Proving Failure of Queries for Definite Logic Programs Using XSB-Prolog", 
    "publish": "2000-03-20T09:45:00Z", 
    "summary": "Proving failure of queries for definite logic programs can be done by\nconstructing a finite model of the program in which the query is false. A\ngeneral purpose model generator for first order logic can be used for this. A\nrecent paper presented at PLILP98 shows how the peculiarities of definite\nprograms can be exploited to obtain a better solution. There a procedure is\ndescribed which combines abduction with tabulation and uses a meta-interpreter\nfor heuristic control of the search. The current paper shows how similar\nresults can be obtained by direct execution under the standard tabulation of\nthe XSB-Prolog system. The loss of control is compensated for by better\nintelligent backtracking and more accurate failure analysis."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003069v1", 
    "other_authors": [
        "Nikolay Pelov", 
        "Maurice Bruynooghe"
    ], 
    "lead_author": "Nikolay Pelov", 
    "arxiv-id": "cs/0003069v1", 
    "title": "Proving Failure of Queries for Definite Logic Programs Using XSB-Prolog", 
    "publish": "2000-03-20T09:45:00Z", 
    "summary": "Proving failure of queries for definite logic programs can be done by\nconstructing a finite model of the program in which the query is false. A\ngeneral purpose model generator for first order logic can be used for this. A\nrecent paper presented at PLILP98 shows how the peculiarities of definite\nprograms can be exploited to obtain a better solution. There a procedure is\ndescribed which combines abduction with tabulation and uses a meta-interpreter\nfor heuristic control of the search. The current paper shows how similar\nresults can be obtained by direct execution under the standard tabulation of\nthe XSB-Prolog system. The loss of control is compensated for by better\nintelligent backtracking and more accurate failure analysis."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003069v1", 
    "other_authors": [
        "Nikolay Pelov", 
        "Maurice Bruynooghe"
    ], 
    "lead_author": "Maurice Bruynooghe", 
    "arxiv-id": "cs/0003069v1", 
    "title": "Proving Failure of Queries for Definite Logic Programs Using XSB-Prolog", 
    "publish": "2000-03-20T09:45:00Z", 
    "summary": "Proving failure of queries for definite logic programs can be done by\nconstructing a finite model of the program in which the query is false. A\ngeneral purpose model generator for first order logic can be used for this. A\nrecent paper presented at PLILP98 shows how the peculiarities of definite\nprograms can be exploited to obtain a better solution. There a procedure is\ndescribed which combines abduction with tabulation and uses a meta-interpreter\nfor heuristic control of the search. The current paper shows how similar\nresults can be obtained by direct execution under the standard tabulation of\nthe XSB-Prolog system. The loss of control is compensated for by better\nintelligent backtracking and more accurate failure analysis."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003069v1", 
    "other_authors": [
        "Nikolay Pelov", 
        "Maurice Bruynooghe"
    ], 
    "lead_author": "Maurice Bruynooghe", 
    "arxiv-id": "cs/0003069v1", 
    "title": "Proving Failure of Queries for Definite Logic Programs Using XSB-Prolog", 
    "publish": "2000-03-20T09:45:00Z", 
    "summary": "Proving failure of queries for definite logic programs can be done by\nconstructing a finite model of the program in which the query is false. A\ngeneral purpose model generator for first order logic can be used for this. A\nrecent paper presented at PLILP98 shows how the peculiarities of definite\nprograms can be exploited to obtain a better solution. There a procedure is\ndescribed which combines abduction with tabulation and uses a meta-interpreter\nfor heuristic control of the search. The current paper shows how similar\nresults can be obtained by direct execution under the standard tabulation of\nthe XSB-Prolog system. The loss of control is compensated for by better\nintelligent backtracking and more accurate failure analysis."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003069v1", 
    "other_authors": [
        "Nikolay Pelov", 
        "Maurice Bruynooghe"
    ], 
    "lead_author": "Maurice Bruynooghe", 
    "arxiv-id": "cs/0003069v1", 
    "title": "Proving Failure of Queries for Definite Logic Programs Using XSB-Prolog", 
    "publish": "2000-03-20T09:45:00Z", 
    "summary": "Proving failure of queries for definite logic programs can be done by\nconstructing a finite model of the program in which the query is false. A\ngeneral purpose model generator for first order logic can be used for this. A\nrecent paper presented at PLILP98 shows how the peculiarities of definite\nprograms can be exploited to obtain a better solution. There a procedure is\ndescribed which combines abduction with tabulation and uses a meta-interpreter\nfor heuristic control of the search. The current paper shows how similar\nresults can be obtained by direct execution under the standard tabulation of\nthe XSB-Prolog system. The loss of control is compensated for by better\nintelligent backtracking and more accurate failure analysis."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003069v1", 
    "other_authors": [
        "Nikolay Pelov", 
        "Maurice Bruynooghe"
    ], 
    "lead_author": "Maurice Bruynooghe", 
    "arxiv-id": "cs/0003069v1", 
    "title": "Proving Failure of Queries for Definite Logic Programs Using XSB-Prolog", 
    "publish": "2000-03-20T09:45:00Z", 
    "summary": "Proving failure of queries for definite logic programs can be done by\nconstructing a finite model of the program in which the query is false. A\ngeneral purpose model generator for first order logic can be used for this. A\nrecent paper presented at PLILP98 shows how the peculiarities of definite\nprograms can be exploited to obtain a better solution. There a procedure is\ndescribed which combines abduction with tabulation and uses a meta-interpreter\nfor heuristic control of the search. The current paper shows how similar\nresults can be obtained by direct execution under the standard tabulation of\nthe XSB-Prolog system. The loss of control is compensated for by better\nintelligent backtracking and more accurate failure analysis."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003069v1", 
    "other_authors": [
        "Nikolay Pelov", 
        "Maurice Bruynooghe"
    ], 
    "lead_author": "Maurice Bruynooghe", 
    "arxiv-id": "cs/0003069v1", 
    "title": "Proving Failure of Queries for Definite Logic Programs Using XSB-Prolog", 
    "publish": "2000-03-20T09:45:00Z", 
    "summary": "Proving failure of queries for definite logic programs can be done by\nconstructing a finite model of the program in which the query is false. A\ngeneral purpose model generator for first order logic can be used for this. A\nrecent paper presented at PLILP98 shows how the peculiarities of definite\nprograms can be exploited to obtain a better solution. There a procedure is\ndescribed which combines abduction with tabulation and uses a meta-interpreter\nfor heuristic control of the search. The current paper shows how similar\nresults can be obtained by direct execution under the standard tabulation of\nthe XSB-Prolog system. The loss of control is compensated for by better\nintelligent backtracking and more accurate failure analysis."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003069v1", 
    "other_authors": [
        "Nikolay Pelov", 
        "Maurice Bruynooghe"
    ], 
    "lead_author": "Maurice Bruynooghe", 
    "arxiv-id": "cs/0003069v1", 
    "title": "Proving Failure of Queries for Definite Logic Programs Using XSB-Prolog", 
    "publish": "2000-03-20T09:45:00Z", 
    "summary": "Proving failure of queries for definite logic programs can be done by\nconstructing a finite model of the program in which the query is false. A\ngeneral purpose model generator for first order logic can be used for this. A\nrecent paper presented at PLILP98 shows how the peculiarities of definite\nprograms can be exploited to obtain a better solution. There a procedure is\ndescribed which combines abduction with tabulation and uses a meta-interpreter\nfor heuristic control of the search. The current paper shows how similar\nresults can be obtained by direct execution under the standard tabulation of\nthe XSB-Prolog system. The loss of control is compensated for by better\nintelligent backtracking and more accurate failure analysis."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003069v1", 
    "other_authors": [
        "Nikolay Pelov", 
        "Maurice Bruynooghe"
    ], 
    "lead_author": "Maurice Bruynooghe", 
    "arxiv-id": "cs/0003069v1", 
    "title": "Proving Failure of Queries for Definite Logic Programs Using XSB-Prolog", 
    "publish": "2000-03-20T09:45:00Z", 
    "summary": "Proving failure of queries for definite logic programs can be done by\nconstructing a finite model of the program in which the query is false. A\ngeneral purpose model generator for first order logic can be used for this. A\nrecent paper presented at PLILP98 shows how the peculiarities of definite\nprograms can be exploited to obtain a better solution. There a procedure is\ndescribed which combines abduction with tabulation and uses a meta-interpreter\nfor heuristic control of the search. The current paper shows how similar\nresults can be obtained by direct execution under the standard tabulation of\nthe XSB-Prolog system. The loss of control is compensated for by better\nintelligent backtracking and more accurate failure analysis."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003069v1", 
    "other_authors": [
        "Nikolay Pelov", 
        "Maurice Bruynooghe"
    ], 
    "lead_author": "Maurice Bruynooghe", 
    "arxiv-id": "cs/0003069v1", 
    "title": "Proving Failure of Queries for Definite Logic Programs Using XSB-Prolog", 
    "publish": "2000-03-20T09:45:00Z", 
    "summary": "Proving failure of queries for definite logic programs can be done by\nconstructing a finite model of the program in which the query is false. A\ngeneral purpose model generator for first order logic can be used for this. A\nrecent paper presented at PLILP98 shows how the peculiarities of definite\nprograms can be exploited to obtain a better solution. There a procedure is\ndescribed which combines abduction with tabulation and uses a meta-interpreter\nfor heuristic control of the search. The current paper shows how similar\nresults can be obtained by direct execution under the standard tabulation of\nthe XSB-Prolog system. The loss of control is compensated for by better\nintelligent backtracking and more accurate failure analysis."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003069v1", 
    "other_authors": [
        "Nikolay Pelov", 
        "Maurice Bruynooghe"
    ], 
    "lead_author": "Maurice Bruynooghe", 
    "arxiv-id": "cs/0003069v1", 
    "title": "Proving Failure of Queries for Definite Logic Programs Using XSB-Prolog", 
    "publish": "2000-03-20T09:45:00Z", 
    "summary": "Proving failure of queries for definite logic programs can be done by\nconstructing a finite model of the program in which the query is false. A\ngeneral purpose model generator for first order logic can be used for this. A\nrecent paper presented at PLILP98 shows how the peculiarities of definite\nprograms can be exploited to obtain a better solution. There a procedure is\ndescribed which combines abduction with tabulation and uses a meta-interpreter\nfor heuristic control of the search. The current paper shows how similar\nresults can be obtained by direct execution under the standard tabulation of\nthe XSB-Prolog system. The loss of control is compensated for by better\nintelligent backtracking and more accurate failure analysis."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003069v1", 
    "other_authors": [
        "Nikolay Pelov", 
        "Maurice Bruynooghe"
    ], 
    "lead_author": "Maurice Bruynooghe", 
    "arxiv-id": "cs/0003069v1", 
    "title": "Proving Failure of Queries for Definite Logic Programs Using XSB-Prolog", 
    "publish": "2000-03-20T09:45:00Z", 
    "summary": "Proving failure of queries for definite logic programs can be done by\nconstructing a finite model of the program in which the query is false. A\ngeneral purpose model generator for first order logic can be used for this. A\nrecent paper presented at PLILP98 shows how the peculiarities of definite\nprograms can be exploited to obtain a better solution. There a procedure is\ndescribed which combines abduction with tabulation and uses a meta-interpreter\nfor heuristic control of the search. The current paper shows how similar\nresults can be obtained by direct execution under the standard tabulation of\nthe XSB-Prolog system. The loss of control is compensated for by better\nintelligent backtracking and more accurate failure analysis."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003069v1", 
    "other_authors": [
        "Nikolay Pelov", 
        "Maurice Bruynooghe"
    ], 
    "lead_author": "Maurice Bruynooghe", 
    "arxiv-id": "cs/0003069v1", 
    "title": "Proving Failure of Queries for Definite Logic Programs Using XSB-Prolog", 
    "publish": "2000-03-20T09:45:00Z", 
    "summary": "Proving failure of queries for definite logic programs can be done by\nconstructing a finite model of the program in which the query is false. A\ngeneral purpose model generator for first order logic can be used for this. A\nrecent paper presented at PLILP98 shows how the peculiarities of definite\nprograms can be exploited to obtain a better solution. There a procedure is\ndescribed which combines abduction with tabulation and uses a meta-interpreter\nfor heuristic control of the search. The current paper shows how similar\nresults can be obtained by direct execution under the standard tabulation of\nthe XSB-Prolog system. The loss of control is compensated for by better\nintelligent backtracking and more accurate failure analysis."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003069v1", 
    "other_authors": [
        "Nikolay Pelov", 
        "Maurice Bruynooghe"
    ], 
    "lead_author": "Maurice Bruynooghe", 
    "arxiv-id": "cs/0003069v1", 
    "title": "Proving Failure of Queries for Definite Logic Programs Using XSB-Prolog", 
    "publish": "2000-03-20T09:45:00Z", 
    "summary": "Proving failure of queries for definite logic programs can be done by\nconstructing a finite model of the program in which the query is false. A\ngeneral purpose model generator for first order logic can be used for this. A\nrecent paper presented at PLILP98 shows how the peculiarities of definite\nprograms can be exploited to obtain a better solution. There a procedure is\ndescribed which combines abduction with tabulation and uses a meta-interpreter\nfor heuristic control of the search. The current paper shows how similar\nresults can be obtained by direct execution under the standard tabulation of\nthe XSB-Prolog system. The loss of control is compensated for by better\nintelligent backtracking and more accurate failure analysis."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003069v1", 
    "other_authors": [
        "Nikolay Pelov", 
        "Maurice Bruynooghe"
    ], 
    "lead_author": "Maurice Bruynooghe", 
    "arxiv-id": "cs/0003069v1", 
    "title": "Proving Failure of Queries for Definite Logic Programs Using XSB-Prolog", 
    "publish": "2000-03-20T09:45:00Z", 
    "summary": "Proving failure of queries for definite logic programs can be done by\nconstructing a finite model of the program in which the query is false. A\ngeneral purpose model generator for first order logic can be used for this. A\nrecent paper presented at PLILP98 shows how the peculiarities of definite\nprograms can be exploited to obtain a better solution. There a procedure is\ndescribed which combines abduction with tabulation and uses a meta-interpreter\nfor heuristic control of the search. The current paper shows how similar\nresults can be obtained by direct execution under the standard tabulation of\nthe XSB-Prolog system. The loss of control is compensated for by better\nintelligent backtracking and more accurate failure analysis."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003069v1", 
    "other_authors": [
        "Nikolay Pelov", 
        "Maurice Bruynooghe"
    ], 
    "lead_author": "Maurice Bruynooghe", 
    "arxiv-id": "cs/0003069v1", 
    "title": "Proving Failure of Queries for Definite Logic Programs Using XSB-Prolog", 
    "publish": "2000-03-20T09:45:00Z", 
    "summary": "Proving failure of queries for definite logic programs can be done by\nconstructing a finite model of the program in which the query is false. A\ngeneral purpose model generator for first order logic can be used for this. A\nrecent paper presented at PLILP98 shows how the peculiarities of definite\nprograms can be exploited to obtain a better solution. There a procedure is\ndescribed which combines abduction with tabulation and uses a meta-interpreter\nfor heuristic control of the search. The current paper shows how similar\nresults can be obtained by direct execution under the standard tabulation of\nthe XSB-Prolog system. The loss of control is compensated for by better\nintelligent backtracking and more accurate failure analysis."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003069v1", 
    "other_authors": [
        "Nikolay Pelov", 
        "Maurice Bruynooghe"
    ], 
    "lead_author": "Maurice Bruynooghe", 
    "arxiv-id": "cs/0003069v1", 
    "title": "Proving Failure of Queries for Definite Logic Programs Using XSB-Prolog", 
    "publish": "2000-03-20T09:45:00Z", 
    "summary": "Proving failure of queries for definite logic programs can be done by\nconstructing a finite model of the program in which the query is false. A\ngeneral purpose model generator for first order logic can be used for this. A\nrecent paper presented at PLILP98 shows how the peculiarities of definite\nprograms can be exploited to obtain a better solution. There a procedure is\ndescribed which combines abduction with tabulation and uses a meta-interpreter\nfor heuristic control of the search. The current paper shows how similar\nresults can be obtained by direct execution under the standard tabulation of\nthe XSB-Prolog system. The loss of control is compensated for by better\nintelligent backtracking and more accurate failure analysis."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003069v1", 
    "other_authors": [
        "Nikolay Pelov", 
        "Maurice Bruynooghe"
    ], 
    "lead_author": "Maurice Bruynooghe", 
    "arxiv-id": "cs/0003069v1", 
    "title": "Proving Failure of Queries for Definite Logic Programs Using XSB-Prolog", 
    "publish": "2000-03-20T09:45:00Z", 
    "summary": "Proving failure of queries for definite logic programs can be done by\nconstructing a finite model of the program in which the query is false. A\ngeneral purpose model generator for first order logic can be used for this. A\nrecent paper presented at PLILP98 shows how the peculiarities of definite\nprograms can be exploited to obtain a better solution. There a procedure is\ndescribed which combines abduction with tabulation and uses a meta-interpreter\nfor heuristic control of the search. The current paper shows how similar\nresults can be obtained by direct execution under the standard tabulation of\nthe XSB-Prolog system. The loss of control is compensated for by better\nintelligent backtracking and more accurate failure analysis."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003069v1", 
    "other_authors": [
        "Nikolay Pelov", 
        "Maurice Bruynooghe"
    ], 
    "lead_author": "Maurice Bruynooghe", 
    "arxiv-id": "cs/0003069v1", 
    "title": "Proving Failure of Queries for Definite Logic Programs Using XSB-Prolog", 
    "publish": "2000-03-20T09:45:00Z", 
    "summary": "Proving failure of queries for definite logic programs can be done by\nconstructing a finite model of the program in which the query is false. A\ngeneral purpose model generator for first order logic can be used for this. A\nrecent paper presented at PLILP98 shows how the peculiarities of definite\nprograms can be exploited to obtain a better solution. There a procedure is\ndescribed which combines abduction with tabulation and uses a meta-interpreter\nfor heuristic control of the search. The current paper shows how similar\nresults can be obtained by direct execution under the standard tabulation of\nthe XSB-Prolog system. The loss of control is compensated for by better\nintelligent backtracking and more accurate failure analysis."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003069v1", 
    "other_authors": [
        "Nikolay Pelov", 
        "Maurice Bruynooghe"
    ], 
    "lead_author": "Maurice Bruynooghe", 
    "arxiv-id": "cs/0003069v1", 
    "title": "Proving Failure of Queries for Definite Logic Programs Using XSB-Prolog", 
    "publish": "2000-03-20T09:45:00Z", 
    "summary": "Proving failure of queries for definite logic programs can be done by\nconstructing a finite model of the program in which the query is false. A\ngeneral purpose model generator for first order logic can be used for this. A\nrecent paper presented at PLILP98 shows how the peculiarities of definite\nprograms can be exploited to obtain a better solution. There a procedure is\ndescribed which combines abduction with tabulation and uses a meta-interpreter\nfor heuristic control of the search. The current paper shows how similar\nresults can be obtained by direct execution under the standard tabulation of\nthe XSB-Prolog system. The loss of control is compensated for by better\nintelligent backtracking and more accurate failure analysis."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003069v1", 
    "other_authors": [
        "Nikolay Pelov", 
        "Maurice Bruynooghe"
    ], 
    "lead_author": "Maurice Bruynooghe", 
    "arxiv-id": "cs/0003069v1", 
    "title": "Proving Failure of Queries for Definite Logic Programs Using XSB-Prolog", 
    "publish": "2000-03-20T09:45:00Z", 
    "summary": "Proving failure of queries for definite logic programs can be done by\nconstructing a finite model of the program in which the query is false. A\ngeneral purpose model generator for first order logic can be used for this. A\nrecent paper presented at PLILP98 shows how the peculiarities of definite\nprograms can be exploited to obtain a better solution. There a procedure is\ndescribed which combines abduction with tabulation and uses a meta-interpreter\nfor heuristic control of the search. The current paper shows how similar\nresults can be obtained by direct execution under the standard tabulation of\nthe XSB-Prolog system. The loss of control is compensated for by better\nintelligent backtracking and more accurate failure analysis."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003069v1", 
    "other_authors": [
        "Nikolay Pelov", 
        "Maurice Bruynooghe"
    ], 
    "lead_author": "Maurice Bruynooghe", 
    "arxiv-id": "cs/0003069v1", 
    "title": "Proving Failure of Queries for Definite Logic Programs Using XSB-Prolog", 
    "publish": "2000-03-20T09:45:00Z", 
    "summary": "Proving failure of queries for definite logic programs can be done by\nconstructing a finite model of the program in which the query is false. A\ngeneral purpose model generator for first order logic can be used for this. A\nrecent paper presented at PLILP98 shows how the peculiarities of definite\nprograms can be exploited to obtain a better solution. There a procedure is\ndescribed which combines abduction with tabulation and uses a meta-interpreter\nfor heuristic control of the search. The current paper shows how similar\nresults can be obtained by direct execution under the standard tabulation of\nthe XSB-Prolog system. The loss of control is compensated for by better\nintelligent backtracking and more accurate failure analysis."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003069v1", 
    "other_authors": [
        "Nikolay Pelov", 
        "Maurice Bruynooghe"
    ], 
    "lead_author": "Maurice Bruynooghe", 
    "arxiv-id": "cs/0003069v1", 
    "title": "Proving Failure of Queries for Definite Logic Programs Using XSB-Prolog", 
    "publish": "2000-03-20T09:45:00Z", 
    "summary": "Proving failure of queries for definite logic programs can be done by\nconstructing a finite model of the program in which the query is false. A\ngeneral purpose model generator for first order logic can be used for this. A\nrecent paper presented at PLILP98 shows how the peculiarities of definite\nprograms can be exploited to obtain a better solution. There a procedure is\ndescribed which combines abduction with tabulation and uses a meta-interpreter\nfor heuristic control of the search. The current paper shows how similar\nresults can be obtained by direct execution under the standard tabulation of\nthe XSB-Prolog system. The loss of control is compensated for by better\nintelligent backtracking and more accurate failure analysis."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003069v1", 
    "other_authors": [
        "Nikolay Pelov", 
        "Maurice Bruynooghe"
    ], 
    "lead_author": "Maurice Bruynooghe", 
    "arxiv-id": "cs/0003069v1", 
    "title": "Proving Failure of Queries for Definite Logic Programs Using XSB-Prolog", 
    "publish": "2000-03-20T09:45:00Z", 
    "summary": "Proving failure of queries for definite logic programs can be done by\nconstructing a finite model of the program in which the query is false. A\ngeneral purpose model generator for first order logic can be used for this. A\nrecent paper presented at PLILP98 shows how the peculiarities of definite\nprograms can be exploited to obtain a better solution. There a procedure is\ndescribed which combines abduction with tabulation and uses a meta-interpreter\nfor heuristic control of the search. The current paper shows how similar\nresults can be obtained by direct execution under the standard tabulation of\nthe XSB-Prolog system. The loss of control is compensated for by better\nintelligent backtracking and more accurate failure analysis."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003069v1", 
    "other_authors": [
        "Nikolay Pelov", 
        "Maurice Bruynooghe"
    ], 
    "lead_author": "Maurice Bruynooghe", 
    "arxiv-id": "cs/0003069v1", 
    "title": "Proving Failure of Queries for Definite Logic Programs Using XSB-Prolog", 
    "publish": "2000-03-20T09:45:00Z", 
    "summary": "Proving failure of queries for definite logic programs can be done by\nconstructing a finite model of the program in which the query is false. A\ngeneral purpose model generator for first order logic can be used for this. A\nrecent paper presented at PLILP98 shows how the peculiarities of definite\nprograms can be exploited to obtain a better solution. There a procedure is\ndescribed which combines abduction with tabulation and uses a meta-interpreter\nfor heuristic control of the search. The current paper shows how similar\nresults can be obtained by direct execution under the standard tabulation of\nthe XSB-Prolog system. The loss of control is compensated for by better\nintelligent backtracking and more accurate failure analysis."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003071v1", 
    "other_authors": [
        "Charlie Volkstorf"
    ], 
    "lead_author": "Charlie Volkstorf", 
    "arxiv-id": "cs/0003071v1", 
    "title": "Axiomatic Synthesis of Computer Programs and Computability Theorems", 
    "publish": "2000-03-22T00:01:09Z", 
    "summary": "We introduce a set of eight universal Rules of Inference by which computer\nprograms with known properties (axioms) are transformed into new programs with\nknown properties (theorems). Axioms are presented to formalize a segment of\nNumber Theory, DataBase retrieval and Computability Theory. The resulting\nProgram Calculus is used to generate programs to (1) Determine if one number is\na factor of another. (2) List all employees who earn more than their manager.\n(3) List the set of programs that halt no on themselves, thus proving that it\nis recursively enumerable. The well-known fact that the set of programs that do\nnot halt yes on themselves is not recursively enumerable is formalized as a\nprogram requirement that has no solution, an Incompleteness Axiom. Thus, any\naxioms (programs) which could be used to generate this program are themselves\nunattainable. Such proofs are presented to formally generate several additional\ntheorems, including (4) The halting problem is unsolvable.\n  Open problems and future research is discussed, including the use of\ntemporary sort files, programs that calculate statistics (such as counts and\nsums), the synthesis of programs to solve other well-known problems from Number\nTheory, Logic, DataBase retrieval and Computability Theory, application to\nProgramming Language Semantics, and the formalization of incompleteness results\nfrom Logic and the semantic paradoxes."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0003071v1", 
    "other_authors": [
        "Charlie Volkstorf"
    ], 
    "lead_author": "Charlie Volkstorf", 
    "arxiv-id": "cs/0003071v1", 
    "title": "Axiomatic Synthesis of Computer Programs and Computability Theorems", 
    "publish": "2000-03-22T00:01:09Z", 
    "summary": "We introduce a set of eight universal Rules of Inference by which computer\nprograms with known properties (axioms) are transformed into new programs with\nknown properties (theorems). Axioms are presented to formalize a segment of\nNumber Theory, DataBase retrieval and Computability Theory. The resulting\nProgram Calculus is used to generate programs to (1) Determine if one number is\na factor of another. (2) List all employees who earn more than their manager.\n(3) List the set of programs that halt no on themselves, thus proving that it\nis recursively enumerable. The well-known fact that the set of programs that do\nnot halt yes on themselves is not recursively enumerable is formalized as a\nprogram requirement that has no solution, an Incompleteness Axiom. Thus, any\naxioms (programs) which could be used to generate this program are themselves\nunattainable. Such proofs are presented to formally generate several additional\ntheorems, including (4) The halting problem is unsolvable.\n  Open problems and future research is discussed, including the use of\ntemporary sort files, programs that calculate statistics (such as counts and\nsums), the synthesis of programs to solve other well-known problems from Number\nTheory, Logic, DataBase retrieval and Computability Theory, application to\nProgramming Language Semantics, and the formalization of incompleteness results\nfrom Logic and the semantic paradoxes."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0006010v1", 
    "other_authors": [
        "Andrea Asperti", 
        "Luca Roversi"
    ], 
    "lead_author": "Andrea Asperti", 
    "arxiv-id": "cs/0006010v1", 
    "title": "Light Affine Logic (Proof Nets, Programming Notation, P-Time Correctness   and Completeness)", 
    "publish": "2000-06-05T12:06:50Z", 
    "summary": "This paper is a structured introduction to Light Affine Logic, and to its\nintuitionistic fragment. Light Affine Logic has a polynomially costing cut\nelimination (P-Time correctness), and encodes all P-Time Turing machines\n(P-Time completeness). P-Time correctness is proved by introducing the Proof\nnets for Intuitionistic Light Affine Logic. P-Time completeness is demonstrated\nin full details thanks to a very compact program notation. On one side, the\nproof of P-Time correctness describes how the complexity of cut elimination is\ncontrolled, thanks to a suitable cut elimination strategy that exploits\nstructural properties of the Proof nets. This allows to have a good catch on\nthe meaning of the ``paragraph'' modality, which is a peculiarity of light\nlogics. On the other side, the proof of P-Time completeness, together with a\nlot of programming examples, gives a flavor of the non trivial task of\nprogramming with resource limitations, using Intuitionistic Light Affine Logic\nderivations as programs."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0006010v1", 
    "other_authors": [
        "Andrea Asperti", 
        "Luca Roversi"
    ], 
    "lead_author": "Andrea Asperti", 
    "arxiv-id": "cs/0006010v1", 
    "title": "Light Affine Logic (Proof Nets, Programming Notation, P-Time Correctness   and Completeness)", 
    "publish": "2000-06-05T12:06:50Z", 
    "summary": "This paper is a structured introduction to Light Affine Logic, and to its\nintuitionistic fragment. Light Affine Logic has a polynomially costing cut\nelimination (P-Time correctness), and encodes all P-Time Turing machines\n(P-Time completeness). P-Time correctness is proved by introducing the Proof\nnets for Intuitionistic Light Affine Logic. P-Time completeness is demonstrated\nin full details thanks to a very compact program notation. On one side, the\nproof of P-Time correctness describes how the complexity of cut elimination is\ncontrolled, thanks to a suitable cut elimination strategy that exploits\nstructural properties of the Proof nets. This allows to have a good catch on\nthe meaning of the ``paragraph'' modality, which is a peculiarity of light\nlogics. On the other side, the proof of P-Time completeness, together with a\nlot of programming examples, gives a flavor of the non trivial task of\nprogramming with resource limitations, using Intuitionistic Light Affine Logic\nderivations as programs."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0006010v1", 
    "other_authors": [
        "Andrea Asperti", 
        "Luca Roversi"
    ], 
    "lead_author": "Andrea Asperti", 
    "arxiv-id": "cs/0006010v1", 
    "title": "Light Affine Logic (Proof Nets, Programming Notation, P-Time Correctness   and Completeness)", 
    "publish": "2000-06-05T12:06:50Z", 
    "summary": "This paper is a structured introduction to Light Affine Logic, and to its\nintuitionistic fragment. Light Affine Logic has a polynomially costing cut\nelimination (P-Time correctness), and encodes all P-Time Turing machines\n(P-Time completeness). P-Time correctness is proved by introducing the Proof\nnets for Intuitionistic Light Affine Logic. P-Time completeness is demonstrated\nin full details thanks to a very compact program notation. On one side, the\nproof of P-Time correctness describes how the complexity of cut elimination is\ncontrolled, thanks to a suitable cut elimination strategy that exploits\nstructural properties of the Proof nets. This allows to have a good catch on\nthe meaning of the ``paragraph'' modality, which is a peculiarity of light\nlogics. On the other side, the proof of P-Time completeness, together with a\nlot of programming examples, gives a flavor of the non trivial task of\nprogramming with resource limitations, using Intuitionistic Light Affine Logic\nderivations as programs."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0006010v1", 
    "other_authors": [
        "Andrea Asperti", 
        "Luca Roversi"
    ], 
    "lead_author": "Andrea Asperti", 
    "arxiv-id": "cs/0006010v1", 
    "title": "Light Affine Logic (Proof Nets, Programming Notation, P-Time Correctness   and Completeness)", 
    "publish": "2000-06-05T12:06:50Z", 
    "summary": "This paper is a structured introduction to Light Affine Logic, and to its\nintuitionistic fragment. Light Affine Logic has a polynomially costing cut\nelimination (P-Time correctness), and encodes all P-Time Turing machines\n(P-Time completeness). P-Time correctness is proved by introducing the Proof\nnets for Intuitionistic Light Affine Logic. P-Time completeness is demonstrated\nin full details thanks to a very compact program notation. On one side, the\nproof of P-Time correctness describes how the complexity of cut elimination is\ncontrolled, thanks to a suitable cut elimination strategy that exploits\nstructural properties of the Proof nets. This allows to have a good catch on\nthe meaning of the ``paragraph'' modality, which is a peculiarity of light\nlogics. On the other side, the proof of P-Time completeness, together with a\nlot of programming examples, gives a flavor of the non trivial task of\nprogramming with resource limitations, using Intuitionistic Light Affine Logic\nderivations as programs."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0006010v1", 
    "other_authors": [
        "Andrea Asperti", 
        "Luca Roversi"
    ], 
    "lead_author": "Andrea Asperti", 
    "arxiv-id": "cs/0006010v1", 
    "title": "Light Affine Logic (Proof Nets, Programming Notation, P-Time Correctness   and Completeness)", 
    "publish": "2000-06-05T12:06:50Z", 
    "summary": "This paper is a structured introduction to Light Affine Logic, and to its\nintuitionistic fragment. Light Affine Logic has a polynomially costing cut\nelimination (P-Time correctness), and encodes all P-Time Turing machines\n(P-Time completeness). P-Time correctness is proved by introducing the Proof\nnets for Intuitionistic Light Affine Logic. P-Time completeness is demonstrated\nin full details thanks to a very compact program notation. On one side, the\nproof of P-Time correctness describes how the complexity of cut elimination is\ncontrolled, thanks to a suitable cut elimination strategy that exploits\nstructural properties of the Proof nets. This allows to have a good catch on\nthe meaning of the ``paragraph'' modality, which is a peculiarity of light\nlogics. On the other side, the proof of P-Time completeness, together with a\nlot of programming examples, gives a flavor of the non trivial task of\nprogramming with resource limitations, using Intuitionistic Light Affine Logic\nderivations as programs."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0006010v1", 
    "other_authors": [
        "Andrea Asperti", 
        "Luca Roversi"
    ], 
    "lead_author": "Andrea Asperti", 
    "arxiv-id": "cs/0006010v1", 
    "title": "Light Affine Logic (Proof Nets, Programming Notation, P-Time Correctness   and Completeness)", 
    "publish": "2000-06-05T12:06:50Z", 
    "summary": "This paper is a structured introduction to Light Affine Logic, and to its\nintuitionistic fragment. Light Affine Logic has a polynomially costing cut\nelimination (P-Time correctness), and encodes all P-Time Turing machines\n(P-Time completeness). P-Time correctness is proved by introducing the Proof\nnets for Intuitionistic Light Affine Logic. P-Time completeness is demonstrated\nin full details thanks to a very compact program notation. On one side, the\nproof of P-Time correctness describes how the complexity of cut elimination is\ncontrolled, thanks to a suitable cut elimination strategy that exploits\nstructural properties of the Proof nets. This allows to have a good catch on\nthe meaning of the ``paragraph'' modality, which is a peculiarity of light\nlogics. On the other side, the proof of P-Time completeness, together with a\nlot of programming examples, gives a flavor of the non trivial task of\nprogramming with resource limitations, using Intuitionistic Light Affine Logic\nderivations as programs."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0006010v1", 
    "other_authors": [
        "Andrea Asperti", 
        "Luca Roversi"
    ], 
    "lead_author": "Andrea Asperti", 
    "arxiv-id": "cs/0006010v1", 
    "title": "Light Affine Logic (Proof Nets, Programming Notation, P-Time Correctness   and Completeness)", 
    "publish": "2000-06-05T12:06:50Z", 
    "summary": "This paper is a structured introduction to Light Affine Logic, and to its\nintuitionistic fragment. Light Affine Logic has a polynomially costing cut\nelimination (P-Time correctness), and encodes all P-Time Turing machines\n(P-Time completeness). P-Time correctness is proved by introducing the Proof\nnets for Intuitionistic Light Affine Logic. P-Time completeness is demonstrated\nin full details thanks to a very compact program notation. On one side, the\nproof of P-Time correctness describes how the complexity of cut elimination is\ncontrolled, thanks to a suitable cut elimination strategy that exploits\nstructural properties of the Proof nets. This allows to have a good catch on\nthe meaning of the ``paragraph'' modality, which is a peculiarity of light\nlogics. On the other side, the proof of P-Time completeness, together with a\nlot of programming examples, gives a flavor of the non trivial task of\nprogramming with resource limitations, using Intuitionistic Light Affine Logic\nderivations as programs."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0006010v1", 
    "other_authors": [
        "Andrea Asperti", 
        "Luca Roversi"
    ], 
    "lead_author": "Andrea Asperti", 
    "arxiv-id": "cs/0006010v1", 
    "title": "Light Affine Logic (Proof Nets, Programming Notation, P-Time Correctness   and Completeness)", 
    "publish": "2000-06-05T12:06:50Z", 
    "summary": "This paper is a structured introduction to Light Affine Logic, and to its\nintuitionistic fragment. Light Affine Logic has a polynomially costing cut\nelimination (P-Time correctness), and encodes all P-Time Turing machines\n(P-Time completeness). P-Time correctness is proved by introducing the Proof\nnets for Intuitionistic Light Affine Logic. P-Time completeness is demonstrated\nin full details thanks to a very compact program notation. On one side, the\nproof of P-Time correctness describes how the complexity of cut elimination is\ncontrolled, thanks to a suitable cut elimination strategy that exploits\nstructural properties of the Proof nets. This allows to have a good catch on\nthe meaning of the ``paragraph'' modality, which is a peculiarity of light\nlogics. On the other side, the proof of P-Time completeness, together with a\nlot of programming examples, gives a flavor of the non trivial task of\nprogramming with resource limitations, using Intuitionistic Light Affine Logic\nderivations as programs."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0006010v1", 
    "other_authors": [
        "Andrea Asperti", 
        "Luca Roversi"
    ], 
    "lead_author": "Luca Roversi", 
    "arxiv-id": "cs/0006010v1", 
    "title": "Light Affine Logic (Proof Nets, Programming Notation, P-Time Correctness   and Completeness)", 
    "publish": "2000-06-05T12:06:50Z", 
    "summary": "This paper is a structured introduction to Light Affine Logic, and to its\nintuitionistic fragment. Light Affine Logic has a polynomially costing cut\nelimination (P-Time correctness), and encodes all P-Time Turing machines\n(P-Time completeness). P-Time correctness is proved by introducing the Proof\nnets for Intuitionistic Light Affine Logic. P-Time completeness is demonstrated\nin full details thanks to a very compact program notation. On one side, the\nproof of P-Time correctness describes how the complexity of cut elimination is\ncontrolled, thanks to a suitable cut elimination strategy that exploits\nstructural properties of the Proof nets. This allows to have a good catch on\nthe meaning of the ``paragraph'' modality, which is a peculiarity of light\nlogics. On the other side, the proof of P-Time completeness, together with a\nlot of programming examples, gives a flavor of the non trivial task of\nprogramming with resource limitations, using Intuitionistic Light Affine Logic\nderivations as programs."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0006010v1", 
    "other_authors": [
        "Andrea Asperti", 
        "Luca Roversi"
    ], 
    "lead_author": "Luca Roversi", 
    "arxiv-id": "cs/0006010v1", 
    "title": "Light Affine Logic (Proof Nets, Programming Notation, P-Time Correctness   and Completeness)", 
    "publish": "2000-06-05T12:06:50Z", 
    "summary": "This paper is a structured introduction to Light Affine Logic, and to its\nintuitionistic fragment. Light Affine Logic has a polynomially costing cut\nelimination (P-Time correctness), and encodes all P-Time Turing machines\n(P-Time completeness). P-Time correctness is proved by introducing the Proof\nnets for Intuitionistic Light Affine Logic. P-Time completeness is demonstrated\nin full details thanks to a very compact program notation. On one side, the\nproof of P-Time correctness describes how the complexity of cut elimination is\ncontrolled, thanks to a suitable cut elimination strategy that exploits\nstructural properties of the Proof nets. This allows to have a good catch on\nthe meaning of the ``paragraph'' modality, which is a peculiarity of light\nlogics. On the other side, the proof of P-Time completeness, together with a\nlot of programming examples, gives a flavor of the non trivial task of\nprogramming with resource limitations, using Intuitionistic Light Affine Logic\nderivations as programs."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0006010v1", 
    "other_authors": [
        "Andrea Asperti", 
        "Luca Roversi"
    ], 
    "lead_author": "Luca Roversi", 
    "arxiv-id": "cs/0006010v1", 
    "title": "Light Affine Logic (Proof Nets, Programming Notation, P-Time Correctness   and Completeness)", 
    "publish": "2000-06-05T12:06:50Z", 
    "summary": "This paper is a structured introduction to Light Affine Logic, and to its\nintuitionistic fragment. Light Affine Logic has a polynomially costing cut\nelimination (P-Time correctness), and encodes all P-Time Turing machines\n(P-Time completeness). P-Time correctness is proved by introducing the Proof\nnets for Intuitionistic Light Affine Logic. P-Time completeness is demonstrated\nin full details thanks to a very compact program notation. On one side, the\nproof of P-Time correctness describes how the complexity of cut elimination is\ncontrolled, thanks to a suitable cut elimination strategy that exploits\nstructural properties of the Proof nets. This allows to have a good catch on\nthe meaning of the ``paragraph'' modality, which is a peculiarity of light\nlogics. On the other side, the proof of P-Time completeness, together with a\nlot of programming examples, gives a flavor of the non trivial task of\nprogramming with resource limitations, using Intuitionistic Light Affine Logic\nderivations as programs."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0006010v1", 
    "other_authors": [
        "Andrea Asperti", 
        "Luca Roversi"
    ], 
    "lead_author": "Luca Roversi", 
    "arxiv-id": "cs/0006010v1", 
    "title": "Light Affine Logic (Proof Nets, Programming Notation, P-Time Correctness   and Completeness)", 
    "publish": "2000-06-05T12:06:50Z", 
    "summary": "This paper is a structured introduction to Light Affine Logic, and to its\nintuitionistic fragment. Light Affine Logic has a polynomially costing cut\nelimination (P-Time correctness), and encodes all P-Time Turing machines\n(P-Time completeness). P-Time correctness is proved by introducing the Proof\nnets for Intuitionistic Light Affine Logic. P-Time completeness is demonstrated\nin full details thanks to a very compact program notation. On one side, the\nproof of P-Time correctness describes how the complexity of cut elimination is\ncontrolled, thanks to a suitable cut elimination strategy that exploits\nstructural properties of the Proof nets. This allows to have a good catch on\nthe meaning of the ``paragraph'' modality, which is a peculiarity of light\nlogics. On the other side, the proof of P-Time completeness, together with a\nlot of programming examples, gives a flavor of the non trivial task of\nprogramming with resource limitations, using Intuitionistic Light Affine Logic\nderivations as programs."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0006010v1", 
    "other_authors": [
        "Andrea Asperti", 
        "Luca Roversi"
    ], 
    "lead_author": "Luca Roversi", 
    "arxiv-id": "cs/0006010v1", 
    "title": "Light Affine Logic (Proof Nets, Programming Notation, P-Time Correctness   and Completeness)", 
    "publish": "2000-06-05T12:06:50Z", 
    "summary": "This paper is a structured introduction to Light Affine Logic, and to its\nintuitionistic fragment. Light Affine Logic has a polynomially costing cut\nelimination (P-Time correctness), and encodes all P-Time Turing machines\n(P-Time completeness). P-Time correctness is proved by introducing the Proof\nnets for Intuitionistic Light Affine Logic. P-Time completeness is demonstrated\nin full details thanks to a very compact program notation. On one side, the\nproof of P-Time correctness describes how the complexity of cut elimination is\ncontrolled, thanks to a suitable cut elimination strategy that exploits\nstructural properties of the Proof nets. This allows to have a good catch on\nthe meaning of the ``paragraph'' modality, which is a peculiarity of light\nlogics. On the other side, the proof of P-Time completeness, together with a\nlot of programming examples, gives a flavor of the non trivial task of\nprogramming with resource limitations, using Intuitionistic Light Affine Logic\nderivations as programs."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0006010v1", 
    "other_authors": [
        "Andrea Asperti", 
        "Luca Roversi"
    ], 
    "lead_author": "Luca Roversi", 
    "arxiv-id": "cs/0006010v1", 
    "title": "Light Affine Logic (Proof Nets, Programming Notation, P-Time Correctness   and Completeness)", 
    "publish": "2000-06-05T12:06:50Z", 
    "summary": "This paper is a structured introduction to Light Affine Logic, and to its\nintuitionistic fragment. Light Affine Logic has a polynomially costing cut\nelimination (P-Time correctness), and encodes all P-Time Turing machines\n(P-Time completeness). P-Time correctness is proved by introducing the Proof\nnets for Intuitionistic Light Affine Logic. P-Time completeness is demonstrated\nin full details thanks to a very compact program notation. On one side, the\nproof of P-Time correctness describes how the complexity of cut elimination is\ncontrolled, thanks to a suitable cut elimination strategy that exploits\nstructural properties of the Proof nets. This allows to have a good catch on\nthe meaning of the ``paragraph'' modality, which is a peculiarity of light\nlogics. On the other side, the proof of P-Time completeness, together with a\nlot of programming examples, gives a flavor of the non trivial task of\nprogramming with resource limitations, using Intuitionistic Light Affine Logic\nderivations as programs."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0006010v1", 
    "other_authors": [
        "Andrea Asperti", 
        "Luca Roversi"
    ], 
    "lead_author": "Luca Roversi", 
    "arxiv-id": "cs/0006010v1", 
    "title": "Light Affine Logic (Proof Nets, Programming Notation, P-Time Correctness   and Completeness)", 
    "publish": "2000-06-05T12:06:50Z", 
    "summary": "This paper is a structured introduction to Light Affine Logic, and to its\nintuitionistic fragment. Light Affine Logic has a polynomially costing cut\nelimination (P-Time correctness), and encodes all P-Time Turing machines\n(P-Time completeness). P-Time correctness is proved by introducing the Proof\nnets for Intuitionistic Light Affine Logic. P-Time completeness is demonstrated\nin full details thanks to a very compact program notation. On one side, the\nproof of P-Time correctness describes how the complexity of cut elimination is\ncontrolled, thanks to a suitable cut elimination strategy that exploits\nstructural properties of the Proof nets. This allows to have a good catch on\nthe meaning of the ``paragraph'' modality, which is a peculiarity of light\nlogics. On the other side, the proof of P-Time completeness, together with a\nlot of programming examples, gives a flavor of the non trivial task of\nprogramming with resource limitations, using Intuitionistic Light Affine Logic\nderivations as programs."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0006010v1", 
    "other_authors": [
        "Andrea Asperti", 
        "Luca Roversi"
    ], 
    "lead_author": "Luca Roversi", 
    "arxiv-id": "cs/0006010v1", 
    "title": "Light Affine Logic (Proof Nets, Programming Notation, P-Time Correctness   and Completeness)", 
    "publish": "2000-06-05T12:06:50Z", 
    "summary": "This paper is a structured introduction to Light Affine Logic, and to its\nintuitionistic fragment. Light Affine Logic has a polynomially costing cut\nelimination (P-Time correctness), and encodes all P-Time Turing machines\n(P-Time completeness). P-Time correctness is proved by introducing the Proof\nnets for Intuitionistic Light Affine Logic. P-Time completeness is demonstrated\nin full details thanks to a very compact program notation. On one side, the\nproof of P-Time correctness describes how the complexity of cut elimination is\ncontrolled, thanks to a suitable cut elimination strategy that exploits\nstructural properties of the Proof nets. This allows to have a good catch on\nthe meaning of the ``paragraph'' modality, which is a peculiarity of light\nlogics. On the other side, the proof of P-Time completeness, together with a\nlot of programming examples, gives a flavor of the non trivial task of\nprogramming with resource limitations, using Intuitionistic Light Affine Logic\nderivations as programs."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0006010v1", 
    "other_authors": [
        "Andrea Asperti", 
        "Luca Roversi"
    ], 
    "lead_author": "Luca Roversi", 
    "arxiv-id": "cs/0006010v1", 
    "title": "Light Affine Logic (Proof Nets, Programming Notation, P-Time Correctness   and Completeness)", 
    "publish": "2000-06-05T12:06:50Z", 
    "summary": "This paper is a structured introduction to Light Affine Logic, and to its\nintuitionistic fragment. Light Affine Logic has a polynomially costing cut\nelimination (P-Time correctness), and encodes all P-Time Turing machines\n(P-Time completeness). P-Time correctness is proved by introducing the Proof\nnets for Intuitionistic Light Affine Logic. P-Time completeness is demonstrated\nin full details thanks to a very compact program notation. On one side, the\nproof of P-Time correctness describes how the complexity of cut elimination is\ncontrolled, thanks to a suitable cut elimination strategy that exploits\nstructural properties of the Proof nets. This allows to have a good catch on\nthe meaning of the ``paragraph'' modality, which is a peculiarity of light\nlogics. On the other side, the proof of P-Time completeness, together with a\nlot of programming examples, gives a flavor of the non trivial task of\nprogramming with resource limitations, using Intuitionistic Light Affine Logic\nderivations as programs."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0007037v1", 
    "other_authors": [
        "Konstantinos Georgatos"
    ], 
    "lead_author": "Konstantinos Georgatos", 
    "arxiv-id": "cs/0007037v1", 
    "title": "Knowledge Theoretic Properties of Topological Spaces", 
    "publish": "2000-07-26T18:36:37Z", 
    "summary": "We study the topological models of a logic of knowledge for topological\nreasoning, introduced by Larry Moss and Rohit Parikh. Among our results is a\nsolution of a conjecture by the formentioned authors, finite satisfiability\nproperty and decidability for the theory of topological models."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0007037v1", 
    "other_authors": [
        "Konstantinos Georgatos"
    ], 
    "lead_author": "Konstantinos Georgatos", 
    "arxiv-id": "cs/0007037v1", 
    "title": "Knowledge Theoretic Properties of Topological Spaces", 
    "publish": "2000-07-26T18:36:37Z", 
    "summary": "We study the topological models of a logic of knowledge for topological\nreasoning, introduced by Larry Moss and Rohit Parikh. Among our results is a\nsolution of a conjecture by the formentioned authors, finite satisfiability\nproperty and decidability for the theory of topological models."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0007037v1", 
    "other_authors": [
        "Konstantinos Georgatos"
    ], 
    "lead_author": "Konstantinos Georgatos", 
    "arxiv-id": "cs/0007037v1", 
    "title": "Knowledge Theoretic Properties of Topological Spaces", 
    "publish": "2000-07-26T18:36:37Z", 
    "summary": "We study the topological models of a logic of knowledge for topological\nreasoning, introduced by Larry Moss and Rohit Parikh. Among our results is a\nsolution of a conjecture by the formentioned authors, finite satisfiability\nproperty and decidability for the theory of topological models."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0007037v1", 
    "other_authors": [
        "Konstantinos Georgatos"
    ], 
    "lead_author": "Konstantinos Georgatos", 
    "arxiv-id": "cs/0007037v1", 
    "title": "Knowledge Theoretic Properties of Topological Spaces", 
    "publish": "2000-07-26T18:36:37Z", 
    "summary": "We study the topological models of a logic of knowledge for topological\nreasoning, introduced by Larry Moss and Rohit Parikh. Among our results is a\nsolution of a conjecture by the formentioned authors, finite satisfiability\nproperty and decidability for the theory of topological models."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0007037v1", 
    "other_authors": [
        "Konstantinos Georgatos"
    ], 
    "lead_author": "Konstantinos Georgatos", 
    "arxiv-id": "cs/0007037v1", 
    "title": "Knowledge Theoretic Properties of Topological Spaces", 
    "publish": "2000-07-26T18:36:37Z", 
    "summary": "We study the topological models of a logic of knowledge for topological\nreasoning, introduced by Larry Moss and Rohit Parikh. Among our results is a\nsolution of a conjecture by the formentioned authors, finite satisfiability\nproperty and decidability for the theory of topological models."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0007037v1", 
    "other_authors": [
        "Konstantinos Georgatos"
    ], 
    "lead_author": "Konstantinos Georgatos", 
    "arxiv-id": "cs/0007037v1", 
    "title": "Knowledge Theoretic Properties of Topological Spaces", 
    "publish": "2000-07-26T18:36:37Z", 
    "summary": "We study the topological models of a logic of knowledge for topological\nreasoning, introduced by Larry Moss and Rohit Parikh. Among our results is a\nsolution of a conjecture by the formentioned authors, finite satisfiability\nproperty and decidability for the theory of topological models."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0007037v1", 
    "other_authors": [
        "Konstantinos Georgatos"
    ], 
    "lead_author": "Konstantinos Georgatos", 
    "arxiv-id": "cs/0007037v1", 
    "title": "Knowledge Theoretic Properties of Topological Spaces", 
    "publish": "2000-07-26T18:36:37Z", 
    "summary": "We study the topological models of a logic of knowledge for topological\nreasoning, introduced by Larry Moss and Rohit Parikh. Among our results is a\nsolution of a conjecture by the formentioned authors, finite satisfiability\nproperty and decidability for the theory of topological models."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0007037v1", 
    "other_authors": [
        "Konstantinos Georgatos"
    ], 
    "lead_author": "Konstantinos Georgatos", 
    "arxiv-id": "cs/0007037v1", 
    "title": "Knowledge Theoretic Properties of Topological Spaces", 
    "publish": "2000-07-26T18:36:37Z", 
    "summary": "We study the topological models of a logic of knowledge for topological\nreasoning, introduced by Larry Moss and Rohit Parikh. Among our results is a\nsolution of a conjecture by the formentioned authors, finite satisfiability\nproperty and decidability for the theory of topological models."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0010029v2", 
    "other_authors": [
        "Jan-Georg Smaus", 
        "Francois Fages", 
        "Pierre Deransart"
    ], 
    "lead_author": "Jan-Georg Smaus", 
    "arxiv-id": "cs/0010029v2", 
    "title": "Using Modes to Ensure Subject Reduction for Typed Logic Programs with   Subtyping", 
    "publish": "2000-10-20T08:04:15Z", 
    "summary": "We consider a general prescriptive type system with parametric polymorphism\nand subtyping for logic programs. The property of subject reduction expresses\nthe consistency of the type system w.r.t. the execution model: if a program is\n\"well-typed\", then all derivations starting in a \"well-typed\" goal are again\n\"well-typed\". It is well-established that without subtyping, this property is\nreadily obtained for logic programs w.r.t. their standard (untyped) execution\nmodel. Here we give syntactic conditions that ensure subject reduction also in\nthe presence of general subtyping relations between type constructors. The idea\nis to consider logic programs with a fixed dataflow, given by modes."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0010029v2", 
    "other_authors": [
        "Jan-Georg Smaus", 
        "Francois Fages", 
        "Pierre Deransart"
    ], 
    "lead_author": "Jan-Georg Smaus", 
    "arxiv-id": "cs/0010029v2", 
    "title": "Using Modes to Ensure Subject Reduction for Typed Logic Programs with   Subtyping", 
    "publish": "2000-10-20T08:04:15Z", 
    "summary": "We consider a general prescriptive type system with parametric polymorphism\nand subtyping for logic programs. The property of subject reduction expresses\nthe consistency of the type system w.r.t. the execution model: if a program is\n\"well-typed\", then all derivations starting in a \"well-typed\" goal are again\n\"well-typed\". It is well-established that without subtyping, this property is\nreadily obtained for logic programs w.r.t. their standard (untyped) execution\nmodel. Here we give syntactic conditions that ensure subject reduction also in\nthe presence of general subtyping relations between type constructors. The idea\nis to consider logic programs with a fixed dataflow, given by modes."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0010029v2", 
    "other_authors": [
        "Jan-Georg Smaus", 
        "Francois Fages", 
        "Pierre Deransart"
    ], 
    "lead_author": "Jan-Georg Smaus", 
    "arxiv-id": "cs/0010029v2", 
    "title": "Using Modes to Ensure Subject Reduction for Typed Logic Programs with   Subtyping", 
    "publish": "2000-10-20T08:04:15Z", 
    "summary": "We consider a general prescriptive type system with parametric polymorphism\nand subtyping for logic programs. The property of subject reduction expresses\nthe consistency of the type system w.r.t. the execution model: if a program is\n\"well-typed\", then all derivations starting in a \"well-typed\" goal are again\n\"well-typed\". It is well-established that without subtyping, this property is\nreadily obtained for logic programs w.r.t. their standard (untyped) execution\nmodel. Here we give syntactic conditions that ensure subject reduction also in\nthe presence of general subtyping relations between type constructors. The idea\nis to consider logic programs with a fixed dataflow, given by modes."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0010029v2", 
    "other_authors": [
        "Jan-Georg Smaus", 
        "Francois Fages", 
        "Pierre Deransart"
    ], 
    "lead_author": "Jan-Georg Smaus", 
    "arxiv-id": "cs/0010029v2", 
    "title": "Using Modes to Ensure Subject Reduction for Typed Logic Programs with   Subtyping", 
    "publish": "2000-10-20T08:04:15Z", 
    "summary": "We consider a general prescriptive type system with parametric polymorphism\nand subtyping for logic programs. The property of subject reduction expresses\nthe consistency of the type system w.r.t. the execution model: if a program is\n\"well-typed\", then all derivations starting in a \"well-typed\" goal are again\n\"well-typed\". It is well-established that without subtyping, this property is\nreadily obtained for logic programs w.r.t. their standard (untyped) execution\nmodel. Here we give syntactic conditions that ensure subject reduction also in\nthe presence of general subtyping relations between type constructors. The idea\nis to consider logic programs with a fixed dataflow, given by modes."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0010029v2", 
    "other_authors": [
        "Jan-Georg Smaus", 
        "Francois Fages", 
        "Pierre Deransart"
    ], 
    "lead_author": "Jan-Georg Smaus", 
    "arxiv-id": "cs/0010029v2", 
    "title": "Using Modes to Ensure Subject Reduction for Typed Logic Programs with   Subtyping", 
    "publish": "2000-10-20T08:04:15Z", 
    "summary": "We consider a general prescriptive type system with parametric polymorphism\nand subtyping for logic programs. The property of subject reduction expresses\nthe consistency of the type system w.r.t. the execution model: if a program is\n\"well-typed\", then all derivations starting in a \"well-typed\" goal are again\n\"well-typed\". It is well-established that without subtyping, this property is\nreadily obtained for logic programs w.r.t. their standard (untyped) execution\nmodel. Here we give syntactic conditions that ensure subject reduction also in\nthe presence of general subtyping relations between type constructors. The idea\nis to consider logic programs with a fixed dataflow, given by modes."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0010029v2", 
    "other_authors": [
        "Jan-Georg Smaus", 
        "Francois Fages", 
        "Pierre Deransart"
    ], 
    "lead_author": "Jan-Georg Smaus", 
    "arxiv-id": "cs/0010029v2", 
    "title": "Using Modes to Ensure Subject Reduction for Typed Logic Programs with   Subtyping", 
    "publish": "2000-10-20T08:04:15Z", 
    "summary": "We consider a general prescriptive type system with parametric polymorphism\nand subtyping for logic programs. The property of subject reduction expresses\nthe consistency of the type system w.r.t. the execution model: if a program is\n\"well-typed\", then all derivations starting in a \"well-typed\" goal are again\n\"well-typed\". It is well-established that without subtyping, this property is\nreadily obtained for logic programs w.r.t. their standard (untyped) execution\nmodel. Here we give syntactic conditions that ensure subject reduction also in\nthe presence of general subtyping relations between type constructors. The idea\nis to consider logic programs with a fixed dataflow, given by modes."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0010029v2", 
    "other_authors": [
        "Jan-Georg Smaus", 
        "Francois Fages", 
        "Pierre Deransart"
    ], 
    "lead_author": "Jan-Georg Smaus", 
    "arxiv-id": "cs/0010029v2", 
    "title": "Using Modes to Ensure Subject Reduction for Typed Logic Programs with   Subtyping", 
    "publish": "2000-10-20T08:04:15Z", 
    "summary": "We consider a general prescriptive type system with parametric polymorphism\nand subtyping for logic programs. The property of subject reduction expresses\nthe consistency of the type system w.r.t. the execution model: if a program is\n\"well-typed\", then all derivations starting in a \"well-typed\" goal are again\n\"well-typed\". It is well-established that without subtyping, this property is\nreadily obtained for logic programs w.r.t. their standard (untyped) execution\nmodel. Here we give syntactic conditions that ensure subject reduction also in\nthe presence of general subtyping relations between type constructors. The idea\nis to consider logic programs with a fixed dataflow, given by modes."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0010029v2", 
    "other_authors": [
        "Jan-Georg Smaus", 
        "Francois Fages", 
        "Pierre Deransart"
    ], 
    "lead_author": "Jan-Georg Smaus", 
    "arxiv-id": "cs/0010029v2", 
    "title": "Using Modes to Ensure Subject Reduction for Typed Logic Programs with   Subtyping", 
    "publish": "2000-10-20T08:04:15Z", 
    "summary": "We consider a general prescriptive type system with parametric polymorphism\nand subtyping for logic programs. The property of subject reduction expresses\nthe consistency of the type system w.r.t. the execution model: if a program is\n\"well-typed\", then all derivations starting in a \"well-typed\" goal are again\n\"well-typed\". It is well-established that without subtyping, this property is\nreadily obtained for logic programs w.r.t. their standard (untyped) execution\nmodel. Here we give syntactic conditions that ensure subject reduction also in\nthe presence of general subtyping relations between type constructors. The idea\nis to consider logic programs with a fixed dataflow, given by modes."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0010029v2", 
    "other_authors": [
        "Jan-Georg Smaus", 
        "Francois Fages", 
        "Pierre Deransart"
    ], 
    "lead_author": "Francois Fages", 
    "arxiv-id": "cs/0010029v2", 
    "title": "Using Modes to Ensure Subject Reduction for Typed Logic Programs with   Subtyping", 
    "publish": "2000-10-20T08:04:15Z", 
    "summary": "We consider a general prescriptive type system with parametric polymorphism\nand subtyping for logic programs. The property of subject reduction expresses\nthe consistency of the type system w.r.t. the execution model: if a program is\n\"well-typed\", then all derivations starting in a \"well-typed\" goal are again\n\"well-typed\". It is well-established that without subtyping, this property is\nreadily obtained for logic programs w.r.t. their standard (untyped) execution\nmodel. Here we give syntactic conditions that ensure subject reduction also in\nthe presence of general subtyping relations between type constructors. The idea\nis to consider logic programs with a fixed dataflow, given by modes."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0010029v2", 
    "other_authors": [
        "Jan-Georg Smaus", 
        "Francois Fages", 
        "Pierre Deransart"
    ], 
    "lead_author": "Francois Fages", 
    "arxiv-id": "cs/0010029v2", 
    "title": "Using Modes to Ensure Subject Reduction for Typed Logic Programs with   Subtyping", 
    "publish": "2000-10-20T08:04:15Z", 
    "summary": "We consider a general prescriptive type system with parametric polymorphism\nand subtyping for logic programs. The property of subject reduction expresses\nthe consistency of the type system w.r.t. the execution model: if a program is\n\"well-typed\", then all derivations starting in a \"well-typed\" goal are again\n\"well-typed\". It is well-established that without subtyping, this property is\nreadily obtained for logic programs w.r.t. their standard (untyped) execution\nmodel. Here we give syntactic conditions that ensure subject reduction also in\nthe presence of general subtyping relations between type constructors. The idea\nis to consider logic programs with a fixed dataflow, given by modes."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0010029v2", 
    "other_authors": [
        "Jan-Georg Smaus", 
        "Francois Fages", 
        "Pierre Deransart"
    ], 
    "lead_author": "Francois Fages", 
    "arxiv-id": "cs/0010029v2", 
    "title": "Using Modes to Ensure Subject Reduction for Typed Logic Programs with   Subtyping", 
    "publish": "2000-10-20T08:04:15Z", 
    "summary": "We consider a general prescriptive type system with parametric polymorphism\nand subtyping for logic programs. The property of subject reduction expresses\nthe consistency of the type system w.r.t. the execution model: if a program is\n\"well-typed\", then all derivations starting in a \"well-typed\" goal are again\n\"well-typed\". It is well-established that without subtyping, this property is\nreadily obtained for logic programs w.r.t. their standard (untyped) execution\nmodel. Here we give syntactic conditions that ensure subject reduction also in\nthe presence of general subtyping relations between type constructors. The idea\nis to consider logic programs with a fixed dataflow, given by modes."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0010029v2", 
    "other_authors": [
        "Jan-Georg Smaus", 
        "Francois Fages", 
        "Pierre Deransart"
    ], 
    "lead_author": "Francois Fages", 
    "arxiv-id": "cs/0010029v2", 
    "title": "Using Modes to Ensure Subject Reduction for Typed Logic Programs with   Subtyping", 
    "publish": "2000-10-20T08:04:15Z", 
    "summary": "We consider a general prescriptive type system with parametric polymorphism\nand subtyping for logic programs. The property of subject reduction expresses\nthe consistency of the type system w.r.t. the execution model: if a program is\n\"well-typed\", then all derivations starting in a \"well-typed\" goal are again\n\"well-typed\". It is well-established that without subtyping, this property is\nreadily obtained for logic programs w.r.t. their standard (untyped) execution\nmodel. Here we give syntactic conditions that ensure subject reduction also in\nthe presence of general subtyping relations between type constructors. The idea\nis to consider logic programs with a fixed dataflow, given by modes."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0010029v2", 
    "other_authors": [
        "Jan-Georg Smaus", 
        "Francois Fages", 
        "Pierre Deransart"
    ], 
    "lead_author": "Francois Fages", 
    "arxiv-id": "cs/0010029v2", 
    "title": "Using Modes to Ensure Subject Reduction for Typed Logic Programs with   Subtyping", 
    "publish": "2000-10-20T08:04:15Z", 
    "summary": "We consider a general prescriptive type system with parametric polymorphism\nand subtyping for logic programs. The property of subject reduction expresses\nthe consistency of the type system w.r.t. the execution model: if a program is\n\"well-typed\", then all derivations starting in a \"well-typed\" goal are again\n\"well-typed\". It is well-established that without subtyping, this property is\nreadily obtained for logic programs w.r.t. their standard (untyped) execution\nmodel. Here we give syntactic conditions that ensure subject reduction also in\nthe presence of general subtyping relations between type constructors. The idea\nis to consider logic programs with a fixed dataflow, given by modes."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0010029v2", 
    "other_authors": [
        "Jan-Georg Smaus", 
        "Francois Fages", 
        "Pierre Deransart"
    ], 
    "lead_author": "Francois Fages", 
    "arxiv-id": "cs/0010029v2", 
    "title": "Using Modes to Ensure Subject Reduction for Typed Logic Programs with   Subtyping", 
    "publish": "2000-10-20T08:04:15Z", 
    "summary": "We consider a general prescriptive type system with parametric polymorphism\nand subtyping for logic programs. The property of subject reduction expresses\nthe consistency of the type system w.r.t. the execution model: if a program is\n\"well-typed\", then all derivations starting in a \"well-typed\" goal are again\n\"well-typed\". It is well-established that without subtyping, this property is\nreadily obtained for logic programs w.r.t. their standard (untyped) execution\nmodel. Here we give syntactic conditions that ensure subject reduction also in\nthe presence of general subtyping relations between type constructors. The idea\nis to consider logic programs with a fixed dataflow, given by modes."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0010029v2", 
    "other_authors": [
        "Jan-Georg Smaus", 
        "Francois Fages", 
        "Pierre Deransart"
    ], 
    "lead_author": "Francois Fages", 
    "arxiv-id": "cs/0010029v2", 
    "title": "Using Modes to Ensure Subject Reduction for Typed Logic Programs with   Subtyping", 
    "publish": "2000-10-20T08:04:15Z", 
    "summary": "We consider a general prescriptive type system with parametric polymorphism\nand subtyping for logic programs. The property of subject reduction expresses\nthe consistency of the type system w.r.t. the execution model: if a program is\n\"well-typed\", then all derivations starting in a \"well-typed\" goal are again\n\"well-typed\". It is well-established that without subtyping, this property is\nreadily obtained for logic programs w.r.t. their standard (untyped) execution\nmodel. Here we give syntactic conditions that ensure subject reduction also in\nthe presence of general subtyping relations between type constructors. The idea\nis to consider logic programs with a fixed dataflow, given by modes."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0010029v2", 
    "other_authors": [
        "Jan-Georg Smaus", 
        "Francois Fages", 
        "Pierre Deransart"
    ], 
    "lead_author": "Pierre Deransart", 
    "arxiv-id": "cs/0010029v2", 
    "title": "Using Modes to Ensure Subject Reduction for Typed Logic Programs with   Subtyping", 
    "publish": "2000-10-20T08:04:15Z", 
    "summary": "We consider a general prescriptive type system with parametric polymorphism\nand subtyping for logic programs. The property of subject reduction expresses\nthe consistency of the type system w.r.t. the execution model: if a program is\n\"well-typed\", then all derivations starting in a \"well-typed\" goal are again\n\"well-typed\". It is well-established that without subtyping, this property is\nreadily obtained for logic programs w.r.t. their standard (untyped) execution\nmodel. Here we give syntactic conditions that ensure subject reduction also in\nthe presence of general subtyping relations between type constructors. The idea\nis to consider logic programs with a fixed dataflow, given by modes."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0010029v2", 
    "other_authors": [
        "Jan-Georg Smaus", 
        "Francois Fages", 
        "Pierre Deransart"
    ], 
    "lead_author": "Pierre Deransart", 
    "arxiv-id": "cs/0010029v2", 
    "title": "Using Modes to Ensure Subject Reduction for Typed Logic Programs with   Subtyping", 
    "publish": "2000-10-20T08:04:15Z", 
    "summary": "We consider a general prescriptive type system with parametric polymorphism\nand subtyping for logic programs. The property of subject reduction expresses\nthe consistency of the type system w.r.t. the execution model: if a program is\n\"well-typed\", then all derivations starting in a \"well-typed\" goal are again\n\"well-typed\". It is well-established that without subtyping, this property is\nreadily obtained for logic programs w.r.t. their standard (untyped) execution\nmodel. Here we give syntactic conditions that ensure subject reduction also in\nthe presence of general subtyping relations between type constructors. The idea\nis to consider logic programs with a fixed dataflow, given by modes."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0010029v2", 
    "other_authors": [
        "Jan-Georg Smaus", 
        "Francois Fages", 
        "Pierre Deransart"
    ], 
    "lead_author": "Pierre Deransart", 
    "arxiv-id": "cs/0010029v2", 
    "title": "Using Modes to Ensure Subject Reduction for Typed Logic Programs with   Subtyping", 
    "publish": "2000-10-20T08:04:15Z", 
    "summary": "We consider a general prescriptive type system with parametric polymorphism\nand subtyping for logic programs. The property of subject reduction expresses\nthe consistency of the type system w.r.t. the execution model: if a program is\n\"well-typed\", then all derivations starting in a \"well-typed\" goal are again\n\"well-typed\". It is well-established that without subtyping, this property is\nreadily obtained for logic programs w.r.t. their standard (untyped) execution\nmodel. Here we give syntactic conditions that ensure subject reduction also in\nthe presence of general subtyping relations between type constructors. The idea\nis to consider logic programs with a fixed dataflow, given by modes."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0010029v2", 
    "other_authors": [
        "Jan-Georg Smaus", 
        "Francois Fages", 
        "Pierre Deransart"
    ], 
    "lead_author": "Pierre Deransart", 
    "arxiv-id": "cs/0010029v2", 
    "title": "Using Modes to Ensure Subject Reduction for Typed Logic Programs with   Subtyping", 
    "publish": "2000-10-20T08:04:15Z", 
    "summary": "We consider a general prescriptive type system with parametric polymorphism\nand subtyping for logic programs. The property of subject reduction expresses\nthe consistency of the type system w.r.t. the execution model: if a program is\n\"well-typed\", then all derivations starting in a \"well-typed\" goal are again\n\"well-typed\". It is well-established that without subtyping, this property is\nreadily obtained for logic programs w.r.t. their standard (untyped) execution\nmodel. Here we give syntactic conditions that ensure subject reduction also in\nthe presence of general subtyping relations between type constructors. The idea\nis to consider logic programs with a fixed dataflow, given by modes."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0010029v2", 
    "other_authors": [
        "Jan-Georg Smaus", 
        "Francois Fages", 
        "Pierre Deransart"
    ], 
    "lead_author": "Pierre Deransart", 
    "arxiv-id": "cs/0010029v2", 
    "title": "Using Modes to Ensure Subject Reduction for Typed Logic Programs with   Subtyping", 
    "publish": "2000-10-20T08:04:15Z", 
    "summary": "We consider a general prescriptive type system with parametric polymorphism\nand subtyping for logic programs. The property of subject reduction expresses\nthe consistency of the type system w.r.t. the execution model: if a program is\n\"well-typed\", then all derivations starting in a \"well-typed\" goal are again\n\"well-typed\". It is well-established that without subtyping, this property is\nreadily obtained for logic programs w.r.t. their standard (untyped) execution\nmodel. Here we give syntactic conditions that ensure subject reduction also in\nthe presence of general subtyping relations between type constructors. The idea\nis to consider logic programs with a fixed dataflow, given by modes."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0010029v2", 
    "other_authors": [
        "Jan-Georg Smaus", 
        "Francois Fages", 
        "Pierre Deransart"
    ], 
    "lead_author": "Pierre Deransart", 
    "arxiv-id": "cs/0010029v2", 
    "title": "Using Modes to Ensure Subject Reduction for Typed Logic Programs with   Subtyping", 
    "publish": "2000-10-20T08:04:15Z", 
    "summary": "We consider a general prescriptive type system with parametric polymorphism\nand subtyping for logic programs. The property of subject reduction expresses\nthe consistency of the type system w.r.t. the execution model: if a program is\n\"well-typed\", then all derivations starting in a \"well-typed\" goal are again\n\"well-typed\". It is well-established that without subtyping, this property is\nreadily obtained for logic programs w.r.t. their standard (untyped) execution\nmodel. Here we give syntactic conditions that ensure subject reduction also in\nthe presence of general subtyping relations between type constructors. The idea\nis to consider logic programs with a fixed dataflow, given by modes."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0010029v2", 
    "other_authors": [
        "Jan-Georg Smaus", 
        "Francois Fages", 
        "Pierre Deransart"
    ], 
    "lead_author": "Pierre Deransart", 
    "arxiv-id": "cs/0010029v2", 
    "title": "Using Modes to Ensure Subject Reduction for Typed Logic Programs with   Subtyping", 
    "publish": "2000-10-20T08:04:15Z", 
    "summary": "We consider a general prescriptive type system with parametric polymorphism\nand subtyping for logic programs. The property of subject reduction expresses\nthe consistency of the type system w.r.t. the execution model: if a program is\n\"well-typed\", then all derivations starting in a \"well-typed\" goal are again\n\"well-typed\". It is well-established that without subtyping, this property is\nreadily obtained for logic programs w.r.t. their standard (untyped) execution\nmodel. Here we give syntactic conditions that ensure subject reduction also in\nthe presence of general subtyping relations between type constructors. The idea\nis to consider logic programs with a fixed dataflow, given by modes."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0010029v2", 
    "other_authors": [
        "Jan-Georg Smaus", 
        "Francois Fages", 
        "Pierre Deransart"
    ], 
    "lead_author": "Pierre Deransart", 
    "arxiv-id": "cs/0010029v2", 
    "title": "Using Modes to Ensure Subject Reduction for Typed Logic Programs with   Subtyping", 
    "publish": "2000-10-20T08:04:15Z", 
    "summary": "We consider a general prescriptive type system with parametric polymorphism\nand subtyping for logic programs. The property of subject reduction expresses\nthe consistency of the type system w.r.t. the execution model: if a program is\n\"well-typed\", then all derivations starting in a \"well-typed\" goal are again\n\"well-typed\". It is well-established that without subtyping, this property is\nreadily obtained for logic programs w.r.t. their standard (untyped) execution\nmodel. Here we give syntactic conditions that ensure subject reduction also in\nthe presence of general subtyping relations between type constructors. The idea\nis to consider logic programs with a fixed dataflow, given by modes."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0010029v2", 
    "other_authors": [
        "Jan-Georg Smaus", 
        "Francois Fages", 
        "Pierre Deransart"
    ], 
    "lead_author": "Pierre Deransart", 
    "arxiv-id": "cs/0010029v2", 
    "title": "Using Modes to Ensure Subject Reduction for Typed Logic Programs with   Subtyping", 
    "publish": "2000-10-20T08:04:15Z", 
    "summary": "We consider a general prescriptive type system with parametric polymorphism\nand subtyping for logic programs. The property of subject reduction expresses\nthe consistency of the type system w.r.t. the execution model: if a program is\n\"well-typed\", then all derivations starting in a \"well-typed\" goal are again\n\"well-typed\". It is well-established that without subtyping, this property is\nreadily obtained for logic programs w.r.t. their standard (untyped) execution\nmodel. Here we give syntactic conditions that ensure subject reduction also in\nthe presence of general subtyping relations between type constructors. The idea\nis to consider logic programs with a fixed dataflow, given by modes."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0010029v2", 
    "other_authors": [
        "Jan-Georg Smaus", 
        "Francois Fages", 
        "Pierre Deransart"
    ], 
    "lead_author": "Pierre Deransart", 
    "arxiv-id": "cs/0010029v2", 
    "title": "Using Modes to Ensure Subject Reduction for Typed Logic Programs with   Subtyping", 
    "publish": "2000-10-20T08:04:15Z", 
    "summary": "We consider a general prescriptive type system with parametric polymorphism\nand subtyping for logic programs. The property of subject reduction expresses\nthe consistency of the type system w.r.t. the execution model: if a program is\n\"well-typed\", then all derivations starting in a \"well-typed\" goal are again\n\"well-typed\". It is well-established that without subtyping, this property is\nreadily obtained for logic programs w.r.t. their standard (untyped) execution\nmodel. Here we give syntactic conditions that ensure subject reduction also in\nthe presence of general subtyping relations between type constructors. The idea\nis to consider logic programs with a fixed dataflow, given by modes."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0010029v2", 
    "other_authors": [
        "Jan-Georg Smaus", 
        "Francois Fages", 
        "Pierre Deransart"
    ], 
    "lead_author": "Pierre Deransart", 
    "arxiv-id": "cs/0010029v2", 
    "title": "Using Modes to Ensure Subject Reduction for Typed Logic Programs with   Subtyping", 
    "publish": "2000-10-20T08:04:15Z", 
    "summary": "We consider a general prescriptive type system with parametric polymorphism\nand subtyping for logic programs. The property of subject reduction expresses\nthe consistency of the type system w.r.t. the execution model: if a program is\n\"well-typed\", then all derivations starting in a \"well-typed\" goal are again\n\"well-typed\". It is well-established that without subtyping, this property is\nreadily obtained for logic programs w.r.t. their standard (untyped) execution\nmodel. Here we give syntactic conditions that ensure subject reduction also in\nthe presence of general subtyping relations between type constructors. The idea\nis to consider logic programs with a fixed dataflow, given by modes."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0011013v1", 
    "other_authors": [
        "Stefan Brass", 
        "Juergen Dix", 
        "Burkhard Freitag", 
        "Ulrich Zukowski"
    ], 
    "lead_author": "Stefan Brass", 
    "arxiv-id": "cs/0011013v1", 
    "title": "Transformation-Based Bottom-Up Computation of the Well-Founded Model", 
    "publish": "2000-11-08T14:32:48Z", 
    "summary": "We present a framework for expressing bottom-up algorithms to compute the\nwell-founded model of non-disjunctive logic programs. Our method is based on\nthe notion of conditional facts and elementary program transformations studied\nby Brass and Dix for disjunctive programs. However, even if we restrict their\nframework to nondisjunctive programs, their residual program can grow to\nexponential size, whereas for function-free programs our program remainder is\nalways polynomial in the size of the extensional database (EDB).\n  We show that particular orderings of our transformations (we call them\nstrategies) correspond to well-known computational methods like the alternating\nfixpoint approach, the well-founded magic sets method and the magic alternating\nfixpoint procedure. However, due to the confluence of our calculi, we come up\nwith computations of the well-founded model that are provably better than these\nmethods.\n  In contrast to other approaches, our transformation method treats magic set\ntransformed programs correctly, i.e. it always computes a relevant part of the\nwell-founded model of the original program."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0011013v1", 
    "other_authors": [
        "Stefan Brass", 
        "Juergen Dix", 
        "Burkhard Freitag", 
        "Ulrich Zukowski"
    ], 
    "lead_author": "Stefan Brass", 
    "arxiv-id": "cs/0011013v1", 
    "title": "Transformation-Based Bottom-Up Computation of the Well-Founded Model", 
    "publish": "2000-11-08T14:32:48Z", 
    "summary": "We present a framework for expressing bottom-up algorithms to compute the\nwell-founded model of non-disjunctive logic programs. Our method is based on\nthe notion of conditional facts and elementary program transformations studied\nby Brass and Dix for disjunctive programs. However, even if we restrict their\nframework to nondisjunctive programs, their residual program can grow to\nexponential size, whereas for function-free programs our program remainder is\nalways polynomial in the size of the extensional database (EDB).\n  We show that particular orderings of our transformations (we call them\nstrategies) correspond to well-known computational methods like the alternating\nfixpoint approach, the well-founded magic sets method and the magic alternating\nfixpoint procedure. However, due to the confluence of our calculi, we come up\nwith computations of the well-founded model that are provably better than these\nmethods.\n  In contrast to other approaches, our transformation method treats magic set\ntransformed programs correctly, i.e. it always computes a relevant part of the\nwell-founded model of the original program."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0011013v1", 
    "other_authors": [
        "Stefan Brass", 
        "Juergen Dix", 
        "Burkhard Freitag", 
        "Ulrich Zukowski"
    ], 
    "lead_author": "Stefan Brass", 
    "arxiv-id": "cs/0011013v1", 
    "title": "Transformation-Based Bottom-Up Computation of the Well-Founded Model", 
    "publish": "2000-11-08T14:32:48Z", 
    "summary": "We present a framework for expressing bottom-up algorithms to compute the\nwell-founded model of non-disjunctive logic programs. Our method is based on\nthe notion of conditional facts and elementary program transformations studied\nby Brass and Dix for disjunctive programs. However, even if we restrict their\nframework to nondisjunctive programs, their residual program can grow to\nexponential size, whereas for function-free programs our program remainder is\nalways polynomial in the size of the extensional database (EDB).\n  We show that particular orderings of our transformations (we call them\nstrategies) correspond to well-known computational methods like the alternating\nfixpoint approach, the well-founded magic sets method and the magic alternating\nfixpoint procedure. However, due to the confluence of our calculi, we come up\nwith computations of the well-founded model that are provably better than these\nmethods.\n  In contrast to other approaches, our transformation method treats magic set\ntransformed programs correctly, i.e. it always computes a relevant part of the\nwell-founded model of the original program."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0011013v1", 
    "other_authors": [
        "Stefan Brass", 
        "Juergen Dix", 
        "Burkhard Freitag", 
        "Ulrich Zukowski"
    ], 
    "lead_author": "Stefan Brass", 
    "arxiv-id": "cs/0011013v1", 
    "title": "Transformation-Based Bottom-Up Computation of the Well-Founded Model", 
    "publish": "2000-11-08T14:32:48Z", 
    "summary": "We present a framework for expressing bottom-up algorithms to compute the\nwell-founded model of non-disjunctive logic programs. Our method is based on\nthe notion of conditional facts and elementary program transformations studied\nby Brass and Dix for disjunctive programs. However, even if we restrict their\nframework to nondisjunctive programs, their residual program can grow to\nexponential size, whereas for function-free programs our program remainder is\nalways polynomial in the size of the extensional database (EDB).\n  We show that particular orderings of our transformations (we call them\nstrategies) correspond to well-known computational methods like the alternating\nfixpoint approach, the well-founded magic sets method and the magic alternating\nfixpoint procedure. However, due to the confluence of our calculi, we come up\nwith computations of the well-founded model that are provably better than these\nmethods.\n  In contrast to other approaches, our transformation method treats magic set\ntransformed programs correctly, i.e. it always computes a relevant part of the\nwell-founded model of the original program."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0011013v1", 
    "other_authors": [
        "Stefan Brass", 
        "Juergen Dix", 
        "Burkhard Freitag", 
        "Ulrich Zukowski"
    ], 
    "lead_author": "Stefan Brass", 
    "arxiv-id": "cs/0011013v1", 
    "title": "Transformation-Based Bottom-Up Computation of the Well-Founded Model", 
    "publish": "2000-11-08T14:32:48Z", 
    "summary": "We present a framework for expressing bottom-up algorithms to compute the\nwell-founded model of non-disjunctive logic programs. Our method is based on\nthe notion of conditional facts and elementary program transformations studied\nby Brass and Dix for disjunctive programs. However, even if we restrict their\nframework to nondisjunctive programs, their residual program can grow to\nexponential size, whereas for function-free programs our program remainder is\nalways polynomial in the size of the extensional database (EDB).\n  We show that particular orderings of our transformations (we call them\nstrategies) correspond to well-known computational methods like the alternating\nfixpoint approach, the well-founded magic sets method and the magic alternating\nfixpoint procedure. However, due to the confluence of our calculi, we come up\nwith computations of the well-founded model that are provably better than these\nmethods.\n  In contrast to other approaches, our transformation method treats magic set\ntransformed programs correctly, i.e. it always computes a relevant part of the\nwell-founded model of the original program."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0011013v1", 
    "other_authors": [
        "Stefan Brass", 
        "Juergen Dix", 
        "Burkhard Freitag", 
        "Ulrich Zukowski"
    ], 
    "lead_author": "Stefan Brass", 
    "arxiv-id": "cs/0011013v1", 
    "title": "Transformation-Based Bottom-Up Computation of the Well-Founded Model", 
    "publish": "2000-11-08T14:32:48Z", 
    "summary": "We present a framework for expressing bottom-up algorithms to compute the\nwell-founded model of non-disjunctive logic programs. Our method is based on\nthe notion of conditional facts and elementary program transformations studied\nby Brass and Dix for disjunctive programs. However, even if we restrict their\nframework to nondisjunctive programs, their residual program can grow to\nexponential size, whereas for function-free programs our program remainder is\nalways polynomial in the size of the extensional database (EDB).\n  We show that particular orderings of our transformations (we call them\nstrategies) correspond to well-known computational methods like the alternating\nfixpoint approach, the well-founded magic sets method and the magic alternating\nfixpoint procedure. However, due to the confluence of our calculi, we come up\nwith computations of the well-founded model that are provably better than these\nmethods.\n  In contrast to other approaches, our transformation method treats magic set\ntransformed programs correctly, i.e. it always computes a relevant part of the\nwell-founded model of the original program."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0011013v1", 
    "other_authors": [
        "Stefan Brass", 
        "Juergen Dix", 
        "Burkhard Freitag", 
        "Ulrich Zukowski"
    ], 
    "lead_author": "Stefan Brass", 
    "arxiv-id": "cs/0011013v1", 
    "title": "Transformation-Based Bottom-Up Computation of the Well-Founded Model", 
    "publish": "2000-11-08T14:32:48Z", 
    "summary": "We present a framework for expressing bottom-up algorithms to compute the\nwell-founded model of non-disjunctive logic programs. Our method is based on\nthe notion of conditional facts and elementary program transformations studied\nby Brass and Dix for disjunctive programs. However, even if we restrict their\nframework to nondisjunctive programs, their residual program can grow to\nexponential size, whereas for function-free programs our program remainder is\nalways polynomial in the size of the extensional database (EDB).\n  We show that particular orderings of our transformations (we call them\nstrategies) correspond to well-known computational methods like the alternating\nfixpoint approach, the well-founded magic sets method and the magic alternating\nfixpoint procedure. However, due to the confluence of our calculi, we come up\nwith computations of the well-founded model that are provably better than these\nmethods.\n  In contrast to other approaches, our transformation method treats magic set\ntransformed programs correctly, i.e. it always computes a relevant part of the\nwell-founded model of the original program."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0011013v1", 
    "other_authors": [
        "Stefan Brass", 
        "Juergen Dix", 
        "Burkhard Freitag", 
        "Ulrich Zukowski"
    ], 
    "lead_author": "Juergen Dix", 
    "arxiv-id": "cs/0011013v1", 
    "title": "Transformation-Based Bottom-Up Computation of the Well-Founded Model", 
    "publish": "2000-11-08T14:32:48Z", 
    "summary": "We present a framework for expressing bottom-up algorithms to compute the\nwell-founded model of non-disjunctive logic programs. Our method is based on\nthe notion of conditional facts and elementary program transformations studied\nby Brass and Dix for disjunctive programs. However, even if we restrict their\nframework to nondisjunctive programs, their residual program can grow to\nexponential size, whereas for function-free programs our program remainder is\nalways polynomial in the size of the extensional database (EDB).\n  We show that particular orderings of our transformations (we call them\nstrategies) correspond to well-known computational methods like the alternating\nfixpoint approach, the well-founded magic sets method and the magic alternating\nfixpoint procedure. However, due to the confluence of our calculi, we come up\nwith computations of the well-founded model that are provably better than these\nmethods.\n  In contrast to other approaches, our transformation method treats magic set\ntransformed programs correctly, i.e. it always computes a relevant part of the\nwell-founded model of the original program."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0011013v1", 
    "other_authors": [
        "Stefan Brass", 
        "Juergen Dix", 
        "Burkhard Freitag", 
        "Ulrich Zukowski"
    ], 
    "lead_author": "Juergen Dix", 
    "arxiv-id": "cs/0011013v1", 
    "title": "Transformation-Based Bottom-Up Computation of the Well-Founded Model", 
    "publish": "2000-11-08T14:32:48Z", 
    "summary": "We present a framework for expressing bottom-up algorithms to compute the\nwell-founded model of non-disjunctive logic programs. Our method is based on\nthe notion of conditional facts and elementary program transformations studied\nby Brass and Dix for disjunctive programs. However, even if we restrict their\nframework to nondisjunctive programs, their residual program can grow to\nexponential size, whereas for function-free programs our program remainder is\nalways polynomial in the size of the extensional database (EDB).\n  We show that particular orderings of our transformations (we call them\nstrategies) correspond to well-known computational methods like the alternating\nfixpoint approach, the well-founded magic sets method and the magic alternating\nfixpoint procedure. However, due to the confluence of our calculi, we come up\nwith computations of the well-founded model that are provably better than these\nmethods.\n  In contrast to other approaches, our transformation method treats magic set\ntransformed programs correctly, i.e. it always computes a relevant part of the\nwell-founded model of the original program."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0011013v1", 
    "other_authors": [
        "Stefan Brass", 
        "Juergen Dix", 
        "Burkhard Freitag", 
        "Ulrich Zukowski"
    ], 
    "lead_author": "Juergen Dix", 
    "arxiv-id": "cs/0011013v1", 
    "title": "Transformation-Based Bottom-Up Computation of the Well-Founded Model", 
    "publish": "2000-11-08T14:32:48Z", 
    "summary": "We present a framework for expressing bottom-up algorithms to compute the\nwell-founded model of non-disjunctive logic programs. Our method is based on\nthe notion of conditional facts and elementary program transformations studied\nby Brass and Dix for disjunctive programs. However, even if we restrict their\nframework to nondisjunctive programs, their residual program can grow to\nexponential size, whereas for function-free programs our program remainder is\nalways polynomial in the size of the extensional database (EDB).\n  We show that particular orderings of our transformations (we call them\nstrategies) correspond to well-known computational methods like the alternating\nfixpoint approach, the well-founded magic sets method and the magic alternating\nfixpoint procedure. However, due to the confluence of our calculi, we come up\nwith computations of the well-founded model that are provably better than these\nmethods.\n  In contrast to other approaches, our transformation method treats magic set\ntransformed programs correctly, i.e. it always computes a relevant part of the\nwell-founded model of the original program."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0011013v1", 
    "other_authors": [
        "Stefan Brass", 
        "Juergen Dix", 
        "Burkhard Freitag", 
        "Ulrich Zukowski"
    ], 
    "lead_author": "Juergen Dix", 
    "arxiv-id": "cs/0011013v1", 
    "title": "Transformation-Based Bottom-Up Computation of the Well-Founded Model", 
    "publish": "2000-11-08T14:32:48Z", 
    "summary": "We present a framework for expressing bottom-up algorithms to compute the\nwell-founded model of non-disjunctive logic programs. Our method is based on\nthe notion of conditional facts and elementary program transformations studied\nby Brass and Dix for disjunctive programs. However, even if we restrict their\nframework to nondisjunctive programs, their residual program can grow to\nexponential size, whereas for function-free programs our program remainder is\nalways polynomial in the size of the extensional database (EDB).\n  We show that particular orderings of our transformations (we call them\nstrategies) correspond to well-known computational methods like the alternating\nfixpoint approach, the well-founded magic sets method and the magic alternating\nfixpoint procedure. However, due to the confluence of our calculi, we come up\nwith computations of the well-founded model that are provably better than these\nmethods.\n  In contrast to other approaches, our transformation method treats magic set\ntransformed programs correctly, i.e. it always computes a relevant part of the\nwell-founded model of the original program."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0011013v1", 
    "other_authors": [
        "Stefan Brass", 
        "Juergen Dix", 
        "Burkhard Freitag", 
        "Ulrich Zukowski"
    ], 
    "lead_author": "Juergen Dix", 
    "arxiv-id": "cs/0011013v1", 
    "title": "Transformation-Based Bottom-Up Computation of the Well-Founded Model", 
    "publish": "2000-11-08T14:32:48Z", 
    "summary": "We present a framework for expressing bottom-up algorithms to compute the\nwell-founded model of non-disjunctive logic programs. Our method is based on\nthe notion of conditional facts and elementary program transformations studied\nby Brass and Dix for disjunctive programs. However, even if we restrict their\nframework to nondisjunctive programs, their residual program can grow to\nexponential size, whereas for function-free programs our program remainder is\nalways polynomial in the size of the extensional database (EDB).\n  We show that particular orderings of our transformations (we call them\nstrategies) correspond to well-known computational methods like the alternating\nfixpoint approach, the well-founded magic sets method and the magic alternating\nfixpoint procedure. However, due to the confluence of our calculi, we come up\nwith computations of the well-founded model that are provably better than these\nmethods.\n  In contrast to other approaches, our transformation method treats magic set\ntransformed programs correctly, i.e. it always computes a relevant part of the\nwell-founded model of the original program."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0011013v1", 
    "other_authors": [
        "Stefan Brass", 
        "Juergen Dix", 
        "Burkhard Freitag", 
        "Ulrich Zukowski"
    ], 
    "lead_author": "Juergen Dix", 
    "arxiv-id": "cs/0011013v1", 
    "title": "Transformation-Based Bottom-Up Computation of the Well-Founded Model", 
    "publish": "2000-11-08T14:32:48Z", 
    "summary": "We present a framework for expressing bottom-up algorithms to compute the\nwell-founded model of non-disjunctive logic programs. Our method is based on\nthe notion of conditional facts and elementary program transformations studied\nby Brass and Dix for disjunctive programs. However, even if we restrict their\nframework to nondisjunctive programs, their residual program can grow to\nexponential size, whereas for function-free programs our program remainder is\nalways polynomial in the size of the extensional database (EDB).\n  We show that particular orderings of our transformations (we call them\nstrategies) correspond to well-known computational methods like the alternating\nfixpoint approach, the well-founded magic sets method and the magic alternating\nfixpoint procedure. However, due to the confluence of our calculi, we come up\nwith computations of the well-founded model that are provably better than these\nmethods.\n  In contrast to other approaches, our transformation method treats magic set\ntransformed programs correctly, i.e. it always computes a relevant part of the\nwell-founded model of the original program."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0011013v1", 
    "other_authors": [
        "Stefan Brass", 
        "Juergen Dix", 
        "Burkhard Freitag", 
        "Ulrich Zukowski"
    ], 
    "lead_author": "Juergen Dix", 
    "arxiv-id": "cs/0011013v1", 
    "title": "Transformation-Based Bottom-Up Computation of the Well-Founded Model", 
    "publish": "2000-11-08T14:32:48Z", 
    "summary": "We present a framework for expressing bottom-up algorithms to compute the\nwell-founded model of non-disjunctive logic programs. Our method is based on\nthe notion of conditional facts and elementary program transformations studied\nby Brass and Dix for disjunctive programs. However, even if we restrict their\nframework to nondisjunctive programs, their residual program can grow to\nexponential size, whereas for function-free programs our program remainder is\nalways polynomial in the size of the extensional database (EDB).\n  We show that particular orderings of our transformations (we call them\nstrategies) correspond to well-known computational methods like the alternating\nfixpoint approach, the well-founded magic sets method and the magic alternating\nfixpoint procedure. However, due to the confluence of our calculi, we come up\nwith computations of the well-founded model that are provably better than these\nmethods.\n  In contrast to other approaches, our transformation method treats magic set\ntransformed programs correctly, i.e. it always computes a relevant part of the\nwell-founded model of the original program."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0011013v1", 
    "other_authors": [
        "Stefan Brass", 
        "Juergen Dix", 
        "Burkhard Freitag", 
        "Ulrich Zukowski"
    ], 
    "lead_author": "Burkhard Freitag", 
    "arxiv-id": "cs/0011013v1", 
    "title": "Transformation-Based Bottom-Up Computation of the Well-Founded Model", 
    "publish": "2000-11-08T14:32:48Z", 
    "summary": "We present a framework for expressing bottom-up algorithms to compute the\nwell-founded model of non-disjunctive logic programs. Our method is based on\nthe notion of conditional facts and elementary program transformations studied\nby Brass and Dix for disjunctive programs. However, even if we restrict their\nframework to nondisjunctive programs, their residual program can grow to\nexponential size, whereas for function-free programs our program remainder is\nalways polynomial in the size of the extensional database (EDB).\n  We show that particular orderings of our transformations (we call them\nstrategies) correspond to well-known computational methods like the alternating\nfixpoint approach, the well-founded magic sets method and the magic alternating\nfixpoint procedure. However, due to the confluence of our calculi, we come up\nwith computations of the well-founded model that are provably better than these\nmethods.\n  In contrast to other approaches, our transformation method treats magic set\ntransformed programs correctly, i.e. it always computes a relevant part of the\nwell-founded model of the original program."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0011013v1", 
    "other_authors": [
        "Stefan Brass", 
        "Juergen Dix", 
        "Burkhard Freitag", 
        "Ulrich Zukowski"
    ], 
    "lead_author": "Burkhard Freitag", 
    "arxiv-id": "cs/0011013v1", 
    "title": "Transformation-Based Bottom-Up Computation of the Well-Founded Model", 
    "publish": "2000-11-08T14:32:48Z", 
    "summary": "We present a framework for expressing bottom-up algorithms to compute the\nwell-founded model of non-disjunctive logic programs. Our method is based on\nthe notion of conditional facts and elementary program transformations studied\nby Brass and Dix for disjunctive programs. However, even if we restrict their\nframework to nondisjunctive programs, their residual program can grow to\nexponential size, whereas for function-free programs our program remainder is\nalways polynomial in the size of the extensional database (EDB).\n  We show that particular orderings of our transformations (we call them\nstrategies) correspond to well-known computational methods like the alternating\nfixpoint approach, the well-founded magic sets method and the magic alternating\nfixpoint procedure. However, due to the confluence of our calculi, we come up\nwith computations of the well-founded model that are provably better than these\nmethods.\n  In contrast to other approaches, our transformation method treats magic set\ntransformed programs correctly, i.e. it always computes a relevant part of the\nwell-founded model of the original program."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0011013v1", 
    "other_authors": [
        "Stefan Brass", 
        "Juergen Dix", 
        "Burkhard Freitag", 
        "Ulrich Zukowski"
    ], 
    "lead_author": "Burkhard Freitag", 
    "arxiv-id": "cs/0011013v1", 
    "title": "Transformation-Based Bottom-Up Computation of the Well-Founded Model", 
    "publish": "2000-11-08T14:32:48Z", 
    "summary": "We present a framework for expressing bottom-up algorithms to compute the\nwell-founded model of non-disjunctive logic programs. Our method is based on\nthe notion of conditional facts and elementary program transformations studied\nby Brass and Dix for disjunctive programs. However, even if we restrict their\nframework to nondisjunctive programs, their residual program can grow to\nexponential size, whereas for function-free programs our program remainder is\nalways polynomial in the size of the extensional database (EDB).\n  We show that particular orderings of our transformations (we call them\nstrategies) correspond to well-known computational methods like the alternating\nfixpoint approach, the well-founded magic sets method and the magic alternating\nfixpoint procedure. However, due to the confluence of our calculi, we come up\nwith computations of the well-founded model that are provably better than these\nmethods.\n  In contrast to other approaches, our transformation method treats magic set\ntransformed programs correctly, i.e. it always computes a relevant part of the\nwell-founded model of the original program."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0011013v1", 
    "other_authors": [
        "Stefan Brass", 
        "Juergen Dix", 
        "Burkhard Freitag", 
        "Ulrich Zukowski"
    ], 
    "lead_author": "Ulrich Zukowski", 
    "arxiv-id": "cs/0011013v1", 
    "title": "Transformation-Based Bottom-Up Computation of the Well-Founded Model", 
    "publish": "2000-11-08T14:32:48Z", 
    "summary": "We present a framework for expressing bottom-up algorithms to compute the\nwell-founded model of non-disjunctive logic programs. Our method is based on\nthe notion of conditional facts and elementary program transformations studied\nby Brass and Dix for disjunctive programs. However, even if we restrict their\nframework to nondisjunctive programs, their residual program can grow to\nexponential size, whereas for function-free programs our program remainder is\nalways polynomial in the size of the extensional database (EDB).\n  We show that particular orderings of our transformations (we call them\nstrategies) correspond to well-known computational methods like the alternating\nfixpoint approach, the well-founded magic sets method and the magic alternating\nfixpoint procedure. However, due to the confluence of our calculi, we come up\nwith computations of the well-founded model that are provably better than these\nmethods.\n  In contrast to other approaches, our transformation method treats magic set\ntransformed programs correctly, i.e. it always computes a relevant part of the\nwell-founded model of the original program."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0011037v2", 
    "other_authors": [
        "Klaus Aehlig", 
        "Helmut Schwichtenberg"
    ], 
    "lead_author": "Klaus Aehlig", 
    "arxiv-id": "cs/0011037v2", 
    "title": "A syntactical analysis of non-size-increasing polynomial time   computation", 
    "publish": "2000-11-23T10:09:06Z", 
    "summary": "A syntactical proof is given that all functions definable in a certain affine\nlinear typed lambda-calculus with iteration in all types are polynomial time\ncomputable. The proof provides explicit polynomial bounds that can easily be\ncalculated."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0011037v2", 
    "other_authors": [
        "Klaus Aehlig", 
        "Helmut Schwichtenberg"
    ], 
    "lead_author": "Klaus Aehlig", 
    "arxiv-id": "cs/0011037v2", 
    "title": "A syntactical analysis of non-size-increasing polynomial time   computation", 
    "publish": "2000-11-23T10:09:06Z", 
    "summary": "A syntactical proof is given that all functions definable in a certain affine\nlinear typed lambda-calculus with iteration in all types are polynomial time\ncomputable. The proof provides explicit polynomial bounds that can easily be\ncalculated."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0011037v2", 
    "other_authors": [
        "Klaus Aehlig", 
        "Helmut Schwichtenberg"
    ], 
    "lead_author": "Klaus Aehlig", 
    "arxiv-id": "cs/0011037v2", 
    "title": "A syntactical analysis of non-size-increasing polynomial time   computation", 
    "publish": "2000-11-23T10:09:06Z", 
    "summary": "A syntactical proof is given that all functions definable in a certain affine\nlinear typed lambda-calculus with iteration in all types are polynomial time\ncomputable. The proof provides explicit polynomial bounds that can easily be\ncalculated."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0011037v2", 
    "other_authors": [
        "Klaus Aehlig", 
        "Helmut Schwichtenberg"
    ], 
    "lead_author": "Klaus Aehlig", 
    "arxiv-id": "cs/0011037v2", 
    "title": "A syntactical analysis of non-size-increasing polynomial time   computation", 
    "publish": "2000-11-23T10:09:06Z", 
    "summary": "A syntactical proof is given that all functions definable in a certain affine\nlinear typed lambda-calculus with iteration in all types are polynomial time\ncomputable. The proof provides explicit polynomial bounds that can easily be\ncalculated."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0011037v2", 
    "other_authors": [
        "Klaus Aehlig", 
        "Helmut Schwichtenberg"
    ], 
    "lead_author": "Klaus Aehlig", 
    "arxiv-id": "cs/0011037v2", 
    "title": "A syntactical analysis of non-size-increasing polynomial time   computation", 
    "publish": "2000-11-23T10:09:06Z", 
    "summary": "A syntactical proof is given that all functions definable in a certain affine\nlinear typed lambda-calculus with iteration in all types are polynomial time\ncomputable. The proof provides explicit polynomial bounds that can easily be\ncalculated."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0011037v2", 
    "other_authors": [
        "Klaus Aehlig", 
        "Helmut Schwichtenberg"
    ], 
    "lead_author": "Klaus Aehlig", 
    "arxiv-id": "cs/0011037v2", 
    "title": "A syntactical analysis of non-size-increasing polynomial time   computation", 
    "publish": "2000-11-23T10:09:06Z", 
    "summary": "A syntactical proof is given that all functions definable in a certain affine\nlinear typed lambda-calculus with iteration in all types are polynomial time\ncomputable. The proof provides explicit polynomial bounds that can easily be\ncalculated."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0011037v2", 
    "other_authors": [
        "Klaus Aehlig", 
        "Helmut Schwichtenberg"
    ], 
    "lead_author": "Helmut Schwichtenberg", 
    "arxiv-id": "cs/0011037v2", 
    "title": "A syntactical analysis of non-size-increasing polynomial time   computation", 
    "publish": "2000-11-23T10:09:06Z", 
    "summary": "A syntactical proof is given that all functions definable in a certain affine\nlinear typed lambda-calculus with iteration in all types are polynomial time\ncomputable. The proof provides explicit polynomial bounds that can easily be\ncalculated."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0011037v2", 
    "other_authors": [
        "Klaus Aehlig", 
        "Helmut Schwichtenberg"
    ], 
    "lead_author": "Helmut Schwichtenberg", 
    "arxiv-id": "cs/0011037v2", 
    "title": "A syntactical analysis of non-size-increasing polynomial time   computation", 
    "publish": "2000-11-23T10:09:06Z", 
    "summary": "A syntactical proof is given that all functions definable in a certain affine\nlinear typed lambda-calculus with iteration in all types are polynomial time\ncomputable. The proof provides explicit polynomial bounds that can easily be\ncalculated."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0011037v2", 
    "other_authors": [
        "Klaus Aehlig", 
        "Helmut Schwichtenberg"
    ], 
    "lead_author": "Helmut Schwichtenberg", 
    "arxiv-id": "cs/0011037v2", 
    "title": "A syntactical analysis of non-size-increasing polynomial time   computation", 
    "publish": "2000-11-23T10:09:06Z", 
    "summary": "A syntactical proof is given that all functions definable in a certain affine\nlinear typed lambda-calculus with iteration in all types are polynomial time\ncomputable. The proof provides explicit polynomial bounds that can easily be\ncalculated."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0011037v2", 
    "other_authors": [
        "Klaus Aehlig", 
        "Helmut Schwichtenberg"
    ], 
    "lead_author": "Helmut Schwichtenberg", 
    "arxiv-id": "cs/0011037v2", 
    "title": "A syntactical analysis of non-size-increasing polynomial time   computation", 
    "publish": "2000-11-23T10:09:06Z", 
    "summary": "A syntactical proof is given that all functions definable in a certain affine\nlinear typed lambda-calculus with iteration in all types are polynomial time\ncomputable. The proof provides explicit polynomial bounds that can easily be\ncalculated."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0011037v2", 
    "other_authors": [
        "Klaus Aehlig", 
        "Helmut Schwichtenberg"
    ], 
    "lead_author": "Helmut Schwichtenberg", 
    "arxiv-id": "cs/0011037v2", 
    "title": "A syntactical analysis of non-size-increasing polynomial time   computation", 
    "publish": "2000-11-23T10:09:06Z", 
    "summary": "A syntactical proof is given that all functions definable in a certain affine\nlinear typed lambda-calculus with iteration in all types are polynomial time\ncomputable. The proof provides explicit polynomial bounds that can easily be\ncalculated."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0011037v2", 
    "other_authors": [
        "Klaus Aehlig", 
        "Helmut Schwichtenberg"
    ], 
    "lead_author": "Helmut Schwichtenberg", 
    "arxiv-id": "cs/0011037v2", 
    "title": "A syntactical analysis of non-size-increasing polynomial time   computation", 
    "publish": "2000-11-23T10:09:06Z", 
    "summary": "A syntactical proof is given that all functions definable in a certain affine\nlinear typed lambda-calculus with iteration in all types are polynomial time\ncomputable. The proof provides explicit polynomial bounds that can easily be\ncalculated."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0011039v1", 
    "other_authors": [
        "M. Dezani-Ciancaglini", 
        "F. Honsell", 
        "F. Alessi"
    ], 
    "lead_author": "F. Honsell", 
    "arxiv-id": "cs/0011039v1", 
    "title": "A Complete Characterization of Complete Intersection-Type Theories", 
    "publish": "2000-11-23T17:40:24Z", 
    "summary": "We characterize those intersection-type theories which yield complete\nintersection-type assignment systems for lambda-calculi, with respect to the\nthree canonical set-theoretical semantics for intersection-types: the inference\nsemantics, the simple semantics and the F-semantics. These semantics arise by\ntaking as interpretation of types subsets of applicative structures, as\ninterpretation of the intersection constructor set-theoretic inclusion, and by\ntaking the interpretation of the arrow constructor a' la Scott, with respect to\neither any possible functionality set, or the largest one, or the least one.\n  These results strengthen and generalize significantly all earlier results in\nthe literature, to our knowledge, in at least three respects. First of all the\ninference semantics had not been considered before. Secondly, the\ncharacterizations are all given just in terms of simple closure conditions on\nthe preorder relation on the types, rather than on the typing judgments\nthemselves. The task of checking the condition is made therefore considerably\nmore tractable. Lastly, we do not restrict attention just to lambda-models, but\nto arbitrary applicative structures which admit an interpretation function.\nThus we allow also for the treatment of models of restricted lambda-calculi.\nNevertheless the characterizations we give can be tailored just to the case of\nlambda-models."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0011039v1", 
    "other_authors": [
        "M. Dezani-Ciancaglini", 
        "F. Honsell", 
        "F. Alessi"
    ], 
    "lead_author": "F. Honsell", 
    "arxiv-id": "cs/0011039v1", 
    "title": "A Complete Characterization of Complete Intersection-Type Theories", 
    "publish": "2000-11-23T17:40:24Z", 
    "summary": "We characterize those intersection-type theories which yield complete\nintersection-type assignment systems for lambda-calculi, with respect to the\nthree canonical set-theoretical semantics for intersection-types: the inference\nsemantics, the simple semantics and the F-semantics. These semantics arise by\ntaking as interpretation of types subsets of applicative structures, as\ninterpretation of the intersection constructor set-theoretic inclusion, and by\ntaking the interpretation of the arrow constructor a' la Scott, with respect to\neither any possible functionality set, or the largest one, or the least one.\n  These results strengthen and generalize significantly all earlier results in\nthe literature, to our knowledge, in at least three respects. First of all the\ninference semantics had not been considered before. Secondly, the\ncharacterizations are all given just in terms of simple closure conditions on\nthe preorder relation on the types, rather than on the typing judgments\nthemselves. The task of checking the condition is made therefore considerably\nmore tractable. Lastly, we do not restrict attention just to lambda-models, but\nto arbitrary applicative structures which admit an interpretation function.\nThus we allow also for the treatment of models of restricted lambda-calculi.\nNevertheless the characterizations we give can be tailored just to the case of\nlambda-models."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0011039v1", 
    "other_authors": [
        "M. Dezani-Ciancaglini", 
        "F. Honsell", 
        "F. Alessi"
    ], 
    "lead_author": "F. Honsell", 
    "arxiv-id": "cs/0011039v1", 
    "title": "A Complete Characterization of Complete Intersection-Type Theories", 
    "publish": "2000-11-23T17:40:24Z", 
    "summary": "We characterize those intersection-type theories which yield complete\nintersection-type assignment systems for lambda-calculi, with respect to the\nthree canonical set-theoretical semantics for intersection-types: the inference\nsemantics, the simple semantics and the F-semantics. These semantics arise by\ntaking as interpretation of types subsets of applicative structures, as\ninterpretation of the intersection constructor set-theoretic inclusion, and by\ntaking the interpretation of the arrow constructor a' la Scott, with respect to\neither any possible functionality set, or the largest one, or the least one.\n  These results strengthen and generalize significantly all earlier results in\nthe literature, to our knowledge, in at least three respects. First of all the\ninference semantics had not been considered before. Secondly, the\ncharacterizations are all given just in terms of simple closure conditions on\nthe preorder relation on the types, rather than on the typing judgments\nthemselves. The task of checking the condition is made therefore considerably\nmore tractable. Lastly, we do not restrict attention just to lambda-models, but\nto arbitrary applicative structures which admit an interpretation function.\nThus we allow also for the treatment of models of restricted lambda-calculi.\nNevertheless the characterizations we give can be tailored just to the case of\nlambda-models."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0011039v1", 
    "other_authors": [
        "M. Dezani-Ciancaglini", 
        "F. Honsell", 
        "F. Alessi"
    ], 
    "lead_author": "F. Honsell", 
    "arxiv-id": "cs/0011039v1", 
    "title": "A Complete Characterization of Complete Intersection-Type Theories", 
    "publish": "2000-11-23T17:40:24Z", 
    "summary": "We characterize those intersection-type theories which yield complete\nintersection-type assignment systems for lambda-calculi, with respect to the\nthree canonical set-theoretical semantics for intersection-types: the inference\nsemantics, the simple semantics and the F-semantics. These semantics arise by\ntaking as interpretation of types subsets of applicative structures, as\ninterpretation of the intersection constructor set-theoretic inclusion, and by\ntaking the interpretation of the arrow constructor a' la Scott, with respect to\neither any possible functionality set, or the largest one, or the least one.\n  These results strengthen and generalize significantly all earlier results in\nthe literature, to our knowledge, in at least three respects. First of all the\ninference semantics had not been considered before. Secondly, the\ncharacterizations are all given just in terms of simple closure conditions on\nthe preorder relation on the types, rather than on the typing judgments\nthemselves. The task of checking the condition is made therefore considerably\nmore tractable. Lastly, we do not restrict attention just to lambda-models, but\nto arbitrary applicative structures which admit an interpretation function.\nThus we allow also for the treatment of models of restricted lambda-calculi.\nNevertheless the characterizations we give can be tailored just to the case of\nlambda-models."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0011039v1", 
    "other_authors": [
        "M. Dezani-Ciancaglini", 
        "F. Honsell", 
        "F. Alessi"
    ], 
    "lead_author": "F. Honsell", 
    "arxiv-id": "cs/0011039v1", 
    "title": "A Complete Characterization of Complete Intersection-Type Theories", 
    "publish": "2000-11-23T17:40:24Z", 
    "summary": "We characterize those intersection-type theories which yield complete\nintersection-type assignment systems for lambda-calculi, with respect to the\nthree canonical set-theoretical semantics for intersection-types: the inference\nsemantics, the simple semantics and the F-semantics. These semantics arise by\ntaking as interpretation of types subsets of applicative structures, as\ninterpretation of the intersection constructor set-theoretic inclusion, and by\ntaking the interpretation of the arrow constructor a' la Scott, with respect to\neither any possible functionality set, or the largest one, or the least one.\n  These results strengthen and generalize significantly all earlier results in\nthe literature, to our knowledge, in at least three respects. First of all the\ninference semantics had not been considered before. Secondly, the\ncharacterizations are all given just in terms of simple closure conditions on\nthe preorder relation on the types, rather than on the typing judgments\nthemselves. The task of checking the condition is made therefore considerably\nmore tractable. Lastly, we do not restrict attention just to lambda-models, but\nto arbitrary applicative structures which admit an interpretation function.\nThus we allow also for the treatment of models of restricted lambda-calculi.\nNevertheless the characterizations we give can be tailored just to the case of\nlambda-models."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0011039v1", 
    "other_authors": [
        "M. Dezani-Ciancaglini", 
        "F. Honsell", 
        "F. Alessi"
    ], 
    "lead_author": "F. Alessi", 
    "arxiv-id": "cs/0011039v1", 
    "title": "A Complete Characterization of Complete Intersection-Type Theories", 
    "publish": "2000-11-23T17:40:24Z", 
    "summary": "We characterize those intersection-type theories which yield complete\nintersection-type assignment systems for lambda-calculi, with respect to the\nthree canonical set-theoretical semantics for intersection-types: the inference\nsemantics, the simple semantics and the F-semantics. These semantics arise by\ntaking as interpretation of types subsets of applicative structures, as\ninterpretation of the intersection constructor set-theoretic inclusion, and by\ntaking the interpretation of the arrow constructor a' la Scott, with respect to\neither any possible functionality set, or the largest one, or the least one.\n  These results strengthen and generalize significantly all earlier results in\nthe literature, to our knowledge, in at least three respects. First of all the\ninference semantics had not been considered before. Secondly, the\ncharacterizations are all given just in terms of simple closure conditions on\nthe preorder relation on the types, rather than on the typing judgments\nthemselves. The task of checking the condition is made therefore considerably\nmore tractable. Lastly, we do not restrict attention just to lambda-models, but\nto arbitrary applicative structures which admit an interpretation function.\nThus we allow also for the treatment of models of restricted lambda-calculi.\nNevertheless the characterizations we give can be tailored just to the case of\nlambda-models."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0012015v2", 
    "other_authors": [
        "Pierre Deransart", 
        "Jan-Georg Smaus"
    ], 
    "lead_author": "Pierre Deransart", 
    "arxiv-id": "cs/0012015v2", 
    "title": "Well-Typed Logic Programs Are not Wrong", 
    "publish": "2000-12-20T15:45:32Z", 
    "summary": "We consider prescriptive type systems for logic programs (as in Goedel or\nMercury). In such systems, the typing is static, but it guarantees an\noperational property: if a program is \"well-typed\", then all derivations\nstarting in a \"well-typed\" query are again \"well-typed\". This property has been\ncalled subject reduction. We show that this property can also be phrased as a\nproperty of the proof-theoretic semantics of logic programs, thus abstracting\nfrom the usual operational (top-down) semantics. This proof-theoretic view\nleads us to questioning a condition which is usually considered necessary for\nsubject reduction, namely the head condition. It states that the head of each\nclause must have a type which is a variant (and not a proper instance) of the\ndeclared type. We provide a more general condition, thus reestablishing a\ncertain symmetry between heads and body atoms. The condition ensures that in a\nderivation, the types of two unified terms are themselves unifiable. We discuss\npossible implications of this result. We also discuss the relationship between\nthe head condition and polymorphic recursion, a concept known in functional\nprogramming."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0012015v2", 
    "other_authors": [
        "Pierre Deransart", 
        "Jan-Georg Smaus"
    ], 
    "lead_author": "Pierre Deransart", 
    "arxiv-id": "cs/0012015v2", 
    "title": "Well-Typed Logic Programs Are not Wrong", 
    "publish": "2000-12-20T15:45:32Z", 
    "summary": "We consider prescriptive type systems for logic programs (as in Goedel or\nMercury). In such systems, the typing is static, but it guarantees an\noperational property: if a program is \"well-typed\", then all derivations\nstarting in a \"well-typed\" query are again \"well-typed\". This property has been\ncalled subject reduction. We show that this property can also be phrased as a\nproperty of the proof-theoretic semantics of logic programs, thus abstracting\nfrom the usual operational (top-down) semantics. This proof-theoretic view\nleads us to questioning a condition which is usually considered necessary for\nsubject reduction, namely the head condition. It states that the head of each\nclause must have a type which is a variant (and not a proper instance) of the\ndeclared type. We provide a more general condition, thus reestablishing a\ncertain symmetry between heads and body atoms. The condition ensures that in a\nderivation, the types of two unified terms are themselves unifiable. We discuss\npossible implications of this result. We also discuss the relationship between\nthe head condition and polymorphic recursion, a concept known in functional\nprogramming."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0012015v2", 
    "other_authors": [
        "Pierre Deransart", 
        "Jan-Georg Smaus"
    ], 
    "lead_author": "Pierre Deransart", 
    "arxiv-id": "cs/0012015v2", 
    "title": "Well-Typed Logic Programs Are not Wrong", 
    "publish": "2000-12-20T15:45:32Z", 
    "summary": "We consider prescriptive type systems for logic programs (as in Goedel or\nMercury). In such systems, the typing is static, but it guarantees an\noperational property: if a program is \"well-typed\", then all derivations\nstarting in a \"well-typed\" query are again \"well-typed\". This property has been\ncalled subject reduction. We show that this property can also be phrased as a\nproperty of the proof-theoretic semantics of logic programs, thus abstracting\nfrom the usual operational (top-down) semantics. This proof-theoretic view\nleads us to questioning a condition which is usually considered necessary for\nsubject reduction, namely the head condition. It states that the head of each\nclause must have a type which is a variant (and not a proper instance) of the\ndeclared type. We provide a more general condition, thus reestablishing a\ncertain symmetry between heads and body atoms. The condition ensures that in a\nderivation, the types of two unified terms are themselves unifiable. We discuss\npossible implications of this result. We also discuss the relationship between\nthe head condition and polymorphic recursion, a concept known in functional\nprogramming."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0012015v2", 
    "other_authors": [
        "Pierre Deransart", 
        "Jan-Georg Smaus"
    ], 
    "lead_author": "Pierre Deransart", 
    "arxiv-id": "cs/0012015v2", 
    "title": "Well-Typed Logic Programs Are not Wrong", 
    "publish": "2000-12-20T15:45:32Z", 
    "summary": "We consider prescriptive type systems for logic programs (as in Goedel or\nMercury). In such systems, the typing is static, but it guarantees an\noperational property: if a program is \"well-typed\", then all derivations\nstarting in a \"well-typed\" query are again \"well-typed\". This property has been\ncalled subject reduction. We show that this property can also be phrased as a\nproperty of the proof-theoretic semantics of logic programs, thus abstracting\nfrom the usual operational (top-down) semantics. This proof-theoretic view\nleads us to questioning a condition which is usually considered necessary for\nsubject reduction, namely the head condition. It states that the head of each\nclause must have a type which is a variant (and not a proper instance) of the\ndeclared type. We provide a more general condition, thus reestablishing a\ncertain symmetry between heads and body atoms. The condition ensures that in a\nderivation, the types of two unified terms are themselves unifiable. We discuss\npossible implications of this result. We also discuss the relationship between\nthe head condition and polymorphic recursion, a concept known in functional\nprogramming."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0012015v2", 
    "other_authors": [
        "Pierre Deransart", 
        "Jan-Georg Smaus"
    ], 
    "lead_author": "Pierre Deransart", 
    "arxiv-id": "cs/0012015v2", 
    "title": "Well-Typed Logic Programs Are not Wrong", 
    "publish": "2000-12-20T15:45:32Z", 
    "summary": "We consider prescriptive type systems for logic programs (as in Goedel or\nMercury). In such systems, the typing is static, but it guarantees an\noperational property: if a program is \"well-typed\", then all derivations\nstarting in a \"well-typed\" query are again \"well-typed\". This property has been\ncalled subject reduction. We show that this property can also be phrased as a\nproperty of the proof-theoretic semantics of logic programs, thus abstracting\nfrom the usual operational (top-down) semantics. This proof-theoretic view\nleads us to questioning a condition which is usually considered necessary for\nsubject reduction, namely the head condition. It states that the head of each\nclause must have a type which is a variant (and not a proper instance) of the\ndeclared type. We provide a more general condition, thus reestablishing a\ncertain symmetry between heads and body atoms. The condition ensures that in a\nderivation, the types of two unified terms are themselves unifiable. We discuss\npossible implications of this result. We also discuss the relationship between\nthe head condition and polymorphic recursion, a concept known in functional\nprogramming."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0012015v2", 
    "other_authors": [
        "Pierre Deransart", 
        "Jan-Georg Smaus"
    ], 
    "lead_author": "Pierre Deransart", 
    "arxiv-id": "cs/0012015v2", 
    "title": "Well-Typed Logic Programs Are not Wrong", 
    "publish": "2000-12-20T15:45:32Z", 
    "summary": "We consider prescriptive type systems for logic programs (as in Goedel or\nMercury). In such systems, the typing is static, but it guarantees an\noperational property: if a program is \"well-typed\", then all derivations\nstarting in a \"well-typed\" query are again \"well-typed\". This property has been\ncalled subject reduction. We show that this property can also be phrased as a\nproperty of the proof-theoretic semantics of logic programs, thus abstracting\nfrom the usual operational (top-down) semantics. This proof-theoretic view\nleads us to questioning a condition which is usually considered necessary for\nsubject reduction, namely the head condition. It states that the head of each\nclause must have a type which is a variant (and not a proper instance) of the\ndeclared type. We provide a more general condition, thus reestablishing a\ncertain symmetry between heads and body atoms. The condition ensures that in a\nderivation, the types of two unified terms are themselves unifiable. We discuss\npossible implications of this result. We also discuss the relationship between\nthe head condition and polymorphic recursion, a concept known in functional\nprogramming."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0012015v2", 
    "other_authors": [
        "Pierre Deransart", 
        "Jan-Georg Smaus"
    ], 
    "lead_author": "Pierre Deransart", 
    "arxiv-id": "cs/0012015v2", 
    "title": "Well-Typed Logic Programs Are not Wrong", 
    "publish": "2000-12-20T15:45:32Z", 
    "summary": "We consider prescriptive type systems for logic programs (as in Goedel or\nMercury). In such systems, the typing is static, but it guarantees an\noperational property: if a program is \"well-typed\", then all derivations\nstarting in a \"well-typed\" query are again \"well-typed\". This property has been\ncalled subject reduction. We show that this property can also be phrased as a\nproperty of the proof-theoretic semantics of logic programs, thus abstracting\nfrom the usual operational (top-down) semantics. This proof-theoretic view\nleads us to questioning a condition which is usually considered necessary for\nsubject reduction, namely the head condition. It states that the head of each\nclause must have a type which is a variant (and not a proper instance) of the\ndeclared type. We provide a more general condition, thus reestablishing a\ncertain symmetry between heads and body atoms. The condition ensures that in a\nderivation, the types of two unified terms are themselves unifiable. We discuss\npossible implications of this result. We also discuss the relationship between\nthe head condition and polymorphic recursion, a concept known in functional\nprogramming."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0012015v2", 
    "other_authors": [
        "Pierre Deransart", 
        "Jan-Georg Smaus"
    ], 
    "lead_author": "Pierre Deransart", 
    "arxiv-id": "cs/0012015v2", 
    "title": "Well-Typed Logic Programs Are not Wrong", 
    "publish": "2000-12-20T15:45:32Z", 
    "summary": "We consider prescriptive type systems for logic programs (as in Goedel or\nMercury). In such systems, the typing is static, but it guarantees an\noperational property: if a program is \"well-typed\", then all derivations\nstarting in a \"well-typed\" query are again \"well-typed\". This property has been\ncalled subject reduction. We show that this property can also be phrased as a\nproperty of the proof-theoretic semantics of logic programs, thus abstracting\nfrom the usual operational (top-down) semantics. This proof-theoretic view\nleads us to questioning a condition which is usually considered necessary for\nsubject reduction, namely the head condition. It states that the head of each\nclause must have a type which is a variant (and not a proper instance) of the\ndeclared type. We provide a more general condition, thus reestablishing a\ncertain symmetry between heads and body atoms. The condition ensures that in a\nderivation, the types of two unified terms are themselves unifiable. We discuss\npossible implications of this result. We also discuss the relationship between\nthe head condition and polymorphic recursion, a concept known in functional\nprogramming."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0012015v2", 
    "other_authors": [
        "Pierre Deransart", 
        "Jan-Georg Smaus"
    ], 
    "lead_author": "Pierre Deransart", 
    "arxiv-id": "cs/0012015v2", 
    "title": "Well-Typed Logic Programs Are not Wrong", 
    "publish": "2000-12-20T15:45:32Z", 
    "summary": "We consider prescriptive type systems for logic programs (as in Goedel or\nMercury). In such systems, the typing is static, but it guarantees an\noperational property: if a program is \"well-typed\", then all derivations\nstarting in a \"well-typed\" query are again \"well-typed\". This property has been\ncalled subject reduction. We show that this property can also be phrased as a\nproperty of the proof-theoretic semantics of logic programs, thus abstracting\nfrom the usual operational (top-down) semantics. This proof-theoretic view\nleads us to questioning a condition which is usually considered necessary for\nsubject reduction, namely the head condition. It states that the head of each\nclause must have a type which is a variant (and not a proper instance) of the\ndeclared type. We provide a more general condition, thus reestablishing a\ncertain symmetry between heads and body atoms. The condition ensures that in a\nderivation, the types of two unified terms are themselves unifiable. We discuss\npossible implications of this result. We also discuss the relationship between\nthe head condition and polymorphic recursion, a concept known in functional\nprogramming."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0012015v2", 
    "other_authors": [
        "Pierre Deransart", 
        "Jan-Georg Smaus"
    ], 
    "lead_author": "Pierre Deransart", 
    "arxiv-id": "cs/0012015v2", 
    "title": "Well-Typed Logic Programs Are not Wrong", 
    "publish": "2000-12-20T15:45:32Z", 
    "summary": "We consider prescriptive type systems for logic programs (as in Goedel or\nMercury). In such systems, the typing is static, but it guarantees an\noperational property: if a program is \"well-typed\", then all derivations\nstarting in a \"well-typed\" query are again \"well-typed\". This property has been\ncalled subject reduction. We show that this property can also be phrased as a\nproperty of the proof-theoretic semantics of logic programs, thus abstracting\nfrom the usual operational (top-down) semantics. This proof-theoretic view\nleads us to questioning a condition which is usually considered necessary for\nsubject reduction, namely the head condition. It states that the head of each\nclause must have a type which is a variant (and not a proper instance) of the\ndeclared type. We provide a more general condition, thus reestablishing a\ncertain symmetry between heads and body atoms. The condition ensures that in a\nderivation, the types of two unified terms are themselves unifiable. We discuss\npossible implications of this result. We also discuss the relationship between\nthe head condition and polymorphic recursion, a concept known in functional\nprogramming."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0012015v2", 
    "other_authors": [
        "Pierre Deransart", 
        "Jan-Georg Smaus"
    ], 
    "lead_author": "Pierre Deransart", 
    "arxiv-id": "cs/0012015v2", 
    "title": "Well-Typed Logic Programs Are not Wrong", 
    "publish": "2000-12-20T15:45:32Z", 
    "summary": "We consider prescriptive type systems for logic programs (as in Goedel or\nMercury). In such systems, the typing is static, but it guarantees an\noperational property: if a program is \"well-typed\", then all derivations\nstarting in a \"well-typed\" query are again \"well-typed\". This property has been\ncalled subject reduction. We show that this property can also be phrased as a\nproperty of the proof-theoretic semantics of logic programs, thus abstracting\nfrom the usual operational (top-down) semantics. This proof-theoretic view\nleads us to questioning a condition which is usually considered necessary for\nsubject reduction, namely the head condition. It states that the head of each\nclause must have a type which is a variant (and not a proper instance) of the\ndeclared type. We provide a more general condition, thus reestablishing a\ncertain symmetry between heads and body atoms. The condition ensures that in a\nderivation, the types of two unified terms are themselves unifiable. We discuss\npossible implications of this result. We also discuss the relationship between\nthe head condition and polymorphic recursion, a concept known in functional\nprogramming."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0012015v2", 
    "other_authors": [
        "Pierre Deransart", 
        "Jan-Georg Smaus"
    ], 
    "lead_author": "Jan-Georg Smaus", 
    "arxiv-id": "cs/0012015v2", 
    "title": "Well-Typed Logic Programs Are not Wrong", 
    "publish": "2000-12-20T15:45:32Z", 
    "summary": "We consider prescriptive type systems for logic programs (as in Goedel or\nMercury). In such systems, the typing is static, but it guarantees an\noperational property: if a program is \"well-typed\", then all derivations\nstarting in a \"well-typed\" query are again \"well-typed\". This property has been\ncalled subject reduction. We show that this property can also be phrased as a\nproperty of the proof-theoretic semantics of logic programs, thus abstracting\nfrom the usual operational (top-down) semantics. This proof-theoretic view\nleads us to questioning a condition which is usually considered necessary for\nsubject reduction, namely the head condition. It states that the head of each\nclause must have a type which is a variant (and not a proper instance) of the\ndeclared type. We provide a more general condition, thus reestablishing a\ncertain symmetry between heads and body atoms. The condition ensures that in a\nderivation, the types of two unified terms are themselves unifiable. We discuss\npossible implications of this result. We also discuss the relationship between\nthe head condition and polymorphic recursion, a concept known in functional\nprogramming."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0012015v2", 
    "other_authors": [
        "Pierre Deransart", 
        "Jan-Georg Smaus"
    ], 
    "lead_author": "Jan-Georg Smaus", 
    "arxiv-id": "cs/0012015v2", 
    "title": "Well-Typed Logic Programs Are not Wrong", 
    "publish": "2000-12-20T15:45:32Z", 
    "summary": "We consider prescriptive type systems for logic programs (as in Goedel or\nMercury). In such systems, the typing is static, but it guarantees an\noperational property: if a program is \"well-typed\", then all derivations\nstarting in a \"well-typed\" query are again \"well-typed\". This property has been\ncalled subject reduction. We show that this property can also be phrased as a\nproperty of the proof-theoretic semantics of logic programs, thus abstracting\nfrom the usual operational (top-down) semantics. This proof-theoretic view\nleads us to questioning a condition which is usually considered necessary for\nsubject reduction, namely the head condition. It states that the head of each\nclause must have a type which is a variant (and not a proper instance) of the\ndeclared type. We provide a more general condition, thus reestablishing a\ncertain symmetry between heads and body atoms. The condition ensures that in a\nderivation, the types of two unified terms are themselves unifiable. We discuss\npossible implications of this result. We also discuss the relationship between\nthe head condition and polymorphic recursion, a concept known in functional\nprogramming."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0012015v2", 
    "other_authors": [
        "Pierre Deransart", 
        "Jan-Georg Smaus"
    ], 
    "lead_author": "Jan-Georg Smaus", 
    "arxiv-id": "cs/0012015v2", 
    "title": "Well-Typed Logic Programs Are not Wrong", 
    "publish": "2000-12-20T15:45:32Z", 
    "summary": "We consider prescriptive type systems for logic programs (as in Goedel or\nMercury). In such systems, the typing is static, but it guarantees an\noperational property: if a program is \"well-typed\", then all derivations\nstarting in a \"well-typed\" query are again \"well-typed\". This property has been\ncalled subject reduction. We show that this property can also be phrased as a\nproperty of the proof-theoretic semantics of logic programs, thus abstracting\nfrom the usual operational (top-down) semantics. This proof-theoretic view\nleads us to questioning a condition which is usually considered necessary for\nsubject reduction, namely the head condition. It states that the head of each\nclause must have a type which is a variant (and not a proper instance) of the\ndeclared type. We provide a more general condition, thus reestablishing a\ncertain symmetry between heads and body atoms. The condition ensures that in a\nderivation, the types of two unified terms are themselves unifiable. We discuss\npossible implications of this result. We also discuss the relationship between\nthe head condition and polymorphic recursion, a concept known in functional\nprogramming."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0012015v2", 
    "other_authors": [
        "Pierre Deransart", 
        "Jan-Georg Smaus"
    ], 
    "lead_author": "Jan-Georg Smaus", 
    "arxiv-id": "cs/0012015v2", 
    "title": "Well-Typed Logic Programs Are not Wrong", 
    "publish": "2000-12-20T15:45:32Z", 
    "summary": "We consider prescriptive type systems for logic programs (as in Goedel or\nMercury). In such systems, the typing is static, but it guarantees an\noperational property: if a program is \"well-typed\", then all derivations\nstarting in a \"well-typed\" query are again \"well-typed\". This property has been\ncalled subject reduction. We show that this property can also be phrased as a\nproperty of the proof-theoretic semantics of logic programs, thus abstracting\nfrom the usual operational (top-down) semantics. This proof-theoretic view\nleads us to questioning a condition which is usually considered necessary for\nsubject reduction, namely the head condition. It states that the head of each\nclause must have a type which is a variant (and not a proper instance) of the\ndeclared type. We provide a more general condition, thus reestablishing a\ncertain symmetry between heads and body atoms. The condition ensures that in a\nderivation, the types of two unified terms are themselves unifiable. We discuss\npossible implications of this result. We also discuss the relationship between\nthe head condition and polymorphic recursion, a concept known in functional\nprogramming."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0012015v2", 
    "other_authors": [
        "Pierre Deransart", 
        "Jan-Georg Smaus"
    ], 
    "lead_author": "Jan-Georg Smaus", 
    "arxiv-id": "cs/0012015v2", 
    "title": "Well-Typed Logic Programs Are not Wrong", 
    "publish": "2000-12-20T15:45:32Z", 
    "summary": "We consider prescriptive type systems for logic programs (as in Goedel or\nMercury). In such systems, the typing is static, but it guarantees an\noperational property: if a program is \"well-typed\", then all derivations\nstarting in a \"well-typed\" query are again \"well-typed\". This property has been\ncalled subject reduction. We show that this property can also be phrased as a\nproperty of the proof-theoretic semantics of logic programs, thus abstracting\nfrom the usual operational (top-down) semantics. This proof-theoretic view\nleads us to questioning a condition which is usually considered necessary for\nsubject reduction, namely the head condition. It states that the head of each\nclause must have a type which is a variant (and not a proper instance) of the\ndeclared type. We provide a more general condition, thus reestablishing a\ncertain symmetry between heads and body atoms. The condition ensures that in a\nderivation, the types of two unified terms are themselves unifiable. We discuss\npossible implications of this result. We also discuss the relationship between\nthe head condition and polymorphic recursion, a concept known in functional\nprogramming."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0012015v2", 
    "other_authors": [
        "Pierre Deransart", 
        "Jan-Georg Smaus"
    ], 
    "lead_author": "Jan-Georg Smaus", 
    "arxiv-id": "cs/0012015v2", 
    "title": "Well-Typed Logic Programs Are not Wrong", 
    "publish": "2000-12-20T15:45:32Z", 
    "summary": "We consider prescriptive type systems for logic programs (as in Goedel or\nMercury). In such systems, the typing is static, but it guarantees an\noperational property: if a program is \"well-typed\", then all derivations\nstarting in a \"well-typed\" query are again \"well-typed\". This property has been\ncalled subject reduction. We show that this property can also be phrased as a\nproperty of the proof-theoretic semantics of logic programs, thus abstracting\nfrom the usual operational (top-down) semantics. This proof-theoretic view\nleads us to questioning a condition which is usually considered necessary for\nsubject reduction, namely the head condition. It states that the head of each\nclause must have a type which is a variant (and not a proper instance) of the\ndeclared type. We provide a more general condition, thus reestablishing a\ncertain symmetry between heads and body atoms. The condition ensures that in a\nderivation, the types of two unified terms are themselves unifiable. We discuss\npossible implications of this result. We also discuss the relationship between\nthe head condition and polymorphic recursion, a concept known in functional\nprogramming."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0012015v2", 
    "other_authors": [
        "Pierre Deransart", 
        "Jan-Georg Smaus"
    ], 
    "lead_author": "Jan-Georg Smaus", 
    "arxiv-id": "cs/0012015v2", 
    "title": "Well-Typed Logic Programs Are not Wrong", 
    "publish": "2000-12-20T15:45:32Z", 
    "summary": "We consider prescriptive type systems for logic programs (as in Goedel or\nMercury). In such systems, the typing is static, but it guarantees an\noperational property: if a program is \"well-typed\", then all derivations\nstarting in a \"well-typed\" query are again \"well-typed\". This property has been\ncalled subject reduction. We show that this property can also be phrased as a\nproperty of the proof-theoretic semantics of logic programs, thus abstracting\nfrom the usual operational (top-down) semantics. This proof-theoretic view\nleads us to questioning a condition which is usually considered necessary for\nsubject reduction, namely the head condition. It states that the head of each\nclause must have a type which is a variant (and not a proper instance) of the\ndeclared type. We provide a more general condition, thus reestablishing a\ncertain symmetry between heads and body atoms. The condition ensures that in a\nderivation, the types of two unified terms are themselves unifiable. We discuss\npossible implications of this result. We also discuss the relationship between\nthe head condition and polymorphic recursion, a concept known in functional\nprogramming."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0012015v2", 
    "other_authors": [
        "Pierre Deransart", 
        "Jan-Georg Smaus"
    ], 
    "lead_author": "Jan-Georg Smaus", 
    "arxiv-id": "cs/0012015v2", 
    "title": "Well-Typed Logic Programs Are not Wrong", 
    "publish": "2000-12-20T15:45:32Z", 
    "summary": "We consider prescriptive type systems for logic programs (as in Goedel or\nMercury). In such systems, the typing is static, but it guarantees an\noperational property: if a program is \"well-typed\", then all derivations\nstarting in a \"well-typed\" query are again \"well-typed\". This property has been\ncalled subject reduction. We show that this property can also be phrased as a\nproperty of the proof-theoretic semantics of logic programs, thus abstracting\nfrom the usual operational (top-down) semantics. This proof-theoretic view\nleads us to questioning a condition which is usually considered necessary for\nsubject reduction, namely the head condition. It states that the head of each\nclause must have a type which is a variant (and not a proper instance) of the\ndeclared type. We provide a more general condition, thus reestablishing a\ncertain symmetry between heads and body atoms. The condition ensures that in a\nderivation, the types of two unified terms are themselves unifiable. We discuss\npossible implications of this result. We also discuss the relationship between\nthe head condition and polymorphic recursion, a concept known in functional\nprogramming."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0012018v1", 
    "other_authors": [
        "James Harland", 
        "David Pym"
    ], 
    "lead_author": "James Harland", 
    "arxiv-id": "cs/0012018v1", 
    "title": "Resource-distribution via Boolean constraints", 
    "publish": "2000-12-21T00:24:42Z", 
    "summary": "We consider the problem of searching for proofs in sequential presentations\nof logics with multiplicative (or intensional) connectives. Specifically, we\nstart with the multiplicative fragment of linear logic and extend, on the one\nhand, to linear logic with its additives and, on the other, to the additives of\nthe logic of bunched implications, BI. We give an algebraic method for\ncalculating the distribution of the side-formulae in multiplicative rules which\nallows the occurrence or non-occurrence of a formula on a branch of a proof to\nbe determined once sufficient information is available. Each formula in the\nconclusion of such a rule is assigned a Boolean expression. As a search\nproceeds, a set of Boolean constraint equations is generated. We show that a\nsolution to such a set of equations determines a proof corresponding to the\ngiven search. We explain a range of strategies, from the lazy to the eager, for\nsolving sets of constraint equations. We indicate how to apply our methods\nsystematically to large family of relevant systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0012018v1", 
    "other_authors": [
        "James Harland", 
        "David Pym"
    ], 
    "lead_author": "James Harland", 
    "arxiv-id": "cs/0012018v1", 
    "title": "Resource-distribution via Boolean constraints", 
    "publish": "2000-12-21T00:24:42Z", 
    "summary": "We consider the problem of searching for proofs in sequential presentations\nof logics with multiplicative (or intensional) connectives. Specifically, we\nstart with the multiplicative fragment of linear logic and extend, on the one\nhand, to linear logic with its additives and, on the other, to the additives of\nthe logic of bunched implications, BI. We give an algebraic method for\ncalculating the distribution of the side-formulae in multiplicative rules which\nallows the occurrence or non-occurrence of a formula on a branch of a proof to\nbe determined once sufficient information is available. Each formula in the\nconclusion of such a rule is assigned a Boolean expression. As a search\nproceeds, a set of Boolean constraint equations is generated. We show that a\nsolution to such a set of equations determines a proof corresponding to the\ngiven search. We explain a range of strategies, from the lazy to the eager, for\nsolving sets of constraint equations. We indicate how to apply our methods\nsystematically to large family of relevant systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0012018v1", 
    "other_authors": [
        "James Harland", 
        "David Pym"
    ], 
    "lead_author": "James Harland", 
    "arxiv-id": "cs/0012018v1", 
    "title": "Resource-distribution via Boolean constraints", 
    "publish": "2000-12-21T00:24:42Z", 
    "summary": "We consider the problem of searching for proofs in sequential presentations\nof logics with multiplicative (or intensional) connectives. Specifically, we\nstart with the multiplicative fragment of linear logic and extend, on the one\nhand, to linear logic with its additives and, on the other, to the additives of\nthe logic of bunched implications, BI. We give an algebraic method for\ncalculating the distribution of the side-formulae in multiplicative rules which\nallows the occurrence or non-occurrence of a formula on a branch of a proof to\nbe determined once sufficient information is available. Each formula in the\nconclusion of such a rule is assigned a Boolean expression. As a search\nproceeds, a set of Boolean constraint equations is generated. We show that a\nsolution to such a set of equations determines a proof corresponding to the\ngiven search. We explain a range of strategies, from the lazy to the eager, for\nsolving sets of constraint equations. We indicate how to apply our methods\nsystematically to large family of relevant systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0012018v1", 
    "other_authors": [
        "James Harland", 
        "David Pym"
    ], 
    "lead_author": "James Harland", 
    "arxiv-id": "cs/0012018v1", 
    "title": "Resource-distribution via Boolean constraints", 
    "publish": "2000-12-21T00:24:42Z", 
    "summary": "We consider the problem of searching for proofs in sequential presentations\nof logics with multiplicative (or intensional) connectives. Specifically, we\nstart with the multiplicative fragment of linear logic and extend, on the one\nhand, to linear logic with its additives and, on the other, to the additives of\nthe logic of bunched implications, BI. We give an algebraic method for\ncalculating the distribution of the side-formulae in multiplicative rules which\nallows the occurrence or non-occurrence of a formula on a branch of a proof to\nbe determined once sufficient information is available. Each formula in the\nconclusion of such a rule is assigned a Boolean expression. As a search\nproceeds, a set of Boolean constraint equations is generated. We show that a\nsolution to such a set of equations determines a proof corresponding to the\ngiven search. We explain a range of strategies, from the lazy to the eager, for\nsolving sets of constraint equations. We indicate how to apply our methods\nsystematically to large family of relevant systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0012018v1", 
    "other_authors": [
        "James Harland", 
        "David Pym"
    ], 
    "lead_author": "James Harland", 
    "arxiv-id": "cs/0012018v1", 
    "title": "Resource-distribution via Boolean constraints", 
    "publish": "2000-12-21T00:24:42Z", 
    "summary": "We consider the problem of searching for proofs in sequential presentations\nof logics with multiplicative (or intensional) connectives. Specifically, we\nstart with the multiplicative fragment of linear logic and extend, on the one\nhand, to linear logic with its additives and, on the other, to the additives of\nthe logic of bunched implications, BI. We give an algebraic method for\ncalculating the distribution of the side-formulae in multiplicative rules which\nallows the occurrence or non-occurrence of a formula on a branch of a proof to\nbe determined once sufficient information is available. Each formula in the\nconclusion of such a rule is assigned a Boolean expression. As a search\nproceeds, a set of Boolean constraint equations is generated. We show that a\nsolution to such a set of equations determines a proof corresponding to the\ngiven search. We explain a range of strategies, from the lazy to the eager, for\nsolving sets of constraint equations. We indicate how to apply our methods\nsystematically to large family of relevant systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0012018v1", 
    "other_authors": [
        "James Harland", 
        "David Pym"
    ], 
    "lead_author": "David Pym", 
    "arxiv-id": "cs/0012018v1", 
    "title": "Resource-distribution via Boolean constraints", 
    "publish": "2000-12-21T00:24:42Z", 
    "summary": "We consider the problem of searching for proofs in sequential presentations\nof logics with multiplicative (or intensional) connectives. Specifically, we\nstart with the multiplicative fragment of linear logic and extend, on the one\nhand, to linear logic with its additives and, on the other, to the additives of\nthe logic of bunched implications, BI. We give an algebraic method for\ncalculating the distribution of the side-formulae in multiplicative rules which\nallows the occurrence or non-occurrence of a formula on a branch of a proof to\nbe determined once sufficient information is available. Each formula in the\nconclusion of such a rule is assigned a Boolean expression. As a search\nproceeds, a set of Boolean constraint equations is generated. We show that a\nsolution to such a set of equations determines a proof corresponding to the\ngiven search. We explain a range of strategies, from the lazy to the eager, for\nsolving sets of constraint equations. We indicate how to apply our methods\nsystematically to large family of relevant systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0012018v1", 
    "other_authors": [
        "James Harland", 
        "David Pym"
    ], 
    "lead_author": "David Pym", 
    "arxiv-id": "cs/0012018v1", 
    "title": "Resource-distribution via Boolean constraints", 
    "publish": "2000-12-21T00:24:42Z", 
    "summary": "We consider the problem of searching for proofs in sequential presentations\nof logics with multiplicative (or intensional) connectives. Specifically, we\nstart with the multiplicative fragment of linear logic and extend, on the one\nhand, to linear logic with its additives and, on the other, to the additives of\nthe logic of bunched implications, BI. We give an algebraic method for\ncalculating the distribution of the side-formulae in multiplicative rules which\nallows the occurrence or non-occurrence of a formula on a branch of a proof to\nbe determined once sufficient information is available. Each formula in the\nconclusion of such a rule is assigned a Boolean expression. As a search\nproceeds, a set of Boolean constraint equations is generated. We show that a\nsolution to such a set of equations determines a proof corresponding to the\ngiven search. We explain a range of strategies, from the lazy to the eager, for\nsolving sets of constraint equations. We indicate how to apply our methods\nsystematically to large family of relevant systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0012018v1", 
    "other_authors": [
        "James Harland", 
        "David Pym"
    ], 
    "lead_author": "David Pym", 
    "arxiv-id": "cs/0012018v1", 
    "title": "Resource-distribution via Boolean constraints", 
    "publish": "2000-12-21T00:24:42Z", 
    "summary": "We consider the problem of searching for proofs in sequential presentations\nof logics with multiplicative (or intensional) connectives. Specifically, we\nstart with the multiplicative fragment of linear logic and extend, on the one\nhand, to linear logic with its additives and, on the other, to the additives of\nthe logic of bunched implications, BI. We give an algebraic method for\ncalculating the distribution of the side-formulae in multiplicative rules which\nallows the occurrence or non-occurrence of a formula on a branch of a proof to\nbe determined once sufficient information is available. Each formula in the\nconclusion of such a rule is assigned a Boolean expression. As a search\nproceeds, a set of Boolean constraint equations is generated. We show that a\nsolution to such a set of equations determines a proof corresponding to the\ngiven search. We explain a range of strategies, from the lazy to the eager, for\nsolving sets of constraint equations. We indicate how to apply our methods\nsystematically to large family of relevant systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0012018v1", 
    "other_authors": [
        "James Harland", 
        "David Pym"
    ], 
    "lead_author": "David Pym", 
    "arxiv-id": "cs/0012018v1", 
    "title": "Resource-distribution via Boolean constraints", 
    "publish": "2000-12-21T00:24:42Z", 
    "summary": "We consider the problem of searching for proofs in sequential presentations\nof logics with multiplicative (or intensional) connectives. Specifically, we\nstart with the multiplicative fragment of linear logic and extend, on the one\nhand, to linear logic with its additives and, on the other, to the additives of\nthe logic of bunched implications, BI. We give an algebraic method for\ncalculating the distribution of the side-formulae in multiplicative rules which\nallows the occurrence or non-occurrence of a formula on a branch of a proof to\nbe determined once sufficient information is available. Each formula in the\nconclusion of such a rule is assigned a Boolean expression. As a search\nproceeds, a set of Boolean constraint equations is generated. We show that a\nsolution to such a set of equations determines a proof corresponding to the\ngiven search. We explain a range of strategies, from the lazy to the eager, for\nsolving sets of constraint equations. We indicate how to apply our methods\nsystematically to large family of relevant systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Rupak Majumdar", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Rupak Majumdar", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Rupak Majumdar", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Rupak Majumdar", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Rupak Majumdar", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Rupak Majumdar", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Rupak Majumdar", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Rupak Majumdar", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Rupak Majumdar", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Rupak Majumdar", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Rupak Majumdar", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Rupak Majumdar", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Rupak Majumdar", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Rupak Majumdar", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Rupak Majumdar", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Rupak Majumdar", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Rupak Majumdar", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Rupak Majumdar", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Rupak Majumdar", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Rupak Majumdar", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Rupak Majumdar", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Rupak Majumdar", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Rupak Majumdar", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Rupak Majumdar", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Rupak Majumdar", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Rupak Majumdar", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Rupak Majumdar", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Rupak Majumdar", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Rupak Majumdar", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Rupak Majumdar", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Rupak Majumdar", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Rupak Majumdar", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Rupak Majumdar", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Rupak Majumdar", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Rupak Majumdar", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Rupak Majumdar", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Rupak Majumdar", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Rupak Majumdar", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Rupak Majumdar", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Rupak Majumdar", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Rupak Majumdar", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Rupak Majumdar", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Rupak Majumdar", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Rupak Majumdar", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Rupak Majumdar", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Jean-Francois Raskin", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Jean-Francois Raskin", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Jean-Francois Raskin", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Jean-Francois Raskin", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Jean-Francois Raskin", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Jean-Francois Raskin", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Jean-Francois Raskin", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Jean-Francois Raskin", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Jean-Francois Raskin", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Jean-Francois Raskin", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Jean-Francois Raskin", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Jean-Francois Raskin", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Jean-Francois Raskin", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Jean-Francois Raskin", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Jean-Francois Raskin", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Jean-Francois Raskin", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Jean-Francois Raskin", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Jean-Francois Raskin", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Jean-Francois Raskin", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Jean-Francois Raskin", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Jean-Francois Raskin", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Jean-Francois Raskin", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Jean-Francois Raskin", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Jean-Francois Raskin", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Jean-Francois Raskin", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Jean-Francois Raskin", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Jean-Francois Raskin", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Jean-Francois Raskin", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Jean-Francois Raskin", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Jean-Francois Raskin", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Jean-Francois Raskin", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Jean-Francois Raskin", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Jean-Francois Raskin", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Jean-Francois Raskin", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Jean-Francois Raskin", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Jean-Francois Raskin", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Jean-Francois Raskin", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Jean-Francois Raskin", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Jean-Francois Raskin", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Jean-Francois Raskin", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Jean-Francois Raskin", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Jean-Francois Raskin", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Jean-Francois Raskin", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Jean-Francois Raskin", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Jean-Francois Raskin", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Jean-Francois Raskin", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Jean-Francois Raskin", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Jean-Francois Raskin", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Jean-Francois Raskin", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Jean-Francois Raskin", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Jean-Francois Raskin", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Jean-Francois Raskin", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Jean-Francois Raskin", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Jean-Francois Raskin", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Jean-Francois Raskin", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Jean-Francois Raskin", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Jean-Francois Raskin", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Jean-Francois Raskin", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Jean-Francois Raskin", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Jean-Francois Raskin", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Jean-Francois Raskin", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Jean-Francois Raskin", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Jean-Francois Raskin", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Jean-Francois Raskin", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101013v1", 
    "other_authors": [
        "Thomas A. Henzinger", 
        "Rupak Majumdar", 
        "Jean-Francois Raskin"
    ], 
    "lead_author": "Jean-Francois Raskin", 
    "arxiv-id": "cs/0101013v1", 
    "title": "A Classification of Symbolic Transition Systems", 
    "publish": "2001-01-16T20:17:30Z", 
    "summary": "We define five increasingly comprehensive classes of infinite-state systems,\ncalled STS1--5, whose state spaces have finitary structure. For four of these\nclasses, we provide examples from hybrid systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101017v1", 
    "other_authors": [
        "Ulrich Ultes-Nitsche", 
        "Pierre Wolper"
    ], 
    "lead_author": "Pierre Wolper", 
    "arxiv-id": "cs/0101017v1", 
    "title": "Checking Properties within Fairness and Behavior Abstractions", 
    "publish": "2001-01-19T09:35:10Z", 
    "summary": "This paper is motivated by the fact that verifying liveness properties under\na fairness condition is often problematic, especially when abstraction is used.\nIt shows that using a more abstract notion than truth under fairness,\nspecifically the concept of a property being satisfied within fairness can lead\nto interesting possibilities. Technically, it is first established that\ndeciding satisfaction within fairness is a PSPACE-complete problem and it is\nshown that properties satisfied within fairness can always be satisfied by some\nfair implementation. Thereafter, the interaction between behavior abstraction\nand satisfaction within fairness is studied and it is proved that satisfaction\nof properties within fairness can be verified on behavior abstractions, if the\nabstraction homomorphism is weakly continuation-closed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101017v1", 
    "other_authors": [
        "Ulrich Ultes-Nitsche", 
        "Pierre Wolper"
    ], 
    "lead_author": "Pierre Wolper", 
    "arxiv-id": "cs/0101017v1", 
    "title": "Checking Properties within Fairness and Behavior Abstractions", 
    "publish": "2001-01-19T09:35:10Z", 
    "summary": "This paper is motivated by the fact that verifying liveness properties under\na fairness condition is often problematic, especially when abstraction is used.\nIt shows that using a more abstract notion than truth under fairness,\nspecifically the concept of a property being satisfied within fairness can lead\nto interesting possibilities. Technically, it is first established that\ndeciding satisfaction within fairness is a PSPACE-complete problem and it is\nshown that properties satisfied within fairness can always be satisfied by some\nfair implementation. Thereafter, the interaction between behavior abstraction\nand satisfaction within fairness is studied and it is proved that satisfaction\nof properties within fairness can be verified on behavior abstractions, if the\nabstraction homomorphism is weakly continuation-closed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101017v1", 
    "other_authors": [
        "Ulrich Ultes-Nitsche", 
        "Pierre Wolper"
    ], 
    "lead_author": "Pierre Wolper", 
    "arxiv-id": "cs/0101017v1", 
    "title": "Checking Properties within Fairness and Behavior Abstractions", 
    "publish": "2001-01-19T09:35:10Z", 
    "summary": "This paper is motivated by the fact that verifying liveness properties under\na fairness condition is often problematic, especially when abstraction is used.\nIt shows that using a more abstract notion than truth under fairness,\nspecifically the concept of a property being satisfied within fairness can lead\nto interesting possibilities. Technically, it is first established that\ndeciding satisfaction within fairness is a PSPACE-complete problem and it is\nshown that properties satisfied within fairness can always be satisfied by some\nfair implementation. Thereafter, the interaction between behavior abstraction\nand satisfaction within fairness is studied and it is proved that satisfaction\nof properties within fairness can be verified on behavior abstractions, if the\nabstraction homomorphism is weakly continuation-closed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0101017v1", 
    "other_authors": [
        "Ulrich Ultes-Nitsche", 
        "Pierre Wolper"
    ], 
    "lead_author": "Pierre Wolper", 
    "arxiv-id": "cs/0101017v1", 
    "title": "Checking Properties within Fairness and Behavior Abstractions", 
    "publish": "2001-01-19T09:35:10Z", 
    "summary": "This paper is motivated by the fact that verifying liveness properties under\na fairness condition is often problematic, especially when abstraction is used.\nIt shows that using a more abstract notion than truth under fairness,\nspecifically the concept of a property being satisfied within fairness can lead\nto interesting possibilities. Technically, it is first established that\ndeciding satisfaction within fairness is a PSPACE-complete problem and it is\nshown that properties satisfied within fairness can always be satisfied by some\nfair implementation. Thereafter, the interaction between behavior abstraction\nand satisfaction within fairness is studied and it is proved that satisfaction\nof properties within fairness can be verified on behavior abstractions, if the\nabstraction homomorphism is weakly continuation-closed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0104021v2", 
    "other_authors": [
        "Matthew Stone"
    ], 
    "lead_author": "Matthew Stone", 
    "arxiv-id": "cs/0104021v2", 
    "title": "Disjunction and modular goal-directed proof search", 
    "publish": "2001-04-30T14:23:50Z", 
    "summary": "This paper explores goal-directed proof search in first-order multi-modal\nlogic. The key issue is to design a proof system that respects the modularity\nand locality of assumptions of many modal logics. By forcing ambiguities to be\nconsidered independently, modular disjunctions in particular can be used to\nconstruct efficiently executable specifications in reasoning tasks involving\npartial information that otherwise might require prohibitive search. To achieve\nthis behavior requires prior proof-theoretic justifications of logic\nprogramming to be extended, strengthened, and combined with proof-theoretic\nanalyses of modal deduction in a novel way."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0105007v1", 
    "other_authors": [
        "Jan-Georg Smaus"
    ], 
    "lead_author": "Jan-Georg Smaus", 
    "arxiv-id": "cs/0105007v1", 
    "title": "Analysis of Polymorphically Typed Logic Programs Using ACI-Unification", 
    "publish": "2001-05-04T10:33:39Z", 
    "summary": "Analysis of (partial) groundness is an important application of abstract\ninterpretation. There are several proposals for improving the precision of such\nan analysis by exploiting type information, icluding our own work with Hill and\nKing, where we had shown how the information present in the type declarations\nof a program can be used to characterise the degree of instantiation of a term\nin a precise and yet inherently finite way. This approach worked for\npolymorphically typed programs as in Goedel or HAL. Here, we recast this\napproach following works by Codish, Lagoon and Stuckey. To formalise which\nproperties of terms we want to characterise, we use labelling functions, which\nare functions that extract subterms from a term along certain paths. An\nabstract term collects the results of all labelling functions of a term. For\nthe analysis, programs are executed on abstract terms instead of the concrete\nones, and usual unification is replaced by unification modulo an equality\ntheory which includes the well-known ACI-theory. Thus we generalise the works\nby Codish, Lagoon and Stuckey w.r.t. the type systems considered and relate the\nworks among each other."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0105007v1", 
    "other_authors": [
        "Jan-Georg Smaus"
    ], 
    "lead_author": "Jan-Georg Smaus", 
    "arxiv-id": "cs/0105007v1", 
    "title": "Analysis of Polymorphically Typed Logic Programs Using ACI-Unification", 
    "publish": "2001-05-04T10:33:39Z", 
    "summary": "Analysis of (partial) groundness is an important application of abstract\ninterpretation. There are several proposals for improving the precision of such\nan analysis by exploiting type information, icluding our own work with Hill and\nKing, where we had shown how the information present in the type declarations\nof a program can be used to characterise the degree of instantiation of a term\nin a precise and yet inherently finite way. This approach worked for\npolymorphically typed programs as in Goedel or HAL. Here, we recast this\napproach following works by Codish, Lagoon and Stuckey. To formalise which\nproperties of terms we want to characterise, we use labelling functions, which\nare functions that extract subterms from a term along certain paths. An\nabstract term collects the results of all labelling functions of a term. For\nthe analysis, programs are executed on abstract terms instead of the concrete\nones, and usual unification is replaced by unification modulo an equality\ntheory which includes the well-known ACI-theory. Thus we generalise the works\nby Codish, Lagoon and Stuckey w.r.t. the type systems considered and relate the\nworks among each other."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0105007v1", 
    "other_authors": [
        "Jan-Georg Smaus"
    ], 
    "lead_author": "Jan-Georg Smaus", 
    "arxiv-id": "cs/0105007v1", 
    "title": "Analysis of Polymorphically Typed Logic Programs Using ACI-Unification", 
    "publish": "2001-05-04T10:33:39Z", 
    "summary": "Analysis of (partial) groundness is an important application of abstract\ninterpretation. There are several proposals for improving the precision of such\nan analysis by exploiting type information, icluding our own work with Hill and\nKing, where we had shown how the information present in the type declarations\nof a program can be used to characterise the degree of instantiation of a term\nin a precise and yet inherently finite way. This approach worked for\npolymorphically typed programs as in Goedel or HAL. Here, we recast this\napproach following works by Codish, Lagoon and Stuckey. To formalise which\nproperties of terms we want to characterise, we use labelling functions, which\nare functions that extract subterms from a term along certain paths. An\nabstract term collects the results of all labelling functions of a term. For\nthe analysis, programs are executed on abstract terms instead of the concrete\nones, and usual unification is replaced by unification modulo an equality\ntheory which includes the well-known ACI-theory. Thus we generalise the works\nby Codish, Lagoon and Stuckey w.r.t. the type systems considered and relate the\nworks among each other."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0105007v1", 
    "other_authors": [
        "Jan-Georg Smaus"
    ], 
    "lead_author": "Jan-Georg Smaus", 
    "arxiv-id": "cs/0105007v1", 
    "title": "Analysis of Polymorphically Typed Logic Programs Using ACI-Unification", 
    "publish": "2001-05-04T10:33:39Z", 
    "summary": "Analysis of (partial) groundness is an important application of abstract\ninterpretation. There are several proposals for improving the precision of such\nan analysis by exploiting type information, icluding our own work with Hill and\nKing, where we had shown how the information present in the type declarations\nof a program can be used to characterise the degree of instantiation of a term\nin a precise and yet inherently finite way. This approach worked for\npolymorphically typed programs as in Goedel or HAL. Here, we recast this\napproach following works by Codish, Lagoon and Stuckey. To formalise which\nproperties of terms we want to characterise, we use labelling functions, which\nare functions that extract subterms from a term along certain paths. An\nabstract term collects the results of all labelling functions of a term. For\nthe analysis, programs are executed on abstract terms instead of the concrete\nones, and usual unification is replaced by unification modulo an equality\ntheory which includes the well-known ACI-theory. Thus we generalise the works\nby Codish, Lagoon and Stuckey w.r.t. the type systems considered and relate the\nworks among each other."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0105007v1", 
    "other_authors": [
        "Jan-Georg Smaus"
    ], 
    "lead_author": "Jan-Georg Smaus", 
    "arxiv-id": "cs/0105007v1", 
    "title": "Analysis of Polymorphically Typed Logic Programs Using ACI-Unification", 
    "publish": "2001-05-04T10:33:39Z", 
    "summary": "Analysis of (partial) groundness is an important application of abstract\ninterpretation. There are several proposals for improving the precision of such\nan analysis by exploiting type information, icluding our own work with Hill and\nKing, where we had shown how the information present in the type declarations\nof a program can be used to characterise the degree of instantiation of a term\nin a precise and yet inherently finite way. This approach worked for\npolymorphically typed programs as in Goedel or HAL. Here, we recast this\napproach following works by Codish, Lagoon and Stuckey. To formalise which\nproperties of terms we want to characterise, we use labelling functions, which\nare functions that extract subterms from a term along certain paths. An\nabstract term collects the results of all labelling functions of a term. For\nthe analysis, programs are executed on abstract terms instead of the concrete\nones, and usual unification is replaced by unification modulo an equality\ntheory which includes the well-known ACI-theory. Thus we generalise the works\nby Codish, Lagoon and Stuckey w.r.t. the type systems considered and relate the\nworks among each other."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0105007v1", 
    "other_authors": [
        "Jan-Georg Smaus"
    ], 
    "lead_author": "Jan-Georg Smaus", 
    "arxiv-id": "cs/0105007v1", 
    "title": "Analysis of Polymorphically Typed Logic Programs Using ACI-Unification", 
    "publish": "2001-05-04T10:33:39Z", 
    "summary": "Analysis of (partial) groundness is an important application of abstract\ninterpretation. There are several proposals for improving the precision of such\nan analysis by exploiting type information, icluding our own work with Hill and\nKing, where we had shown how the information present in the type declarations\nof a program can be used to characterise the degree of instantiation of a term\nin a precise and yet inherently finite way. This approach worked for\npolymorphically typed programs as in Goedel or HAL. Here, we recast this\napproach following works by Codish, Lagoon and Stuckey. To formalise which\nproperties of terms we want to characterise, we use labelling functions, which\nare functions that extract subterms from a term along certain paths. An\nabstract term collects the results of all labelling functions of a term. For\nthe analysis, programs are executed on abstract terms instead of the concrete\nones, and usual unification is replaced by unification modulo an equality\ntheory which includes the well-known ACI-theory. Thus we generalise the works\nby Codish, Lagoon and Stuckey w.r.t. the type systems considered and relate the\nworks among each other."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0105007v1", 
    "other_authors": [
        "Jan-Georg Smaus"
    ], 
    "lead_author": "Jan-Georg Smaus", 
    "arxiv-id": "cs/0105007v1", 
    "title": "Analysis of Polymorphically Typed Logic Programs Using ACI-Unification", 
    "publish": "2001-05-04T10:33:39Z", 
    "summary": "Analysis of (partial) groundness is an important application of abstract\ninterpretation. There are several proposals for improving the precision of such\nan analysis by exploiting type information, icluding our own work with Hill and\nKing, where we had shown how the information present in the type declarations\nof a program can be used to characterise the degree of instantiation of a term\nin a precise and yet inherently finite way. This approach worked for\npolymorphically typed programs as in Goedel or HAL. Here, we recast this\napproach following works by Codish, Lagoon and Stuckey. To formalise which\nproperties of terms we want to characterise, we use labelling functions, which\nare functions that extract subterms from a term along certain paths. An\nabstract term collects the results of all labelling functions of a term. For\nthe analysis, programs are executed on abstract terms instead of the concrete\nones, and usual unification is replaced by unification modulo an equality\ntheory which includes the well-known ACI-theory. Thus we generalise the works\nby Codish, Lagoon and Stuckey w.r.t. the type systems considered and relate the\nworks among each other."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0105007v1", 
    "other_authors": [
        "Jan-Georg Smaus"
    ], 
    "lead_author": "Jan-Georg Smaus", 
    "arxiv-id": "cs/0105007v1", 
    "title": "Analysis of Polymorphically Typed Logic Programs Using ACI-Unification", 
    "publish": "2001-05-04T10:33:39Z", 
    "summary": "Analysis of (partial) groundness is an important application of abstract\ninterpretation. There are several proposals for improving the precision of such\nan analysis by exploiting type information, icluding our own work with Hill and\nKing, where we had shown how the information present in the type declarations\nof a program can be used to characterise the degree of instantiation of a term\nin a precise and yet inherently finite way. This approach worked for\npolymorphically typed programs as in Goedel or HAL. Here, we recast this\napproach following works by Codish, Lagoon and Stuckey. To formalise which\nproperties of terms we want to characterise, we use labelling functions, which\nare functions that extract subterms from a term along certain paths. An\nabstract term collects the results of all labelling functions of a term. For\nthe analysis, programs are executed on abstract terms instead of the concrete\nones, and usual unification is replaced by unification modulo an equality\ntheory which includes the well-known ACI-theory. Thus we generalise the works\nby Codish, Lagoon and Stuckey w.r.t. the type systems considered and relate the\nworks among each other."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0108007v1", 
    "other_authors": [
        "J. V. Tucker", 
        "J. I. Zucker"
    ], 
    "lead_author": "J. I. Zucker", 
    "arxiv-id": "cs/0108007v1", 
    "title": "Abstract versus Concrete Computation on Metric Partial Algebras", 
    "publish": "2001-08-12T21:25:13Z", 
    "summary": "A model of computation is abstract if, when applied to any algebra, the\nresulting programs for computable functions and sets on that algebra are\ninvariant under isomorphisms, and hence do not depend on a representation for\nthe algebra. Otherwise it is concrete. Intuitively, concrete models depend on\nthe implementation of the algebra.\n  The difference is particularly striking in the case of topological partial\nalgebras, and notably in algebras over the reals. We investigate the\nrelationship between abstract and concrete models of partial metric algebras.\nIn the course of this investigation, interesting aspects of continuity,\nextensionality and non-determinism are uncovered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0108007v1", 
    "other_authors": [
        "J. V. Tucker", 
        "J. I. Zucker"
    ], 
    "lead_author": "J. I. Zucker", 
    "arxiv-id": "cs/0108007v1", 
    "title": "Abstract versus Concrete Computation on Metric Partial Algebras", 
    "publish": "2001-08-12T21:25:13Z", 
    "summary": "A model of computation is abstract if, when applied to any algebra, the\nresulting programs for computable functions and sets on that algebra are\ninvariant under isomorphisms, and hence do not depend on a representation for\nthe algebra. Otherwise it is concrete. Intuitively, concrete models depend on\nthe implementation of the algebra.\n  The difference is particularly striking in the case of topological partial\nalgebras, and notably in algebras over the reals. We investigate the\nrelationship between abstract and concrete models of partial metric algebras.\nIn the course of this investigation, interesting aspects of continuity,\nextensionality and non-determinism are uncovered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0108007v1", 
    "other_authors": [
        "J. V. Tucker", 
        "J. I. Zucker"
    ], 
    "lead_author": "J. I. Zucker", 
    "arxiv-id": "cs/0108007v1", 
    "title": "Abstract versus Concrete Computation on Metric Partial Algebras", 
    "publish": "2001-08-12T21:25:13Z", 
    "summary": "A model of computation is abstract if, when applied to any algebra, the\nresulting programs for computable functions and sets on that algebra are\ninvariant under isomorphisms, and hence do not depend on a representation for\nthe algebra. Otherwise it is concrete. Intuitively, concrete models depend on\nthe implementation of the algebra.\n  The difference is particularly striking in the case of topological partial\nalgebras, and notably in algebras over the reals. We investigate the\nrelationship between abstract and concrete models of partial metric algebras.\nIn the course of this investigation, interesting aspects of continuity,\nextensionality and non-determinism are uncovered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0109001v1", 
    "other_authors": [
        "J. V. Tucker", 
        "J. I. Zucker"
    ], 
    "lead_author": "J. I. Zucker", 
    "arxiv-id": "cs/0109001v1", 
    "title": "Abstract Computability, Algebraic Specification and Initiality", 
    "publish": "2001-09-02T18:52:51Z", 
    "summary": "computable functions are defined by abstract finite deterministic algorithms\non many-sorted algebras. We show that there exist finite universal algebraic\nspecifications that specify uniquely (up to isomorphism) (i) all abstract\ncomputable functions on any many-sorted algebra; and (ii) all functions\neffectively approximable by abstract computable functions on any metric\nalgebra.\n  We show that there exist universal algebraic specifications for all the\nclassically computable functions on the set R of real numbers. The algebraic\nspecifications used are mainly bounded universal equations and conditional\nequations. We investigate the initial algebra semantics of these\nspecifications, and derive situations where algebraic specifications define\nprecisely the computable functions."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0109001v1", 
    "other_authors": [
        "J. V. Tucker", 
        "J. I. Zucker"
    ], 
    "lead_author": "J. I. Zucker", 
    "arxiv-id": "cs/0109001v1", 
    "title": "Abstract Computability, Algebraic Specification and Initiality", 
    "publish": "2001-09-02T18:52:51Z", 
    "summary": "computable functions are defined by abstract finite deterministic algorithms\non many-sorted algebras. We show that there exist finite universal algebraic\nspecifications that specify uniquely (up to isomorphism) (i) all abstract\ncomputable functions on any many-sorted algebra; and (ii) all functions\neffectively approximable by abstract computable functions on any metric\nalgebra.\n  We show that there exist universal algebraic specifications for all the\nclassically computable functions on the set R of real numbers. The algebraic\nspecifications used are mainly bounded universal equations and conditional\nequations. We investigate the initial algebra semantics of these\nspecifications, and derive situations where algebraic specifications define\nprecisely the computable functions."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0109001v1", 
    "other_authors": [
        "J. V. Tucker", 
        "J. I. Zucker"
    ], 
    "lead_author": "J. I. Zucker", 
    "arxiv-id": "cs/0109001v1", 
    "title": "Abstract Computability, Algebraic Specification and Initiality", 
    "publish": "2001-09-02T18:52:51Z", 
    "summary": "computable functions are defined by abstract finite deterministic algorithms\non many-sorted algebras. We show that there exist finite universal algebraic\nspecifications that specify uniquely (up to isomorphism) (i) all abstract\ncomputable functions on any many-sorted algebra; and (ii) all functions\neffectively approximable by abstract computable functions on any metric\nalgebra.\n  We show that there exist universal algebraic specifications for all the\nclassically computable functions on the set R of real numbers. The algebraic\nspecifications used are mainly bounded universal equations and conditional\nequations. We investigate the initial algebra semantics of these\nspecifications, and derive situations where algebraic specifications define\nprecisely the computable functions."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0110010v1", 
    "other_authors": [
        "Zhe Dang"
    ], 
    "lead_author": "Zhe Dang", 
    "arxiv-id": "cs/0110010v1", 
    "title": "Pushdown Timed Automata: a Binary Reachability Characterization and   Safety Verification", 
    "publish": "2001-10-02T22:47:41Z", 
    "summary": "We consider pushdown timed automata (PTAs) that are timed automata (with\ndense clocks) augmented with a pushdown stack. A configuration of a PTA\nincludes a control state, dense clock values and a stack word. By using the\npattern technique, we give a decidable characterization of the binary\nreachability (i.e., the set of all pairs of configurations such that one can\nreach the other) of a PTA. Since a timed automaton can be treated as a PTA\nwithout the pushdown stack, we can show that the binary reachability of a timed\nautomaton is definable in the additive theory of reals and integers. The\nresults can be used to verify a class of properties containing linear relations\nover both dense variables and unbounded discrete variables. The properties\npreviously could not be verified using the classic region technique nor\nexpressed by timed temporal logics for timed automata and CTL$^*$ for pushdown\nsystems. The results are also extended to other generalizations of timed\nautomata."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0110010v1", 
    "other_authors": [
        "Zhe Dang"
    ], 
    "lead_author": "Zhe Dang", 
    "arxiv-id": "cs/0110010v1", 
    "title": "Pushdown Timed Automata: a Binary Reachability Characterization and   Safety Verification", 
    "publish": "2001-10-02T22:47:41Z", 
    "summary": "We consider pushdown timed automata (PTAs) that are timed automata (with\ndense clocks) augmented with a pushdown stack. A configuration of a PTA\nincludes a control state, dense clock values and a stack word. By using the\npattern technique, we give a decidable characterization of the binary\nreachability (i.e., the set of all pairs of configurations such that one can\nreach the other) of a PTA. Since a timed automaton can be treated as a PTA\nwithout the pushdown stack, we can show that the binary reachability of a timed\nautomaton is definable in the additive theory of reals and integers. The\nresults can be used to verify a class of properties containing linear relations\nover both dense variables and unbounded discrete variables. The properties\npreviously could not be verified using the classic region technique nor\nexpressed by timed temporal logics for timed automata and CTL$^*$ for pushdown\nsystems. The results are also extended to other generalizations of timed\nautomata."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0110010v1", 
    "other_authors": [
        "Zhe Dang"
    ], 
    "lead_author": "Zhe Dang", 
    "arxiv-id": "cs/0110010v1", 
    "title": "Pushdown Timed Automata: a Binary Reachability Characterization and   Safety Verification", 
    "publish": "2001-10-02T22:47:41Z", 
    "summary": "We consider pushdown timed automata (PTAs) that are timed automata (with\ndense clocks) augmented with a pushdown stack. A configuration of a PTA\nincludes a control state, dense clock values and a stack word. By using the\npattern technique, we give a decidable characterization of the binary\nreachability (i.e., the set of all pairs of configurations such that one can\nreach the other) of a PTA. Since a timed automaton can be treated as a PTA\nwithout the pushdown stack, we can show that the binary reachability of a timed\nautomaton is definable in the additive theory of reals and integers. The\nresults can be used to verify a class of properties containing linear relations\nover both dense variables and unbounded discrete variables. The properties\npreviously could not be verified using the classic region technique nor\nexpressed by timed temporal logics for timed automata and CTL$^*$ for pushdown\nsystems. The results are also extended to other generalizations of timed\nautomata."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0110010v1", 
    "other_authors": [
        "Zhe Dang"
    ], 
    "lead_author": "Zhe Dang", 
    "arxiv-id": "cs/0110010v1", 
    "title": "Pushdown Timed Automata: a Binary Reachability Characterization and   Safety Verification", 
    "publish": "2001-10-02T22:47:41Z", 
    "summary": "We consider pushdown timed automata (PTAs) that are timed automata (with\ndense clocks) augmented with a pushdown stack. A configuration of a PTA\nincludes a control state, dense clock values and a stack word. By using the\npattern technique, we give a decidable characterization of the binary\nreachability (i.e., the set of all pairs of configurations such that one can\nreach the other) of a PTA. Since a timed automaton can be treated as a PTA\nwithout the pushdown stack, we can show that the binary reachability of a timed\nautomaton is definable in the additive theory of reals and integers. The\nresults can be used to verify a class of properties containing linear relations\nover both dense variables and unbounded discrete variables. The properties\npreviously could not be verified using the classic region technique nor\nexpressed by timed temporal logics for timed automata and CTL$^*$ for pushdown\nsystems. The results are also extended to other generalizations of timed\nautomata."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0110010v1", 
    "other_authors": [
        "Zhe Dang"
    ], 
    "lead_author": "Zhe Dang", 
    "arxiv-id": "cs/0110010v1", 
    "title": "Pushdown Timed Automata: a Binary Reachability Characterization and   Safety Verification", 
    "publish": "2001-10-02T22:47:41Z", 
    "summary": "We consider pushdown timed automata (PTAs) that are timed automata (with\ndense clocks) augmented with a pushdown stack. A configuration of a PTA\nincludes a control state, dense clock values and a stack word. By using the\npattern technique, we give a decidable characterization of the binary\nreachability (i.e., the set of all pairs of configurations such that one can\nreach the other) of a PTA. Since a timed automaton can be treated as a PTA\nwithout the pushdown stack, we can show that the binary reachability of a timed\nautomaton is definable in the additive theory of reals and integers. The\nresults can be used to verify a class of properties containing linear relations\nover both dense variables and unbounded discrete variables. The properties\npreviously could not be verified using the classic region technique nor\nexpressed by timed temporal logics for timed automata and CTL$^*$ for pushdown\nsystems. The results are also extended to other generalizations of timed\nautomata."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0110010v1", 
    "other_authors": [
        "Zhe Dang"
    ], 
    "lead_author": "Zhe Dang", 
    "arxiv-id": "cs/0110010v1", 
    "title": "Pushdown Timed Automata: a Binary Reachability Characterization and   Safety Verification", 
    "publish": "2001-10-02T22:47:41Z", 
    "summary": "We consider pushdown timed automata (PTAs) that are timed automata (with\ndense clocks) augmented with a pushdown stack. A configuration of a PTA\nincludes a control state, dense clock values and a stack word. By using the\npattern technique, we give a decidable characterization of the binary\nreachability (i.e., the set of all pairs of configurations such that one can\nreach the other) of a PTA. Since a timed automaton can be treated as a PTA\nwithout the pushdown stack, we can show that the binary reachability of a timed\nautomaton is definable in the additive theory of reals and integers. The\nresults can be used to verify a class of properties containing linear relations\nover both dense variables and unbounded discrete variables. The properties\npreviously could not be verified using the classic region technique nor\nexpressed by timed temporal logics for timed automata and CTL$^*$ for pushdown\nsystems. The results are also extended to other generalizations of timed\nautomata."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0110010v1", 
    "other_authors": [
        "Zhe Dang"
    ], 
    "lead_author": "Zhe Dang", 
    "arxiv-id": "cs/0110010v1", 
    "title": "Pushdown Timed Automata: a Binary Reachability Characterization and   Safety Verification", 
    "publish": "2001-10-02T22:47:41Z", 
    "summary": "We consider pushdown timed automata (PTAs) that are timed automata (with\ndense clocks) augmented with a pushdown stack. A configuration of a PTA\nincludes a control state, dense clock values and a stack word. By using the\npattern technique, we give a decidable characterization of the binary\nreachability (i.e., the set of all pairs of configurations such that one can\nreach the other) of a PTA. Since a timed automaton can be treated as a PTA\nwithout the pushdown stack, we can show that the binary reachability of a timed\nautomaton is definable in the additive theory of reals and integers. The\nresults can be used to verify a class of properties containing linear relations\nover both dense variables and unbounded discrete variables. The properties\npreviously could not be verified using the classic region technique nor\nexpressed by timed temporal logics for timed automata and CTL$^*$ for pushdown\nsystems. The results are also extended to other generalizations of timed\nautomata."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0110010v1", 
    "other_authors": [
        "Zhe Dang"
    ], 
    "lead_author": "Zhe Dang", 
    "arxiv-id": "cs/0110010v1", 
    "title": "Pushdown Timed Automata: a Binary Reachability Characterization and   Safety Verification", 
    "publish": "2001-10-02T22:47:41Z", 
    "summary": "We consider pushdown timed automata (PTAs) that are timed automata (with\ndense clocks) augmented with a pushdown stack. A configuration of a PTA\nincludes a control state, dense clock values and a stack word. By using the\npattern technique, we give a decidable characterization of the binary\nreachability (i.e., the set of all pairs of configurations such that one can\nreach the other) of a PTA. Since a timed automaton can be treated as a PTA\nwithout the pushdown stack, we can show that the binary reachability of a timed\nautomaton is definable in the additive theory of reals and integers. The\nresults can be used to verify a class of properties containing linear relations\nover both dense variables and unbounded discrete variables. The properties\npreviously could not be verified using the classic region technique nor\nexpressed by timed temporal logics for timed automata and CTL$^*$ for pushdown\nsystems. The results are also extended to other generalizations of timed\nautomata."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0110028v1", 
    "other_authors": [
        "Robert Harper", 
        "Frank Pfenning"
    ], 
    "lead_author": "Robert Harper", 
    "arxiv-id": "cs/0110028v1", 
    "title": "On Equivalence and Canonical Forms in the LF Type Theory", 
    "publish": "2001-10-11T16:36:18Z", 
    "summary": "Decidability of definitional equality and conversion of terms into canonical\nform play a central role in the meta-theory of a type-theoretic logical\nframework. Most studies of definitional equality are based on a confluent,\nstrongly-normalizing notion of reduction. Coquand has considered a different\napproach, directly proving the correctness of a practical equivalance algorithm\nbased on the shape of terms. Neither approach appears to scale well to richer\nlanguages with unit types or subtyping, and neither directly addresses the\nproblem of conversion to canonical.\n  In this paper we present a new, type-directed equivalence algorithm for the\nLF type theory that overcomes the weaknesses of previous approaches. The\nalgorithm is practical, scales to richer languages, and yields a new notion of\ncanonical form sufficient for adequate encodings of logical systems. The\nalgorithm is proved complete by a Kripke-style logical relations argument\nsimilar to that suggested by Coquand. Crucially, both the algorithm itself and\nthe logical relations rely only on the shapes of types, ignoring dependencies\non terms."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0110028v1", 
    "other_authors": [
        "Robert Harper", 
        "Frank Pfenning"
    ], 
    "lead_author": "Robert Harper", 
    "arxiv-id": "cs/0110028v1", 
    "title": "On Equivalence and Canonical Forms in the LF Type Theory", 
    "publish": "2001-10-11T16:36:18Z", 
    "summary": "Decidability of definitional equality and conversion of terms into canonical\nform play a central role in the meta-theory of a type-theoretic logical\nframework. Most studies of definitional equality are based on a confluent,\nstrongly-normalizing notion of reduction. Coquand has considered a different\napproach, directly proving the correctness of a practical equivalance algorithm\nbased on the shape of terms. Neither approach appears to scale well to richer\nlanguages with unit types or subtyping, and neither directly addresses the\nproblem of conversion to canonical.\n  In this paper we present a new, type-directed equivalence algorithm for the\nLF type theory that overcomes the weaknesses of previous approaches. The\nalgorithm is practical, scales to richer languages, and yields a new notion of\ncanonical form sufficient for adequate encodings of logical systems. The\nalgorithm is proved complete by a Kripke-style logical relations argument\nsimilar to that suggested by Coquand. Crucially, both the algorithm itself and\nthe logical relations rely only on the shapes of types, ignoring dependencies\non terms."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0110028v1", 
    "other_authors": [
        "Robert Harper", 
        "Frank Pfenning"
    ], 
    "lead_author": "Robert Harper", 
    "arxiv-id": "cs/0110028v1", 
    "title": "On Equivalence and Canonical Forms in the LF Type Theory", 
    "publish": "2001-10-11T16:36:18Z", 
    "summary": "Decidability of definitional equality and conversion of terms into canonical\nform play a central role in the meta-theory of a type-theoretic logical\nframework. Most studies of definitional equality are based on a confluent,\nstrongly-normalizing notion of reduction. Coquand has considered a different\napproach, directly proving the correctness of a practical equivalance algorithm\nbased on the shape of terms. Neither approach appears to scale well to richer\nlanguages with unit types or subtyping, and neither directly addresses the\nproblem of conversion to canonical.\n  In this paper we present a new, type-directed equivalence algorithm for the\nLF type theory that overcomes the weaknesses of previous approaches. The\nalgorithm is practical, scales to richer languages, and yields a new notion of\ncanonical form sufficient for adequate encodings of logical systems. The\nalgorithm is proved complete by a Kripke-style logical relations argument\nsimilar to that suggested by Coquand. Crucially, both the algorithm itself and\nthe logical relations rely only on the shapes of types, ignoring dependencies\non terms."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0110028v1", 
    "other_authors": [
        "Robert Harper", 
        "Frank Pfenning"
    ], 
    "lead_author": "Robert Harper", 
    "arxiv-id": "cs/0110028v1", 
    "title": "On Equivalence and Canonical Forms in the LF Type Theory", 
    "publish": "2001-10-11T16:36:18Z", 
    "summary": "Decidability of definitional equality and conversion of terms into canonical\nform play a central role in the meta-theory of a type-theoretic logical\nframework. Most studies of definitional equality are based on a confluent,\nstrongly-normalizing notion of reduction. Coquand has considered a different\napproach, directly proving the correctness of a practical equivalance algorithm\nbased on the shape of terms. Neither approach appears to scale well to richer\nlanguages with unit types or subtyping, and neither directly addresses the\nproblem of conversion to canonical.\n  In this paper we present a new, type-directed equivalence algorithm for the\nLF type theory that overcomes the weaknesses of previous approaches. The\nalgorithm is practical, scales to richer languages, and yields a new notion of\ncanonical form sufficient for adequate encodings of logical systems. The\nalgorithm is proved complete by a Kripke-style logical relations argument\nsimilar to that suggested by Coquand. Crucially, both the algorithm itself and\nthe logical relations rely only on the shapes of types, ignoring dependencies\non terms."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0110028v1", 
    "other_authors": [
        "Robert Harper", 
        "Frank Pfenning"
    ], 
    "lead_author": "Robert Harper", 
    "arxiv-id": "cs/0110028v1", 
    "title": "On Equivalence and Canonical Forms in the LF Type Theory", 
    "publish": "2001-10-11T16:36:18Z", 
    "summary": "Decidability of definitional equality and conversion of terms into canonical\nform play a central role in the meta-theory of a type-theoretic logical\nframework. Most studies of definitional equality are based on a confluent,\nstrongly-normalizing notion of reduction. Coquand has considered a different\napproach, directly proving the correctness of a practical equivalance algorithm\nbased on the shape of terms. Neither approach appears to scale well to richer\nlanguages with unit types or subtyping, and neither directly addresses the\nproblem of conversion to canonical.\n  In this paper we present a new, type-directed equivalence algorithm for the\nLF type theory that overcomes the weaknesses of previous approaches. The\nalgorithm is practical, scales to richer languages, and yields a new notion of\ncanonical form sufficient for adequate encodings of logical systems. The\nalgorithm is proved complete by a Kripke-style logical relations argument\nsimilar to that suggested by Coquand. Crucially, both the algorithm itself and\nthe logical relations rely only on the shapes of types, ignoring dependencies\non terms."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0110028v1", 
    "other_authors": [
        "Robert Harper", 
        "Frank Pfenning"
    ], 
    "lead_author": "Robert Harper", 
    "arxiv-id": "cs/0110028v1", 
    "title": "On Equivalence and Canonical Forms in the LF Type Theory", 
    "publish": "2001-10-11T16:36:18Z", 
    "summary": "Decidability of definitional equality and conversion of terms into canonical\nform play a central role in the meta-theory of a type-theoretic logical\nframework. Most studies of definitional equality are based on a confluent,\nstrongly-normalizing notion of reduction. Coquand has considered a different\napproach, directly proving the correctness of a practical equivalance algorithm\nbased on the shape of terms. Neither approach appears to scale well to richer\nlanguages with unit types or subtyping, and neither directly addresses the\nproblem of conversion to canonical.\n  In this paper we present a new, type-directed equivalence algorithm for the\nLF type theory that overcomes the weaknesses of previous approaches. The\nalgorithm is practical, scales to richer languages, and yields a new notion of\ncanonical form sufficient for adequate encodings of logical systems. The\nalgorithm is proved complete by a Kripke-style logical relations argument\nsimilar to that suggested by Coquand. Crucially, both the algorithm itself and\nthe logical relations rely only on the shapes of types, ignoring dependencies\non terms."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0110028v1", 
    "other_authors": [
        "Robert Harper", 
        "Frank Pfenning"
    ], 
    "lead_author": "Robert Harper", 
    "arxiv-id": "cs/0110028v1", 
    "title": "On Equivalence and Canonical Forms in the LF Type Theory", 
    "publish": "2001-10-11T16:36:18Z", 
    "summary": "Decidability of definitional equality and conversion of terms into canonical\nform play a central role in the meta-theory of a type-theoretic logical\nframework. Most studies of definitional equality are based on a confluent,\nstrongly-normalizing notion of reduction. Coquand has considered a different\napproach, directly proving the correctness of a practical equivalance algorithm\nbased on the shape of terms. Neither approach appears to scale well to richer\nlanguages with unit types or subtyping, and neither directly addresses the\nproblem of conversion to canonical.\n  In this paper we present a new, type-directed equivalence algorithm for the\nLF type theory that overcomes the weaknesses of previous approaches. The\nalgorithm is practical, scales to richer languages, and yields a new notion of\ncanonical form sufficient for adequate encodings of logical systems. The\nalgorithm is proved complete by a Kripke-style logical relations argument\nsimilar to that suggested by Coquand. Crucially, both the algorithm itself and\nthe logical relations rely only on the shapes of types, ignoring dependencies\non terms."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0110028v1", 
    "other_authors": [
        "Robert Harper", 
        "Frank Pfenning"
    ], 
    "lead_author": "Robert Harper", 
    "arxiv-id": "cs/0110028v1", 
    "title": "On Equivalence and Canonical Forms in the LF Type Theory", 
    "publish": "2001-10-11T16:36:18Z", 
    "summary": "Decidability of definitional equality and conversion of terms into canonical\nform play a central role in the meta-theory of a type-theoretic logical\nframework. Most studies of definitional equality are based on a confluent,\nstrongly-normalizing notion of reduction. Coquand has considered a different\napproach, directly proving the correctness of a practical equivalance algorithm\nbased on the shape of terms. Neither approach appears to scale well to richer\nlanguages with unit types or subtyping, and neither directly addresses the\nproblem of conversion to canonical.\n  In this paper we present a new, type-directed equivalence algorithm for the\nLF type theory that overcomes the weaknesses of previous approaches. The\nalgorithm is practical, scales to richer languages, and yields a new notion of\ncanonical form sufficient for adequate encodings of logical systems. The\nalgorithm is proved complete by a Kripke-style logical relations argument\nsimilar to that suggested by Coquand. Crucially, both the algorithm itself and\nthe logical relations rely only on the shapes of types, ignoring dependencies\non terms."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0110028v1", 
    "other_authors": [
        "Robert Harper", 
        "Frank Pfenning"
    ], 
    "lead_author": "Robert Harper", 
    "arxiv-id": "cs/0110028v1", 
    "title": "On Equivalence and Canonical Forms in the LF Type Theory", 
    "publish": "2001-10-11T16:36:18Z", 
    "summary": "Decidability of definitional equality and conversion of terms into canonical\nform play a central role in the meta-theory of a type-theoretic logical\nframework. Most studies of definitional equality are based on a confluent,\nstrongly-normalizing notion of reduction. Coquand has considered a different\napproach, directly proving the correctness of a practical equivalance algorithm\nbased on the shape of terms. Neither approach appears to scale well to richer\nlanguages with unit types or subtyping, and neither directly addresses the\nproblem of conversion to canonical.\n  In this paper we present a new, type-directed equivalence algorithm for the\nLF type theory that overcomes the weaknesses of previous approaches. The\nalgorithm is practical, scales to richer languages, and yields a new notion of\ncanonical form sufficient for adequate encodings of logical systems. The\nalgorithm is proved complete by a Kripke-style logical relations argument\nsimilar to that suggested by Coquand. Crucially, both the algorithm itself and\nthe logical relations rely only on the shapes of types, ignoring dependencies\non terms."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0110028v1", 
    "other_authors": [
        "Robert Harper", 
        "Frank Pfenning"
    ], 
    "lead_author": "Robert Harper", 
    "arxiv-id": "cs/0110028v1", 
    "title": "On Equivalence and Canonical Forms in the LF Type Theory", 
    "publish": "2001-10-11T16:36:18Z", 
    "summary": "Decidability of definitional equality and conversion of terms into canonical\nform play a central role in the meta-theory of a type-theoretic logical\nframework. Most studies of definitional equality are based on a confluent,\nstrongly-normalizing notion of reduction. Coquand has considered a different\napproach, directly proving the correctness of a practical equivalance algorithm\nbased on the shape of terms. Neither approach appears to scale well to richer\nlanguages with unit types or subtyping, and neither directly addresses the\nproblem of conversion to canonical.\n  In this paper we present a new, type-directed equivalence algorithm for the\nLF type theory that overcomes the weaknesses of previous approaches. The\nalgorithm is practical, scales to richer languages, and yields a new notion of\ncanonical form sufficient for adequate encodings of logical systems. The\nalgorithm is proved complete by a Kripke-style logical relations argument\nsimilar to that suggested by Coquand. Crucially, both the algorithm itself and\nthe logical relations rely only on the shapes of types, ignoring dependencies\non terms."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0110028v1", 
    "other_authors": [
        "Robert Harper", 
        "Frank Pfenning"
    ], 
    "lead_author": "Robert Harper", 
    "arxiv-id": "cs/0110028v1", 
    "title": "On Equivalence and Canonical Forms in the LF Type Theory", 
    "publish": "2001-10-11T16:36:18Z", 
    "summary": "Decidability of definitional equality and conversion of terms into canonical\nform play a central role in the meta-theory of a type-theoretic logical\nframework. Most studies of definitional equality are based on a confluent,\nstrongly-normalizing notion of reduction. Coquand has considered a different\napproach, directly proving the correctness of a practical equivalance algorithm\nbased on the shape of terms. Neither approach appears to scale well to richer\nlanguages with unit types or subtyping, and neither directly addresses the\nproblem of conversion to canonical.\n  In this paper we present a new, type-directed equivalence algorithm for the\nLF type theory that overcomes the weaknesses of previous approaches. The\nalgorithm is practical, scales to richer languages, and yields a new notion of\ncanonical form sufficient for adequate encodings of logical systems. The\nalgorithm is proved complete by a Kripke-style logical relations argument\nsimilar to that suggested by Coquand. Crucially, both the algorithm itself and\nthe logical relations rely only on the shapes of types, ignoring dependencies\non terms."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0110028v1", 
    "other_authors": [
        "Robert Harper", 
        "Frank Pfenning"
    ], 
    "lead_author": "Robert Harper", 
    "arxiv-id": "cs/0110028v1", 
    "title": "On Equivalence and Canonical Forms in the LF Type Theory", 
    "publish": "2001-10-11T16:36:18Z", 
    "summary": "Decidability of definitional equality and conversion of terms into canonical\nform play a central role in the meta-theory of a type-theoretic logical\nframework. Most studies of definitional equality are based on a confluent,\nstrongly-normalizing notion of reduction. Coquand has considered a different\napproach, directly proving the correctness of a practical equivalance algorithm\nbased on the shape of terms. Neither approach appears to scale well to richer\nlanguages with unit types or subtyping, and neither directly addresses the\nproblem of conversion to canonical.\n  In this paper we present a new, type-directed equivalence algorithm for the\nLF type theory that overcomes the weaknesses of previous approaches. The\nalgorithm is practical, scales to richer languages, and yields a new notion of\ncanonical form sufficient for adequate encodings of logical systems. The\nalgorithm is proved complete by a Kripke-style logical relations argument\nsimilar to that suggested by Coquand. Crucially, both the algorithm itself and\nthe logical relations rely only on the shapes of types, ignoring dependencies\non terms."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0110028v1", 
    "other_authors": [
        "Robert Harper", 
        "Frank Pfenning"
    ], 
    "lead_author": "Robert Harper", 
    "arxiv-id": "cs/0110028v1", 
    "title": "On Equivalence and Canonical Forms in the LF Type Theory", 
    "publish": "2001-10-11T16:36:18Z", 
    "summary": "Decidability of definitional equality and conversion of terms into canonical\nform play a central role in the meta-theory of a type-theoretic logical\nframework. Most studies of definitional equality are based on a confluent,\nstrongly-normalizing notion of reduction. Coquand has considered a different\napproach, directly proving the correctness of a practical equivalance algorithm\nbased on the shape of terms. Neither approach appears to scale well to richer\nlanguages with unit types or subtyping, and neither directly addresses the\nproblem of conversion to canonical.\n  In this paper we present a new, type-directed equivalence algorithm for the\nLF type theory that overcomes the weaknesses of previous approaches. The\nalgorithm is practical, scales to richer languages, and yields a new notion of\ncanonical form sufficient for adequate encodings of logical systems. The\nalgorithm is proved complete by a Kripke-style logical relations argument\nsimilar to that suggested by Coquand. Crucially, both the algorithm itself and\nthe logical relations rely only on the shapes of types, ignoring dependencies\non terms."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0110028v1", 
    "other_authors": [
        "Robert Harper", 
        "Frank Pfenning"
    ], 
    "lead_author": "Robert Harper", 
    "arxiv-id": "cs/0110028v1", 
    "title": "On Equivalence and Canonical Forms in the LF Type Theory", 
    "publish": "2001-10-11T16:36:18Z", 
    "summary": "Decidability of definitional equality and conversion of terms into canonical\nform play a central role in the meta-theory of a type-theoretic logical\nframework. Most studies of definitional equality are based on a confluent,\nstrongly-normalizing notion of reduction. Coquand has considered a different\napproach, directly proving the correctness of a practical equivalance algorithm\nbased on the shape of terms. Neither approach appears to scale well to richer\nlanguages with unit types or subtyping, and neither directly addresses the\nproblem of conversion to canonical.\n  In this paper we present a new, type-directed equivalence algorithm for the\nLF type theory that overcomes the weaknesses of previous approaches. The\nalgorithm is practical, scales to richer languages, and yields a new notion of\ncanonical form sufficient for adequate encodings of logical systems. The\nalgorithm is proved complete by a Kripke-style logical relations argument\nsimilar to that suggested by Coquand. Crucially, both the algorithm itself and\nthe logical relations rely only on the shapes of types, ignoring dependencies\non terms."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0110028v1", 
    "other_authors": [
        "Robert Harper", 
        "Frank Pfenning"
    ], 
    "lead_author": "Robert Harper", 
    "arxiv-id": "cs/0110028v1", 
    "title": "On Equivalence and Canonical Forms in the LF Type Theory", 
    "publish": "2001-10-11T16:36:18Z", 
    "summary": "Decidability of definitional equality and conversion of terms into canonical\nform play a central role in the meta-theory of a type-theoretic logical\nframework. Most studies of definitional equality are based on a confluent,\nstrongly-normalizing notion of reduction. Coquand has considered a different\napproach, directly proving the correctness of a practical equivalance algorithm\nbased on the shape of terms. Neither approach appears to scale well to richer\nlanguages with unit types or subtyping, and neither directly addresses the\nproblem of conversion to canonical.\n  In this paper we present a new, type-directed equivalence algorithm for the\nLF type theory that overcomes the weaknesses of previous approaches. The\nalgorithm is practical, scales to richer languages, and yields a new notion of\ncanonical form sufficient for adequate encodings of logical systems. The\nalgorithm is proved complete by a Kripke-style logical relations argument\nsimilar to that suggested by Coquand. Crucially, both the algorithm itself and\nthe logical relations rely only on the shapes of types, ignoring dependencies\non terms."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0110028v1", 
    "other_authors": [
        "Robert Harper", 
        "Frank Pfenning"
    ], 
    "lead_author": "Robert Harper", 
    "arxiv-id": "cs/0110028v1", 
    "title": "On Equivalence and Canonical Forms in the LF Type Theory", 
    "publish": "2001-10-11T16:36:18Z", 
    "summary": "Decidability of definitional equality and conversion of terms into canonical\nform play a central role in the meta-theory of a type-theoretic logical\nframework. Most studies of definitional equality are based on a confluent,\nstrongly-normalizing notion of reduction. Coquand has considered a different\napproach, directly proving the correctness of a practical equivalance algorithm\nbased on the shape of terms. Neither approach appears to scale well to richer\nlanguages with unit types or subtyping, and neither directly addresses the\nproblem of conversion to canonical.\n  In this paper we present a new, type-directed equivalence algorithm for the\nLF type theory that overcomes the weaknesses of previous approaches. The\nalgorithm is practical, scales to richer languages, and yields a new notion of\ncanonical form sufficient for adequate encodings of logical systems. The\nalgorithm is proved complete by a Kripke-style logical relations argument\nsimilar to that suggested by Coquand. Crucially, both the algorithm itself and\nthe logical relations rely only on the shapes of types, ignoring dependencies\non terms."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0110028v1", 
    "other_authors": [
        "Robert Harper", 
        "Frank Pfenning"
    ], 
    "lead_author": "Robert Harper", 
    "arxiv-id": "cs/0110028v1", 
    "title": "On Equivalence and Canonical Forms in the LF Type Theory", 
    "publish": "2001-10-11T16:36:18Z", 
    "summary": "Decidability of definitional equality and conversion of terms into canonical\nform play a central role in the meta-theory of a type-theoretic logical\nframework. Most studies of definitional equality are based on a confluent,\nstrongly-normalizing notion of reduction. Coquand has considered a different\napproach, directly proving the correctness of a practical equivalance algorithm\nbased on the shape of terms. Neither approach appears to scale well to richer\nlanguages with unit types or subtyping, and neither directly addresses the\nproblem of conversion to canonical.\n  In this paper we present a new, type-directed equivalence algorithm for the\nLF type theory that overcomes the weaknesses of previous approaches. The\nalgorithm is practical, scales to richer languages, and yields a new notion of\ncanonical form sufficient for adequate encodings of logical systems. The\nalgorithm is proved complete by a Kripke-style logical relations argument\nsimilar to that suggested by Coquand. Crucially, both the algorithm itself and\nthe logical relations rely only on the shapes of types, ignoring dependencies\non terms."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0110028v1", 
    "other_authors": [
        "Robert Harper", 
        "Frank Pfenning"
    ], 
    "lead_author": "Frank Pfenning", 
    "arxiv-id": "cs/0110028v1", 
    "title": "On Equivalence and Canonical Forms in the LF Type Theory", 
    "publish": "2001-10-11T16:36:18Z", 
    "summary": "Decidability of definitional equality and conversion of terms into canonical\nform play a central role in the meta-theory of a type-theoretic logical\nframework. Most studies of definitional equality are based on a confluent,\nstrongly-normalizing notion of reduction. Coquand has considered a different\napproach, directly proving the correctness of a practical equivalance algorithm\nbased on the shape of terms. Neither approach appears to scale well to richer\nlanguages with unit types or subtyping, and neither directly addresses the\nproblem of conversion to canonical.\n  In this paper we present a new, type-directed equivalence algorithm for the\nLF type theory that overcomes the weaknesses of previous approaches. The\nalgorithm is practical, scales to richer languages, and yields a new notion of\ncanonical form sufficient for adequate encodings of logical systems. The\nalgorithm is proved complete by a Kripke-style logical relations argument\nsimilar to that suggested by Coquand. Crucially, both the algorithm itself and\nthe logical relations rely only on the shapes of types, ignoring dependencies\non terms."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0110028v1", 
    "other_authors": [
        "Robert Harper", 
        "Frank Pfenning"
    ], 
    "lead_author": "Frank Pfenning", 
    "arxiv-id": "cs/0110028v1", 
    "title": "On Equivalence and Canonical Forms in the LF Type Theory", 
    "publish": "2001-10-11T16:36:18Z", 
    "summary": "Decidability of definitional equality and conversion of terms into canonical\nform play a central role in the meta-theory of a type-theoretic logical\nframework. Most studies of definitional equality are based on a confluent,\nstrongly-normalizing notion of reduction. Coquand has considered a different\napproach, directly proving the correctness of a practical equivalance algorithm\nbased on the shape of terms. Neither approach appears to scale well to richer\nlanguages with unit types or subtyping, and neither directly addresses the\nproblem of conversion to canonical.\n  In this paper we present a new, type-directed equivalence algorithm for the\nLF type theory that overcomes the weaknesses of previous approaches. The\nalgorithm is practical, scales to richer languages, and yields a new notion of\ncanonical form sufficient for adequate encodings of logical systems. The\nalgorithm is proved complete by a Kripke-style logical relations argument\nsimilar to that suggested by Coquand. Crucially, both the algorithm itself and\nthe logical relations rely only on the shapes of types, ignoring dependencies\non terms."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0110028v1", 
    "other_authors": [
        "Robert Harper", 
        "Frank Pfenning"
    ], 
    "lead_author": "Frank Pfenning", 
    "arxiv-id": "cs/0110028v1", 
    "title": "On Equivalence and Canonical Forms in the LF Type Theory", 
    "publish": "2001-10-11T16:36:18Z", 
    "summary": "Decidability of definitional equality and conversion of terms into canonical\nform play a central role in the meta-theory of a type-theoretic logical\nframework. Most studies of definitional equality are based on a confluent,\nstrongly-normalizing notion of reduction. Coquand has considered a different\napproach, directly proving the correctness of a practical equivalance algorithm\nbased on the shape of terms. Neither approach appears to scale well to richer\nlanguages with unit types or subtyping, and neither directly addresses the\nproblem of conversion to canonical.\n  In this paper we present a new, type-directed equivalence algorithm for the\nLF type theory that overcomes the weaknesses of previous approaches. The\nalgorithm is practical, scales to richer languages, and yields a new notion of\ncanonical form sufficient for adequate encodings of logical systems. The\nalgorithm is proved complete by a Kripke-style logical relations argument\nsimilar to that suggested by Coquand. Crucially, both the algorithm itself and\nthe logical relations rely only on the shapes of types, ignoring dependencies\non terms."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0110028v1", 
    "other_authors": [
        "Robert Harper", 
        "Frank Pfenning"
    ], 
    "lead_author": "Frank Pfenning", 
    "arxiv-id": "cs/0110028v1", 
    "title": "On Equivalence and Canonical Forms in the LF Type Theory", 
    "publish": "2001-10-11T16:36:18Z", 
    "summary": "Decidability of definitional equality and conversion of terms into canonical\nform play a central role in the meta-theory of a type-theoretic logical\nframework. Most studies of definitional equality are based on a confluent,\nstrongly-normalizing notion of reduction. Coquand has considered a different\napproach, directly proving the correctness of a practical equivalance algorithm\nbased on the shape of terms. Neither approach appears to scale well to richer\nlanguages with unit types or subtyping, and neither directly addresses the\nproblem of conversion to canonical.\n  In this paper we present a new, type-directed equivalence algorithm for the\nLF type theory that overcomes the weaknesses of previous approaches. The\nalgorithm is practical, scales to richer languages, and yields a new notion of\ncanonical form sufficient for adequate encodings of logical systems. The\nalgorithm is proved complete by a Kripke-style logical relations argument\nsimilar to that suggested by Coquand. Crucially, both the algorithm itself and\nthe logical relations rely only on the shapes of types, ignoring dependencies\non terms."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0110028v1", 
    "other_authors": [
        "Robert Harper", 
        "Frank Pfenning"
    ], 
    "lead_author": "Frank Pfenning", 
    "arxiv-id": "cs/0110028v1", 
    "title": "On Equivalence and Canonical Forms in the LF Type Theory", 
    "publish": "2001-10-11T16:36:18Z", 
    "summary": "Decidability of definitional equality and conversion of terms into canonical\nform play a central role in the meta-theory of a type-theoretic logical\nframework. Most studies of definitional equality are based on a confluent,\nstrongly-normalizing notion of reduction. Coquand has considered a different\napproach, directly proving the correctness of a practical equivalance algorithm\nbased on the shape of terms. Neither approach appears to scale well to richer\nlanguages with unit types or subtyping, and neither directly addresses the\nproblem of conversion to canonical.\n  In this paper we present a new, type-directed equivalence algorithm for the\nLF type theory that overcomes the weaknesses of previous approaches. The\nalgorithm is practical, scales to richer languages, and yields a new notion of\ncanonical form sufficient for adequate encodings of logical systems. The\nalgorithm is proved complete by a Kripke-style logical relations argument\nsimilar to that suggested by Coquand. Crucially, both the algorithm itself and\nthe logical relations rely only on the shapes of types, ignoring dependencies\non terms."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0110028v1", 
    "other_authors": [
        "Robert Harper", 
        "Frank Pfenning"
    ], 
    "lead_author": "Frank Pfenning", 
    "arxiv-id": "cs/0110028v1", 
    "title": "On Equivalence and Canonical Forms in the LF Type Theory", 
    "publish": "2001-10-11T16:36:18Z", 
    "summary": "Decidability of definitional equality and conversion of terms into canonical\nform play a central role in the meta-theory of a type-theoretic logical\nframework. Most studies of definitional equality are based on a confluent,\nstrongly-normalizing notion of reduction. Coquand has considered a different\napproach, directly proving the correctness of a practical equivalance algorithm\nbased on the shape of terms. Neither approach appears to scale well to richer\nlanguages with unit types or subtyping, and neither directly addresses the\nproblem of conversion to canonical.\n  In this paper we present a new, type-directed equivalence algorithm for the\nLF type theory that overcomes the weaknesses of previous approaches. The\nalgorithm is practical, scales to richer languages, and yields a new notion of\ncanonical form sufficient for adequate encodings of logical systems. The\nalgorithm is proved complete by a Kripke-style logical relations argument\nsimilar to that suggested by Coquand. Crucially, both the algorithm itself and\nthe logical relations rely only on the shapes of types, ignoring dependencies\non terms."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0110028v1", 
    "other_authors": [
        "Robert Harper", 
        "Frank Pfenning"
    ], 
    "lead_author": "Frank Pfenning", 
    "arxiv-id": "cs/0110028v1", 
    "title": "On Equivalence and Canonical Forms in the LF Type Theory", 
    "publish": "2001-10-11T16:36:18Z", 
    "summary": "Decidability of definitional equality and conversion of terms into canonical\nform play a central role in the meta-theory of a type-theoretic logical\nframework. Most studies of definitional equality are based on a confluent,\nstrongly-normalizing notion of reduction. Coquand has considered a different\napproach, directly proving the correctness of a practical equivalance algorithm\nbased on the shape of terms. Neither approach appears to scale well to richer\nlanguages with unit types or subtyping, and neither directly addresses the\nproblem of conversion to canonical.\n  In this paper we present a new, type-directed equivalence algorithm for the\nLF type theory that overcomes the weaknesses of previous approaches. The\nalgorithm is practical, scales to richer languages, and yields a new notion of\ncanonical form sufficient for adequate encodings of logical systems. The\nalgorithm is proved complete by a Kripke-style logical relations argument\nsimilar to that suggested by Coquand. Crucially, both the algorithm itself and\nthe logical relations rely only on the shapes of types, ignoring dependencies\non terms."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0110060v1", 
    "other_authors": [
        "Serban E. Vlad"
    ], 
    "lead_author": "Serban E. Vlad", 
    "arxiv-id": "cs/0110060v1", 
    "title": "Selected Topics in Asynchronous Automata", 
    "publish": "2001-10-31T10:35:32Z", 
    "summary": "The paper is concerned with defining the electrical signals and their models.\nThe delays are discussed, the asynchronous automata - which are the models of\nthe asynchronous circuits - and the examples of the clock generator and of the\nR-S latch are given. We write the equations of the asynchronous automata, which\ncombine the pure delay model and the inertial delay model; the simple gate\nmodel and the complex gate model; the fixed, bounded and unbounded delay model.\nWe give the solutions of these equations, which are written on R->{0,1}\nfunctions, where R is the time set. The connection between the real time and\nthe discrete time is discussed. The stability, the fundamental mode of\noperation, the combinational automata, the semi-modularity are defined and\ncharacterized. Some connections are suggested with the linear time and the\nbranching time temporal logic of the propositions."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0110061v1", 
    "other_authors": [
        "Serban E. Vlad"
    ], 
    "lead_author": "Serban E. Vlad", 
    "arxiv-id": "cs/0110061v1", 
    "title": "An Asynchronous Automata Approach to the Semantics of Temporal Logic", 
    "publish": "2001-10-31T10:44:55Z", 
    "summary": "The paper presents the differential equations that characterize an\nasynchronous automaton and gives their solution x:R->{0,1}x...x{0,1}. Remarks\nare made on the connection between the continuous time and the discrete time of\nthe approach. The continuous and the discrete time, the linear and the\nbranching temporal logics have the semantics depending on x and their formulas\ngive the properties of the automaton."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0110062v1", 
    "other_authors": [
        "Serban E. Vlad"
    ], 
    "lead_author": "Serban E. Vlad", 
    "arxiv-id": "cs/0110062v1", 
    "title": "The Delay-Insensitivity, the Hazard-Freedom, the Semi-Modularity and the   Technical Condition of Good Running of the Discrete Time Asynchronous   Automata", 
    "publish": "2001-10-31T10:53:34Z", 
    "summary": "The paper studies some important properties of the asynchronous (=timed)\nautomata: the delay-insensitivity, the hazard-freedom, the semi-modularity and\nthe technical condition of good running. Time is discrete."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0110063v2", 
    "other_authors": [
        "Zhe Dang", 
        "Oscar Ibarra"
    ], 
    "lead_author": "Zhe Dang", 
    "arxiv-id": "cs/0110063v2", 
    "title": "The Existence of $\u03c9$-Chains for Transitive Mixed Linear Relations   and Its Applications", 
    "publish": "2001-10-31T10:56:32Z", 
    "summary": "We show that it is decidable whether a transitive mixed linear relation has\nan $\\omega$-chain. Using this result, we study a number of liveness\nverification problems for generalized timed automata within a unified\nframework. More precisely, we prove that (1) the mixed linear liveness problem\nfor a timed automaton with dense clocks, reversal-bounded counters, and a free\ncounter is decidable, and (2) the Presburger liveness problem for a timed\nautomaton with discrete clocks, reversal-bounded counters, and a pushdown stack\nis decidable."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0110063v2", 
    "other_authors": [
        "Zhe Dang", 
        "Oscar Ibarra"
    ], 
    "lead_author": "Zhe Dang", 
    "arxiv-id": "cs/0110063v2", 
    "title": "The Existence of $\u03c9$-Chains for Transitive Mixed Linear Relations   and Its Applications", 
    "publish": "2001-10-31T10:56:32Z", 
    "summary": "We show that it is decidable whether a transitive mixed linear relation has\nan $\\omega$-chain. Using this result, we study a number of liveness\nverification problems for generalized timed automata within a unified\nframework. More precisely, we prove that (1) the mixed linear liveness problem\nfor a timed automaton with dense clocks, reversal-bounded counters, and a free\ncounter is decidable, and (2) the Presburger liveness problem for a timed\nautomaton with discrete clocks, reversal-bounded counters, and a pushdown stack\nis decidable."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0110063v2", 
    "other_authors": [
        "Zhe Dang", 
        "Oscar Ibarra"
    ], 
    "lead_author": "Zhe Dang", 
    "arxiv-id": "cs/0110063v2", 
    "title": "The Existence of $\u03c9$-Chains for Transitive Mixed Linear Relations   and Its Applications", 
    "publish": "2001-10-31T10:56:32Z", 
    "summary": "We show that it is decidable whether a transitive mixed linear relation has\nan $\\omega$-chain. Using this result, we study a number of liveness\nverification problems for generalized timed automata within a unified\nframework. More precisely, we prove that (1) the mixed linear liveness problem\nfor a timed automaton with dense clocks, reversal-bounded counters, and a free\ncounter is decidable, and (2) the Presburger liveness problem for a timed\nautomaton with discrete clocks, reversal-bounded counters, and a pushdown stack\nis decidable."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0110063v2", 
    "other_authors": [
        "Zhe Dang", 
        "Oscar Ibarra"
    ], 
    "lead_author": "Zhe Dang", 
    "arxiv-id": "cs/0110063v2", 
    "title": "The Existence of $\u03c9$-Chains for Transitive Mixed Linear Relations   and Its Applications", 
    "publish": "2001-10-31T10:56:32Z", 
    "summary": "We show that it is decidable whether a transitive mixed linear relation has\nan $\\omega$-chain. Using this result, we study a number of liveness\nverification problems for generalized timed automata within a unified\nframework. More precisely, we prove that (1) the mixed linear liveness problem\nfor a timed automaton with dense clocks, reversal-bounded counters, and a free\ncounter is decidable, and (2) the Presburger liveness problem for a timed\nautomaton with discrete clocks, reversal-bounded counters, and a pushdown stack\nis decidable."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0110063v2", 
    "other_authors": [
        "Zhe Dang", 
        "Oscar Ibarra"
    ], 
    "lead_author": "Zhe Dang", 
    "arxiv-id": "cs/0110063v2", 
    "title": "The Existence of $\u03c9$-Chains for Transitive Mixed Linear Relations   and Its Applications", 
    "publish": "2001-10-31T10:56:32Z", 
    "summary": "We show that it is decidable whether a transitive mixed linear relation has\nan $\\omega$-chain. Using this result, we study a number of liveness\nverification problems for generalized timed automata within a unified\nframework. More precisely, we prove that (1) the mixed linear liveness problem\nfor a timed automaton with dense clocks, reversal-bounded counters, and a free\ncounter is decidable, and (2) the Presburger liveness problem for a timed\nautomaton with discrete clocks, reversal-bounded counters, and a pushdown stack\nis decidable."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0110063v2", 
    "other_authors": [
        "Zhe Dang", 
        "Oscar Ibarra"
    ], 
    "lead_author": "Zhe Dang", 
    "arxiv-id": "cs/0110063v2", 
    "title": "The Existence of $\u03c9$-Chains for Transitive Mixed Linear Relations   and Its Applications", 
    "publish": "2001-10-31T10:56:32Z", 
    "summary": "We show that it is decidable whether a transitive mixed linear relation has\nan $\\omega$-chain. Using this result, we study a number of liveness\nverification problems for generalized timed automata within a unified\nframework. More precisely, we prove that (1) the mixed linear liveness problem\nfor a timed automaton with dense clocks, reversal-bounded counters, and a free\ncounter is decidable, and (2) the Presburger liveness problem for a timed\nautomaton with discrete clocks, reversal-bounded counters, and a pushdown stack\nis decidable."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0110063v2", 
    "other_authors": [
        "Zhe Dang", 
        "Oscar Ibarra"
    ], 
    "lead_author": "Zhe Dang", 
    "arxiv-id": "cs/0110063v2", 
    "title": "The Existence of $\u03c9$-Chains for Transitive Mixed Linear Relations   and Its Applications", 
    "publish": "2001-10-31T10:56:32Z", 
    "summary": "We show that it is decidable whether a transitive mixed linear relation has\nan $\\omega$-chain. Using this result, we study a number of liveness\nverification problems for generalized timed automata within a unified\nframework. More precisely, we prove that (1) the mixed linear liveness problem\nfor a timed automaton with dense clocks, reversal-bounded counters, and a free\ncounter is decidable, and (2) the Presburger liveness problem for a timed\nautomaton with discrete clocks, reversal-bounded counters, and a pushdown stack\nis decidable."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0110063v2", 
    "other_authors": [
        "Zhe Dang", 
        "Oscar Ibarra"
    ], 
    "lead_author": "Zhe Dang", 
    "arxiv-id": "cs/0110063v2", 
    "title": "The Existence of $\u03c9$-Chains for Transitive Mixed Linear Relations   and Its Applications", 
    "publish": "2001-10-31T10:56:32Z", 
    "summary": "We show that it is decidable whether a transitive mixed linear relation has\nan $\\omega$-chain. Using this result, we study a number of liveness\nverification problems for generalized timed automata within a unified\nframework. More precisely, we prove that (1) the mixed linear liveness problem\nfor a timed automaton with dense clocks, reversal-bounded counters, and a free\ncounter is decidable, and (2) the Presburger liveness problem for a timed\nautomaton with discrete clocks, reversal-bounded counters, and a pushdown stack\nis decidable."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0110063v2", 
    "other_authors": [
        "Zhe Dang", 
        "Oscar Ibarra"
    ], 
    "lead_author": "Oscar Ibarra", 
    "arxiv-id": "cs/0110063v2", 
    "title": "The Existence of $\u03c9$-Chains for Transitive Mixed Linear Relations   and Its Applications", 
    "publish": "2001-10-31T10:56:32Z", 
    "summary": "We show that it is decidable whether a transitive mixed linear relation has\nan $\\omega$-chain. Using this result, we study a number of liveness\nverification problems for generalized timed automata within a unified\nframework. More precisely, we prove that (1) the mixed linear liveness problem\nfor a timed automaton with dense clocks, reversal-bounded counters, and a free\ncounter is decidable, and (2) the Presburger liveness problem for a timed\nautomaton with discrete clocks, reversal-bounded counters, and a pushdown stack\nis decidable."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0110063v2", 
    "other_authors": [
        "Zhe Dang", 
        "Oscar Ibarra"
    ], 
    "lead_author": "Oscar Ibarra", 
    "arxiv-id": "cs/0110063v2", 
    "title": "The Existence of $\u03c9$-Chains for Transitive Mixed Linear Relations   and Its Applications", 
    "publish": "2001-10-31T10:56:32Z", 
    "summary": "We show that it is decidable whether a transitive mixed linear relation has\nan $\\omega$-chain. Using this result, we study a number of liveness\nverification problems for generalized timed automata within a unified\nframework. More precisely, we prove that (1) the mixed linear liveness problem\nfor a timed automaton with dense clocks, reversal-bounded counters, and a free\ncounter is decidable, and (2) the Presburger liveness problem for a timed\nautomaton with discrete clocks, reversal-bounded counters, and a pushdown stack\nis decidable."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0110063v2", 
    "other_authors": [
        "Zhe Dang", 
        "Oscar Ibarra"
    ], 
    "lead_author": "Oscar Ibarra", 
    "arxiv-id": "cs/0110063v2", 
    "title": "The Existence of $\u03c9$-Chains for Transitive Mixed Linear Relations   and Its Applications", 
    "publish": "2001-10-31T10:56:32Z", 
    "summary": "We show that it is decidable whether a transitive mixed linear relation has\nan $\\omega$-chain. Using this result, we study a number of liveness\nverification problems for generalized timed automata within a unified\nframework. More precisely, we prove that (1) the mixed linear liveness problem\nfor a timed automaton with dense clocks, reversal-bounded counters, and a free\ncounter is decidable, and (2) the Presburger liveness problem for a timed\nautomaton with discrete clocks, reversal-bounded counters, and a pushdown stack\nis decidable."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0110063v2", 
    "other_authors": [
        "Zhe Dang", 
        "Oscar Ibarra"
    ], 
    "lead_author": "Oscar Ibarra", 
    "arxiv-id": "cs/0110063v2", 
    "title": "The Existence of $\u03c9$-Chains for Transitive Mixed Linear Relations   and Its Applications", 
    "publish": "2001-10-31T10:56:32Z", 
    "summary": "We show that it is decidable whether a transitive mixed linear relation has\nan $\\omega$-chain. Using this result, we study a number of liveness\nverification problems for generalized timed automata within a unified\nframework. More precisely, we prove that (1) the mixed linear liveness problem\nfor a timed automaton with dense clocks, reversal-bounded counters, and a free\ncounter is decidable, and (2) the Presburger liveness problem for a timed\nautomaton with discrete clocks, reversal-bounded counters, and a pushdown stack\nis decidable."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0110063v2", 
    "other_authors": [
        "Zhe Dang", 
        "Oscar Ibarra"
    ], 
    "lead_author": "Oscar Ibarra", 
    "arxiv-id": "cs/0110063v2", 
    "title": "The Existence of $\u03c9$-Chains for Transitive Mixed Linear Relations   and Its Applications", 
    "publish": "2001-10-31T10:56:32Z", 
    "summary": "We show that it is decidable whether a transitive mixed linear relation has\nan $\\omega$-chain. Using this result, we study a number of liveness\nverification problems for generalized timed automata within a unified\nframework. More precisely, we prove that (1) the mixed linear liveness problem\nfor a timed automaton with dense clocks, reversal-bounded counters, and a free\ncounter is decidable, and (2) the Presburger liveness problem for a timed\nautomaton with discrete clocks, reversal-bounded counters, and a pushdown stack\nis decidable."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0110063v2", 
    "other_authors": [
        "Zhe Dang", 
        "Oscar Ibarra"
    ], 
    "lead_author": "Oscar Ibarra", 
    "arxiv-id": "cs/0110063v2", 
    "title": "The Existence of $\u03c9$-Chains for Transitive Mixed Linear Relations   and Its Applications", 
    "publish": "2001-10-31T10:56:32Z", 
    "summary": "We show that it is decidable whether a transitive mixed linear relation has\nan $\\omega$-chain. Using this result, we study a number of liveness\nverification problems for generalized timed automata within a unified\nframework. More precisely, we prove that (1) the mixed linear liveness problem\nfor a timed automaton with dense clocks, reversal-bounded counters, and a free\ncounter is decidable, and (2) the Presburger liveness problem for a timed\nautomaton with discrete clocks, reversal-bounded counters, and a pushdown stack\nis decidable."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0110064v1", 
    "other_authors": [
        "Serban E. Vlad"
    ], 
    "lead_author": "Serban E. Vlad", 
    "arxiv-id": "cs/0110064v1", 
    "title": "Applications of the Differential Calculus in the Study of the Timed   Automata: the Inertial Delay Buffer", 
    "publish": "2001-10-31T10:59:16Z", 
    "summary": "We write the relations that characterize the simpliest timed automaton, the\ninertial delay buffer, in two versions: the non-deterministic and the\ndeterministic one, by making use of the derivatives of the R->{0,1} functions."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111010v1", 
    "other_authors": [
        "Giovambattista Ianni", 
        "Nicola Leone", 
        "Simona Perri", 
        "Francesco Scarcello"
    ], 
    "lead_author": "Giovambattista Ianni", 
    "arxiv-id": "cs/0111010v1", 
    "title": "Abduction with Penalization in Logic Programming", 
    "publish": "2001-11-06T16:33:29Z", 
    "summary": "Abduction, first proposed in the setting of classical logics, has been\nstudied with growing interest in the logic programming area during the last\nyears.\n  In this paper we study {\\em abduction with penalization} in logic\nprogramming. This form of abductive reasoning, which has not been previously\nanalyzed in logic programming, turns out to represent several relevant\nproblems, including optimization problems, very naturally. We define a formal\nmodel for abduction with penalization from logic programs, which extends the\nabductive framework proposed by Kakas and Mancarella. We show the high\nexpressiveness of this formalism, by encoding a couple of relevant problems,\nincluding the well-know Traveling Salesman Problem from optimization theory, in\nthis abductive framework. The resulting encodings are very simple and elegant.\nWe analyze the complexity of the main decisional problems arising in this\nframework. An interesting result in this course is that ``negation comes for\nfree.'' Indeed, the addition of (even unstratified) negation does not cause any\nfurther increase to the complexity of the abductive reasoning tasks (which\nremains the same as for not-free programs)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111010v1", 
    "other_authors": [
        "Giovambattista Ianni", 
        "Nicola Leone", 
        "Simona Perri", 
        "Francesco Scarcello"
    ], 
    "lead_author": "Giovambattista Ianni", 
    "arxiv-id": "cs/0111010v1", 
    "title": "Abduction with Penalization in Logic Programming", 
    "publish": "2001-11-06T16:33:29Z", 
    "summary": "Abduction, first proposed in the setting of classical logics, has been\nstudied with growing interest in the logic programming area during the last\nyears.\n  In this paper we study {\\em abduction with penalization} in logic\nprogramming. This form of abductive reasoning, which has not been previously\nanalyzed in logic programming, turns out to represent several relevant\nproblems, including optimization problems, very naturally. We define a formal\nmodel for abduction with penalization from logic programs, which extends the\nabductive framework proposed by Kakas and Mancarella. We show the high\nexpressiveness of this formalism, by encoding a couple of relevant problems,\nincluding the well-know Traveling Salesman Problem from optimization theory, in\nthis abductive framework. The resulting encodings are very simple and elegant.\nWe analyze the complexity of the main decisional problems arising in this\nframework. An interesting result in this course is that ``negation comes for\nfree.'' Indeed, the addition of (even unstratified) negation does not cause any\nfurther increase to the complexity of the abductive reasoning tasks (which\nremains the same as for not-free programs)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111010v1", 
    "other_authors": [
        "Giovambattista Ianni", 
        "Nicola Leone", 
        "Simona Perri", 
        "Francesco Scarcello"
    ], 
    "lead_author": "Giovambattista Ianni", 
    "arxiv-id": "cs/0111010v1", 
    "title": "Abduction with Penalization in Logic Programming", 
    "publish": "2001-11-06T16:33:29Z", 
    "summary": "Abduction, first proposed in the setting of classical logics, has been\nstudied with growing interest in the logic programming area during the last\nyears.\n  In this paper we study {\\em abduction with penalization} in logic\nprogramming. This form of abductive reasoning, which has not been previously\nanalyzed in logic programming, turns out to represent several relevant\nproblems, including optimization problems, very naturally. We define a formal\nmodel for abduction with penalization from logic programs, which extends the\nabductive framework proposed by Kakas and Mancarella. We show the high\nexpressiveness of this formalism, by encoding a couple of relevant problems,\nincluding the well-know Traveling Salesman Problem from optimization theory, in\nthis abductive framework. The resulting encodings are very simple and elegant.\nWe analyze the complexity of the main decisional problems arising in this\nframework. An interesting result in this course is that ``negation comes for\nfree.'' Indeed, the addition of (even unstratified) negation does not cause any\nfurther increase to the complexity of the abductive reasoning tasks (which\nremains the same as for not-free programs)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111010v1", 
    "other_authors": [
        "Giovambattista Ianni", 
        "Nicola Leone", 
        "Simona Perri", 
        "Francesco Scarcello"
    ], 
    "lead_author": "Giovambattista Ianni", 
    "arxiv-id": "cs/0111010v1", 
    "title": "Abduction with Penalization in Logic Programming", 
    "publish": "2001-11-06T16:33:29Z", 
    "summary": "Abduction, first proposed in the setting of classical logics, has been\nstudied with growing interest in the logic programming area during the last\nyears.\n  In this paper we study {\\em abduction with penalization} in logic\nprogramming. This form of abductive reasoning, which has not been previously\nanalyzed in logic programming, turns out to represent several relevant\nproblems, including optimization problems, very naturally. We define a formal\nmodel for abduction with penalization from logic programs, which extends the\nabductive framework proposed by Kakas and Mancarella. We show the high\nexpressiveness of this formalism, by encoding a couple of relevant problems,\nincluding the well-know Traveling Salesman Problem from optimization theory, in\nthis abductive framework. The resulting encodings are very simple and elegant.\nWe analyze the complexity of the main decisional problems arising in this\nframework. An interesting result in this course is that ``negation comes for\nfree.'' Indeed, the addition of (even unstratified) negation does not cause any\nfurther increase to the complexity of the abductive reasoning tasks (which\nremains the same as for not-free programs)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111010v1", 
    "other_authors": [
        "Giovambattista Ianni", 
        "Nicola Leone", 
        "Simona Perri", 
        "Francesco Scarcello"
    ], 
    "lead_author": "Giovambattista Ianni", 
    "arxiv-id": "cs/0111010v1", 
    "title": "Abduction with Penalization in Logic Programming", 
    "publish": "2001-11-06T16:33:29Z", 
    "summary": "Abduction, first proposed in the setting of classical logics, has been\nstudied with growing interest in the logic programming area during the last\nyears.\n  In this paper we study {\\em abduction with penalization} in logic\nprogramming. This form of abductive reasoning, which has not been previously\nanalyzed in logic programming, turns out to represent several relevant\nproblems, including optimization problems, very naturally. We define a formal\nmodel for abduction with penalization from logic programs, which extends the\nabductive framework proposed by Kakas and Mancarella. We show the high\nexpressiveness of this formalism, by encoding a couple of relevant problems,\nincluding the well-know Traveling Salesman Problem from optimization theory, in\nthis abductive framework. The resulting encodings are very simple and elegant.\nWe analyze the complexity of the main decisional problems arising in this\nframework. An interesting result in this course is that ``negation comes for\nfree.'' Indeed, the addition of (even unstratified) negation does not cause any\nfurther increase to the complexity of the abductive reasoning tasks (which\nremains the same as for not-free programs)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111010v1", 
    "other_authors": [
        "Giovambattista Ianni", 
        "Nicola Leone", 
        "Simona Perri", 
        "Francesco Scarcello"
    ], 
    "lead_author": "Giovambattista Ianni", 
    "arxiv-id": "cs/0111010v1", 
    "title": "Abduction with Penalization in Logic Programming", 
    "publish": "2001-11-06T16:33:29Z", 
    "summary": "Abduction, first proposed in the setting of classical logics, has been\nstudied with growing interest in the logic programming area during the last\nyears.\n  In this paper we study {\\em abduction with penalization} in logic\nprogramming. This form of abductive reasoning, which has not been previously\nanalyzed in logic programming, turns out to represent several relevant\nproblems, including optimization problems, very naturally. We define a formal\nmodel for abduction with penalization from logic programs, which extends the\nabductive framework proposed by Kakas and Mancarella. We show the high\nexpressiveness of this formalism, by encoding a couple of relevant problems,\nincluding the well-know Traveling Salesman Problem from optimization theory, in\nthis abductive framework. The resulting encodings are very simple and elegant.\nWe analyze the complexity of the main decisional problems arising in this\nframework. An interesting result in this course is that ``negation comes for\nfree.'' Indeed, the addition of (even unstratified) negation does not cause any\nfurther increase to the complexity of the abductive reasoning tasks (which\nremains the same as for not-free programs)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111010v1", 
    "other_authors": [
        "Giovambattista Ianni", 
        "Nicola Leone", 
        "Simona Perri", 
        "Francesco Scarcello"
    ], 
    "lead_author": "Giovambattista Ianni", 
    "arxiv-id": "cs/0111010v1", 
    "title": "Abduction with Penalization in Logic Programming", 
    "publish": "2001-11-06T16:33:29Z", 
    "summary": "Abduction, first proposed in the setting of classical logics, has been\nstudied with growing interest in the logic programming area during the last\nyears.\n  In this paper we study {\\em abduction with penalization} in logic\nprogramming. This form of abductive reasoning, which has not been previously\nanalyzed in logic programming, turns out to represent several relevant\nproblems, including optimization problems, very naturally. We define a formal\nmodel for abduction with penalization from logic programs, which extends the\nabductive framework proposed by Kakas and Mancarella. We show the high\nexpressiveness of this formalism, by encoding a couple of relevant problems,\nincluding the well-know Traveling Salesman Problem from optimization theory, in\nthis abductive framework. The resulting encodings are very simple and elegant.\nWe analyze the complexity of the main decisional problems arising in this\nframework. An interesting result in this course is that ``negation comes for\nfree.'' Indeed, the addition of (even unstratified) negation does not cause any\nfurther increase to the complexity of the abductive reasoning tasks (which\nremains the same as for not-free programs)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111010v1", 
    "other_authors": [
        "Giovambattista Ianni", 
        "Nicola Leone", 
        "Simona Perri", 
        "Francesco Scarcello"
    ], 
    "lead_author": "Giovambattista Ianni", 
    "arxiv-id": "cs/0111010v1", 
    "title": "Abduction with Penalization in Logic Programming", 
    "publish": "2001-11-06T16:33:29Z", 
    "summary": "Abduction, first proposed in the setting of classical logics, has been\nstudied with growing interest in the logic programming area during the last\nyears.\n  In this paper we study {\\em abduction with penalization} in logic\nprogramming. This form of abductive reasoning, which has not been previously\nanalyzed in logic programming, turns out to represent several relevant\nproblems, including optimization problems, very naturally. We define a formal\nmodel for abduction with penalization from logic programs, which extends the\nabductive framework proposed by Kakas and Mancarella. We show the high\nexpressiveness of this formalism, by encoding a couple of relevant problems,\nincluding the well-know Traveling Salesman Problem from optimization theory, in\nthis abductive framework. The resulting encodings are very simple and elegant.\nWe analyze the complexity of the main decisional problems arising in this\nframework. An interesting result in this course is that ``negation comes for\nfree.'' Indeed, the addition of (even unstratified) negation does not cause any\nfurther increase to the complexity of the abductive reasoning tasks (which\nremains the same as for not-free programs)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111010v1", 
    "other_authors": [
        "Giovambattista Ianni", 
        "Nicola Leone", 
        "Simona Perri", 
        "Francesco Scarcello"
    ], 
    "lead_author": "Nicola Leone", 
    "arxiv-id": "cs/0111010v1", 
    "title": "Abduction with Penalization in Logic Programming", 
    "publish": "2001-11-06T16:33:29Z", 
    "summary": "Abduction, first proposed in the setting of classical logics, has been\nstudied with growing interest in the logic programming area during the last\nyears.\n  In this paper we study {\\em abduction with penalization} in logic\nprogramming. This form of abductive reasoning, which has not been previously\nanalyzed in logic programming, turns out to represent several relevant\nproblems, including optimization problems, very naturally. We define a formal\nmodel for abduction with penalization from logic programs, which extends the\nabductive framework proposed by Kakas and Mancarella. We show the high\nexpressiveness of this formalism, by encoding a couple of relevant problems,\nincluding the well-know Traveling Salesman Problem from optimization theory, in\nthis abductive framework. The resulting encodings are very simple and elegant.\nWe analyze the complexity of the main decisional problems arising in this\nframework. An interesting result in this course is that ``negation comes for\nfree.'' Indeed, the addition of (even unstratified) negation does not cause any\nfurther increase to the complexity of the abductive reasoning tasks (which\nremains the same as for not-free programs)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111010v1", 
    "other_authors": [
        "Giovambattista Ianni", 
        "Nicola Leone", 
        "Simona Perri", 
        "Francesco Scarcello"
    ], 
    "lead_author": "Nicola Leone", 
    "arxiv-id": "cs/0111010v1", 
    "title": "Abduction with Penalization in Logic Programming", 
    "publish": "2001-11-06T16:33:29Z", 
    "summary": "Abduction, first proposed in the setting of classical logics, has been\nstudied with growing interest in the logic programming area during the last\nyears.\n  In this paper we study {\\em abduction with penalization} in logic\nprogramming. This form of abductive reasoning, which has not been previously\nanalyzed in logic programming, turns out to represent several relevant\nproblems, including optimization problems, very naturally. We define a formal\nmodel for abduction with penalization from logic programs, which extends the\nabductive framework proposed by Kakas and Mancarella. We show the high\nexpressiveness of this formalism, by encoding a couple of relevant problems,\nincluding the well-know Traveling Salesman Problem from optimization theory, in\nthis abductive framework. The resulting encodings are very simple and elegant.\nWe analyze the complexity of the main decisional problems arising in this\nframework. An interesting result in this course is that ``negation comes for\nfree.'' Indeed, the addition of (even unstratified) negation does not cause any\nfurther increase to the complexity of the abductive reasoning tasks (which\nremains the same as for not-free programs)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111010v1", 
    "other_authors": [
        "Giovambattista Ianni", 
        "Nicola Leone", 
        "Simona Perri", 
        "Francesco Scarcello"
    ], 
    "lead_author": "Nicola Leone", 
    "arxiv-id": "cs/0111010v1", 
    "title": "Abduction with Penalization in Logic Programming", 
    "publish": "2001-11-06T16:33:29Z", 
    "summary": "Abduction, first proposed in the setting of classical logics, has been\nstudied with growing interest in the logic programming area during the last\nyears.\n  In this paper we study {\\em abduction with penalization} in logic\nprogramming. This form of abductive reasoning, which has not been previously\nanalyzed in logic programming, turns out to represent several relevant\nproblems, including optimization problems, very naturally. We define a formal\nmodel for abduction with penalization from logic programs, which extends the\nabductive framework proposed by Kakas and Mancarella. We show the high\nexpressiveness of this formalism, by encoding a couple of relevant problems,\nincluding the well-know Traveling Salesman Problem from optimization theory, in\nthis abductive framework. The resulting encodings are very simple and elegant.\nWe analyze the complexity of the main decisional problems arising in this\nframework. An interesting result in this course is that ``negation comes for\nfree.'' Indeed, the addition of (even unstratified) negation does not cause any\nfurther increase to the complexity of the abductive reasoning tasks (which\nremains the same as for not-free programs)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111010v1", 
    "other_authors": [
        "Giovambattista Ianni", 
        "Nicola Leone", 
        "Simona Perri", 
        "Francesco Scarcello"
    ], 
    "lead_author": "Nicola Leone", 
    "arxiv-id": "cs/0111010v1", 
    "title": "Abduction with Penalization in Logic Programming", 
    "publish": "2001-11-06T16:33:29Z", 
    "summary": "Abduction, first proposed in the setting of classical logics, has been\nstudied with growing interest in the logic programming area during the last\nyears.\n  In this paper we study {\\em abduction with penalization} in logic\nprogramming. This form of abductive reasoning, which has not been previously\nanalyzed in logic programming, turns out to represent several relevant\nproblems, including optimization problems, very naturally. We define a formal\nmodel for abduction with penalization from logic programs, which extends the\nabductive framework proposed by Kakas and Mancarella. We show the high\nexpressiveness of this formalism, by encoding a couple of relevant problems,\nincluding the well-know Traveling Salesman Problem from optimization theory, in\nthis abductive framework. The resulting encodings are very simple and elegant.\nWe analyze the complexity of the main decisional problems arising in this\nframework. An interesting result in this course is that ``negation comes for\nfree.'' Indeed, the addition of (even unstratified) negation does not cause any\nfurther increase to the complexity of the abductive reasoning tasks (which\nremains the same as for not-free programs)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111010v1", 
    "other_authors": [
        "Giovambattista Ianni", 
        "Nicola Leone", 
        "Simona Perri", 
        "Francesco Scarcello"
    ], 
    "lead_author": "Nicola Leone", 
    "arxiv-id": "cs/0111010v1", 
    "title": "Abduction with Penalization in Logic Programming", 
    "publish": "2001-11-06T16:33:29Z", 
    "summary": "Abduction, first proposed in the setting of classical logics, has been\nstudied with growing interest in the logic programming area during the last\nyears.\n  In this paper we study {\\em abduction with penalization} in logic\nprogramming. This form of abductive reasoning, which has not been previously\nanalyzed in logic programming, turns out to represent several relevant\nproblems, including optimization problems, very naturally. We define a formal\nmodel for abduction with penalization from logic programs, which extends the\nabductive framework proposed by Kakas and Mancarella. We show the high\nexpressiveness of this formalism, by encoding a couple of relevant problems,\nincluding the well-know Traveling Salesman Problem from optimization theory, in\nthis abductive framework. The resulting encodings are very simple and elegant.\nWe analyze the complexity of the main decisional problems arising in this\nframework. An interesting result in this course is that ``negation comes for\nfree.'' Indeed, the addition of (even unstratified) negation does not cause any\nfurther increase to the complexity of the abductive reasoning tasks (which\nremains the same as for not-free programs)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111010v1", 
    "other_authors": [
        "Giovambattista Ianni", 
        "Nicola Leone", 
        "Simona Perri", 
        "Francesco Scarcello"
    ], 
    "lead_author": "Nicola Leone", 
    "arxiv-id": "cs/0111010v1", 
    "title": "Abduction with Penalization in Logic Programming", 
    "publish": "2001-11-06T16:33:29Z", 
    "summary": "Abduction, first proposed in the setting of classical logics, has been\nstudied with growing interest in the logic programming area during the last\nyears.\n  In this paper we study {\\em abduction with penalization} in logic\nprogramming. This form of abductive reasoning, which has not been previously\nanalyzed in logic programming, turns out to represent several relevant\nproblems, including optimization problems, very naturally. We define a formal\nmodel for abduction with penalization from logic programs, which extends the\nabductive framework proposed by Kakas and Mancarella. We show the high\nexpressiveness of this formalism, by encoding a couple of relevant problems,\nincluding the well-know Traveling Salesman Problem from optimization theory, in\nthis abductive framework. The resulting encodings are very simple and elegant.\nWe analyze the complexity of the main decisional problems arising in this\nframework. An interesting result in this course is that ``negation comes for\nfree.'' Indeed, the addition of (even unstratified) negation does not cause any\nfurther increase to the complexity of the abductive reasoning tasks (which\nremains the same as for not-free programs)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111010v1", 
    "other_authors": [
        "Giovambattista Ianni", 
        "Nicola Leone", 
        "Simona Perri", 
        "Francesco Scarcello"
    ], 
    "lead_author": "Nicola Leone", 
    "arxiv-id": "cs/0111010v1", 
    "title": "Abduction with Penalization in Logic Programming", 
    "publish": "2001-11-06T16:33:29Z", 
    "summary": "Abduction, first proposed in the setting of classical logics, has been\nstudied with growing interest in the logic programming area during the last\nyears.\n  In this paper we study {\\em abduction with penalization} in logic\nprogramming. This form of abductive reasoning, which has not been previously\nanalyzed in logic programming, turns out to represent several relevant\nproblems, including optimization problems, very naturally. We define a formal\nmodel for abduction with penalization from logic programs, which extends the\nabductive framework proposed by Kakas and Mancarella. We show the high\nexpressiveness of this formalism, by encoding a couple of relevant problems,\nincluding the well-know Traveling Salesman Problem from optimization theory, in\nthis abductive framework. The resulting encodings are very simple and elegant.\nWe analyze the complexity of the main decisional problems arising in this\nframework. An interesting result in this course is that ``negation comes for\nfree.'' Indeed, the addition of (even unstratified) negation does not cause any\nfurther increase to the complexity of the abductive reasoning tasks (which\nremains the same as for not-free programs)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111010v1", 
    "other_authors": [
        "Giovambattista Ianni", 
        "Nicola Leone", 
        "Simona Perri", 
        "Francesco Scarcello"
    ], 
    "lead_author": "Nicola Leone", 
    "arxiv-id": "cs/0111010v1", 
    "title": "Abduction with Penalization in Logic Programming", 
    "publish": "2001-11-06T16:33:29Z", 
    "summary": "Abduction, first proposed in the setting of classical logics, has been\nstudied with growing interest in the logic programming area during the last\nyears.\n  In this paper we study {\\em abduction with penalization} in logic\nprogramming. This form of abductive reasoning, which has not been previously\nanalyzed in logic programming, turns out to represent several relevant\nproblems, including optimization problems, very naturally. We define a formal\nmodel for abduction with penalization from logic programs, which extends the\nabductive framework proposed by Kakas and Mancarella. We show the high\nexpressiveness of this formalism, by encoding a couple of relevant problems,\nincluding the well-know Traveling Salesman Problem from optimization theory, in\nthis abductive framework. The resulting encodings are very simple and elegant.\nWe analyze the complexity of the main decisional problems arising in this\nframework. An interesting result in this course is that ``negation comes for\nfree.'' Indeed, the addition of (even unstratified) negation does not cause any\nfurther increase to the complexity of the abductive reasoning tasks (which\nremains the same as for not-free programs)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111010v1", 
    "other_authors": [
        "Giovambattista Ianni", 
        "Nicola Leone", 
        "Simona Perri", 
        "Francesco Scarcello"
    ], 
    "lead_author": "Nicola Leone", 
    "arxiv-id": "cs/0111010v1", 
    "title": "Abduction with Penalization in Logic Programming", 
    "publish": "2001-11-06T16:33:29Z", 
    "summary": "Abduction, first proposed in the setting of classical logics, has been\nstudied with growing interest in the logic programming area during the last\nyears.\n  In this paper we study {\\em abduction with penalization} in logic\nprogramming. This form of abductive reasoning, which has not been previously\nanalyzed in logic programming, turns out to represent several relevant\nproblems, including optimization problems, very naturally. We define a formal\nmodel for abduction with penalization from logic programs, which extends the\nabductive framework proposed by Kakas and Mancarella. We show the high\nexpressiveness of this formalism, by encoding a couple of relevant problems,\nincluding the well-know Traveling Salesman Problem from optimization theory, in\nthis abductive framework. The resulting encodings are very simple and elegant.\nWe analyze the complexity of the main decisional problems arising in this\nframework. An interesting result in this course is that ``negation comes for\nfree.'' Indeed, the addition of (even unstratified) negation does not cause any\nfurther increase to the complexity of the abductive reasoning tasks (which\nremains the same as for not-free programs)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111010v1", 
    "other_authors": [
        "Giovambattista Ianni", 
        "Nicola Leone", 
        "Simona Perri", 
        "Francesco Scarcello"
    ], 
    "lead_author": "Nicola Leone", 
    "arxiv-id": "cs/0111010v1", 
    "title": "Abduction with Penalization in Logic Programming", 
    "publish": "2001-11-06T16:33:29Z", 
    "summary": "Abduction, first proposed in the setting of classical logics, has been\nstudied with growing interest in the logic programming area during the last\nyears.\n  In this paper we study {\\em abduction with penalization} in logic\nprogramming. This form of abductive reasoning, which has not been previously\nanalyzed in logic programming, turns out to represent several relevant\nproblems, including optimization problems, very naturally. We define a formal\nmodel for abduction with penalization from logic programs, which extends the\nabductive framework proposed by Kakas and Mancarella. We show the high\nexpressiveness of this formalism, by encoding a couple of relevant problems,\nincluding the well-know Traveling Salesman Problem from optimization theory, in\nthis abductive framework. The resulting encodings are very simple and elegant.\nWe analyze the complexity of the main decisional problems arising in this\nframework. An interesting result in this course is that ``negation comes for\nfree.'' Indeed, the addition of (even unstratified) negation does not cause any\nfurther increase to the complexity of the abductive reasoning tasks (which\nremains the same as for not-free programs)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111010v1", 
    "other_authors": [
        "Giovambattista Ianni", 
        "Nicola Leone", 
        "Simona Perri", 
        "Francesco Scarcello"
    ], 
    "lead_author": "Nicola Leone", 
    "arxiv-id": "cs/0111010v1", 
    "title": "Abduction with Penalization in Logic Programming", 
    "publish": "2001-11-06T16:33:29Z", 
    "summary": "Abduction, first proposed in the setting of classical logics, has been\nstudied with growing interest in the logic programming area during the last\nyears.\n  In this paper we study {\\em abduction with penalization} in logic\nprogramming. This form of abductive reasoning, which has not been previously\nanalyzed in logic programming, turns out to represent several relevant\nproblems, including optimization problems, very naturally. We define a formal\nmodel for abduction with penalization from logic programs, which extends the\nabductive framework proposed by Kakas and Mancarella. We show the high\nexpressiveness of this formalism, by encoding a couple of relevant problems,\nincluding the well-know Traveling Salesman Problem from optimization theory, in\nthis abductive framework. The resulting encodings are very simple and elegant.\nWe analyze the complexity of the main decisional problems arising in this\nframework. An interesting result in this course is that ``negation comes for\nfree.'' Indeed, the addition of (even unstratified) negation does not cause any\nfurther increase to the complexity of the abductive reasoning tasks (which\nremains the same as for not-free programs)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111010v1", 
    "other_authors": [
        "Giovambattista Ianni", 
        "Nicola Leone", 
        "Simona Perri", 
        "Francesco Scarcello"
    ], 
    "lead_author": "Nicola Leone", 
    "arxiv-id": "cs/0111010v1", 
    "title": "Abduction with Penalization in Logic Programming", 
    "publish": "2001-11-06T16:33:29Z", 
    "summary": "Abduction, first proposed in the setting of classical logics, has been\nstudied with growing interest in the logic programming area during the last\nyears.\n  In this paper we study {\\em abduction with penalization} in logic\nprogramming. This form of abductive reasoning, which has not been previously\nanalyzed in logic programming, turns out to represent several relevant\nproblems, including optimization problems, very naturally. We define a formal\nmodel for abduction with penalization from logic programs, which extends the\nabductive framework proposed by Kakas and Mancarella. We show the high\nexpressiveness of this formalism, by encoding a couple of relevant problems,\nincluding the well-know Traveling Salesman Problem from optimization theory, in\nthis abductive framework. The resulting encodings are very simple and elegant.\nWe analyze the complexity of the main decisional problems arising in this\nframework. An interesting result in this course is that ``negation comes for\nfree.'' Indeed, the addition of (even unstratified) negation does not cause any\nfurther increase to the complexity of the abductive reasoning tasks (which\nremains the same as for not-free programs)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111010v1", 
    "other_authors": [
        "Giovambattista Ianni", 
        "Nicola Leone", 
        "Simona Perri", 
        "Francesco Scarcello"
    ], 
    "lead_author": "Nicola Leone", 
    "arxiv-id": "cs/0111010v1", 
    "title": "Abduction with Penalization in Logic Programming", 
    "publish": "2001-11-06T16:33:29Z", 
    "summary": "Abduction, first proposed in the setting of classical logics, has been\nstudied with growing interest in the logic programming area during the last\nyears.\n  In this paper we study {\\em abduction with penalization} in logic\nprogramming. This form of abductive reasoning, which has not been previously\nanalyzed in logic programming, turns out to represent several relevant\nproblems, including optimization problems, very naturally. We define a formal\nmodel for abduction with penalization from logic programs, which extends the\nabductive framework proposed by Kakas and Mancarella. We show the high\nexpressiveness of this formalism, by encoding a couple of relevant problems,\nincluding the well-know Traveling Salesman Problem from optimization theory, in\nthis abductive framework. The resulting encodings are very simple and elegant.\nWe analyze the complexity of the main decisional problems arising in this\nframework. An interesting result in this course is that ``negation comes for\nfree.'' Indeed, the addition of (even unstratified) negation does not cause any\nfurther increase to the complexity of the abductive reasoning tasks (which\nremains the same as for not-free programs)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111010v1", 
    "other_authors": [
        "Giovambattista Ianni", 
        "Nicola Leone", 
        "Simona Perri", 
        "Francesco Scarcello"
    ], 
    "lead_author": "Nicola Leone", 
    "arxiv-id": "cs/0111010v1", 
    "title": "Abduction with Penalization in Logic Programming", 
    "publish": "2001-11-06T16:33:29Z", 
    "summary": "Abduction, first proposed in the setting of classical logics, has been\nstudied with growing interest in the logic programming area during the last\nyears.\n  In this paper we study {\\em abduction with penalization} in logic\nprogramming. This form of abductive reasoning, which has not been previously\nanalyzed in logic programming, turns out to represent several relevant\nproblems, including optimization problems, very naturally. We define a formal\nmodel for abduction with penalization from logic programs, which extends the\nabductive framework proposed by Kakas and Mancarella. We show the high\nexpressiveness of this formalism, by encoding a couple of relevant problems,\nincluding the well-know Traveling Salesman Problem from optimization theory, in\nthis abductive framework. The resulting encodings are very simple and elegant.\nWe analyze the complexity of the main decisional problems arising in this\nframework. An interesting result in this course is that ``negation comes for\nfree.'' Indeed, the addition of (even unstratified) negation does not cause any\nfurther increase to the complexity of the abductive reasoning tasks (which\nremains the same as for not-free programs)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111010v1", 
    "other_authors": [
        "Giovambattista Ianni", 
        "Nicola Leone", 
        "Simona Perri", 
        "Francesco Scarcello"
    ], 
    "lead_author": "Nicola Leone", 
    "arxiv-id": "cs/0111010v1", 
    "title": "Abduction with Penalization in Logic Programming", 
    "publish": "2001-11-06T16:33:29Z", 
    "summary": "Abduction, first proposed in the setting of classical logics, has been\nstudied with growing interest in the logic programming area during the last\nyears.\n  In this paper we study {\\em abduction with penalization} in logic\nprogramming. This form of abductive reasoning, which has not been previously\nanalyzed in logic programming, turns out to represent several relevant\nproblems, including optimization problems, very naturally. We define a formal\nmodel for abduction with penalization from logic programs, which extends the\nabductive framework proposed by Kakas and Mancarella. We show the high\nexpressiveness of this formalism, by encoding a couple of relevant problems,\nincluding the well-know Traveling Salesman Problem from optimization theory, in\nthis abductive framework. The resulting encodings are very simple and elegant.\nWe analyze the complexity of the main decisional problems arising in this\nframework. An interesting result in this course is that ``negation comes for\nfree.'' Indeed, the addition of (even unstratified) negation does not cause any\nfurther increase to the complexity of the abductive reasoning tasks (which\nremains the same as for not-free programs)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111010v1", 
    "other_authors": [
        "Giovambattista Ianni", 
        "Nicola Leone", 
        "Simona Perri", 
        "Francesco Scarcello"
    ], 
    "lead_author": "Nicola Leone", 
    "arxiv-id": "cs/0111010v1", 
    "title": "Abduction with Penalization in Logic Programming", 
    "publish": "2001-11-06T16:33:29Z", 
    "summary": "Abduction, first proposed in the setting of classical logics, has been\nstudied with growing interest in the logic programming area during the last\nyears.\n  In this paper we study {\\em abduction with penalization} in logic\nprogramming. This form of abductive reasoning, which has not been previously\nanalyzed in logic programming, turns out to represent several relevant\nproblems, including optimization problems, very naturally. We define a formal\nmodel for abduction with penalization from logic programs, which extends the\nabductive framework proposed by Kakas and Mancarella. We show the high\nexpressiveness of this formalism, by encoding a couple of relevant problems,\nincluding the well-know Traveling Salesman Problem from optimization theory, in\nthis abductive framework. The resulting encodings are very simple and elegant.\nWe analyze the complexity of the main decisional problems arising in this\nframework. An interesting result in this course is that ``negation comes for\nfree.'' Indeed, the addition of (even unstratified) negation does not cause any\nfurther increase to the complexity of the abductive reasoning tasks (which\nremains the same as for not-free programs)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111010v1", 
    "other_authors": [
        "Giovambattista Ianni", 
        "Nicola Leone", 
        "Simona Perri", 
        "Francesco Scarcello"
    ], 
    "lead_author": "Nicola Leone", 
    "arxiv-id": "cs/0111010v1", 
    "title": "Abduction with Penalization in Logic Programming", 
    "publish": "2001-11-06T16:33:29Z", 
    "summary": "Abduction, first proposed in the setting of classical logics, has been\nstudied with growing interest in the logic programming area during the last\nyears.\n  In this paper we study {\\em abduction with penalization} in logic\nprogramming. This form of abductive reasoning, which has not been previously\nanalyzed in logic programming, turns out to represent several relevant\nproblems, including optimization problems, very naturally. We define a formal\nmodel for abduction with penalization from logic programs, which extends the\nabductive framework proposed by Kakas and Mancarella. We show the high\nexpressiveness of this formalism, by encoding a couple of relevant problems,\nincluding the well-know Traveling Salesman Problem from optimization theory, in\nthis abductive framework. The resulting encodings are very simple and elegant.\nWe analyze the complexity of the main decisional problems arising in this\nframework. An interesting result in this course is that ``negation comes for\nfree.'' Indeed, the addition of (even unstratified) negation does not cause any\nfurther increase to the complexity of the abductive reasoning tasks (which\nremains the same as for not-free programs)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111010v1", 
    "other_authors": [
        "Giovambattista Ianni", 
        "Nicola Leone", 
        "Simona Perri", 
        "Francesco Scarcello"
    ], 
    "lead_author": "Nicola Leone", 
    "arxiv-id": "cs/0111010v1", 
    "title": "Abduction with Penalization in Logic Programming", 
    "publish": "2001-11-06T16:33:29Z", 
    "summary": "Abduction, first proposed in the setting of classical logics, has been\nstudied with growing interest in the logic programming area during the last\nyears.\n  In this paper we study {\\em abduction with penalization} in logic\nprogramming. This form of abductive reasoning, which has not been previously\nanalyzed in logic programming, turns out to represent several relevant\nproblems, including optimization problems, very naturally. We define a formal\nmodel for abduction with penalization from logic programs, which extends the\nabductive framework proposed by Kakas and Mancarella. We show the high\nexpressiveness of this formalism, by encoding a couple of relevant problems,\nincluding the well-know Traveling Salesman Problem from optimization theory, in\nthis abductive framework. The resulting encodings are very simple and elegant.\nWe analyze the complexity of the main decisional problems arising in this\nframework. An interesting result in this course is that ``negation comes for\nfree.'' Indeed, the addition of (even unstratified) negation does not cause any\nfurther increase to the complexity of the abductive reasoning tasks (which\nremains the same as for not-free programs)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111010v1", 
    "other_authors": [
        "Giovambattista Ianni", 
        "Nicola Leone", 
        "Simona Perri", 
        "Francesco Scarcello"
    ], 
    "lead_author": "Nicola Leone", 
    "arxiv-id": "cs/0111010v1", 
    "title": "Abduction with Penalization in Logic Programming", 
    "publish": "2001-11-06T16:33:29Z", 
    "summary": "Abduction, first proposed in the setting of classical logics, has been\nstudied with growing interest in the logic programming area during the last\nyears.\n  In this paper we study {\\em abduction with penalization} in logic\nprogramming. This form of abductive reasoning, which has not been previously\nanalyzed in logic programming, turns out to represent several relevant\nproblems, including optimization problems, very naturally. We define a formal\nmodel for abduction with penalization from logic programs, which extends the\nabductive framework proposed by Kakas and Mancarella. We show the high\nexpressiveness of this formalism, by encoding a couple of relevant problems,\nincluding the well-know Traveling Salesman Problem from optimization theory, in\nthis abductive framework. The resulting encodings are very simple and elegant.\nWe analyze the complexity of the main decisional problems arising in this\nframework. An interesting result in this course is that ``negation comes for\nfree.'' Indeed, the addition of (even unstratified) negation does not cause any\nfurther increase to the complexity of the abductive reasoning tasks (which\nremains the same as for not-free programs)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111010v1", 
    "other_authors": [
        "Giovambattista Ianni", 
        "Nicola Leone", 
        "Simona Perri", 
        "Francesco Scarcello"
    ], 
    "lead_author": "Nicola Leone", 
    "arxiv-id": "cs/0111010v1", 
    "title": "Abduction with Penalization in Logic Programming", 
    "publish": "2001-11-06T16:33:29Z", 
    "summary": "Abduction, first proposed in the setting of classical logics, has been\nstudied with growing interest in the logic programming area during the last\nyears.\n  In this paper we study {\\em abduction with penalization} in logic\nprogramming. This form of abductive reasoning, which has not been previously\nanalyzed in logic programming, turns out to represent several relevant\nproblems, including optimization problems, very naturally. We define a formal\nmodel for abduction with penalization from logic programs, which extends the\nabductive framework proposed by Kakas and Mancarella. We show the high\nexpressiveness of this formalism, by encoding a couple of relevant problems,\nincluding the well-know Traveling Salesman Problem from optimization theory, in\nthis abductive framework. The resulting encodings are very simple and elegant.\nWe analyze the complexity of the main decisional problems arising in this\nframework. An interesting result in this course is that ``negation comes for\nfree.'' Indeed, the addition of (even unstratified) negation does not cause any\nfurther increase to the complexity of the abductive reasoning tasks (which\nremains the same as for not-free programs)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111010v1", 
    "other_authors": [
        "Giovambattista Ianni", 
        "Nicola Leone", 
        "Simona Perri", 
        "Francesco Scarcello"
    ], 
    "lead_author": "Nicola Leone", 
    "arxiv-id": "cs/0111010v1", 
    "title": "Abduction with Penalization in Logic Programming", 
    "publish": "2001-11-06T16:33:29Z", 
    "summary": "Abduction, first proposed in the setting of classical logics, has been\nstudied with growing interest in the logic programming area during the last\nyears.\n  In this paper we study {\\em abduction with penalization} in logic\nprogramming. This form of abductive reasoning, which has not been previously\nanalyzed in logic programming, turns out to represent several relevant\nproblems, including optimization problems, very naturally. We define a formal\nmodel for abduction with penalization from logic programs, which extends the\nabductive framework proposed by Kakas and Mancarella. We show the high\nexpressiveness of this formalism, by encoding a couple of relevant problems,\nincluding the well-know Traveling Salesman Problem from optimization theory, in\nthis abductive framework. The resulting encodings are very simple and elegant.\nWe analyze the complexity of the main decisional problems arising in this\nframework. An interesting result in this course is that ``negation comes for\nfree.'' Indeed, the addition of (even unstratified) negation does not cause any\nfurther increase to the complexity of the abductive reasoning tasks (which\nremains the same as for not-free programs)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111010v1", 
    "other_authors": [
        "Giovambattista Ianni", 
        "Nicola Leone", 
        "Simona Perri", 
        "Francesco Scarcello"
    ], 
    "lead_author": "Nicola Leone", 
    "arxiv-id": "cs/0111010v1", 
    "title": "Abduction with Penalization in Logic Programming", 
    "publish": "2001-11-06T16:33:29Z", 
    "summary": "Abduction, first proposed in the setting of classical logics, has been\nstudied with growing interest in the logic programming area during the last\nyears.\n  In this paper we study {\\em abduction with penalization} in logic\nprogramming. This form of abductive reasoning, which has not been previously\nanalyzed in logic programming, turns out to represent several relevant\nproblems, including optimization problems, very naturally. We define a formal\nmodel for abduction with penalization from logic programs, which extends the\nabductive framework proposed by Kakas and Mancarella. We show the high\nexpressiveness of this formalism, by encoding a couple of relevant problems,\nincluding the well-know Traveling Salesman Problem from optimization theory, in\nthis abductive framework. The resulting encodings are very simple and elegant.\nWe analyze the complexity of the main decisional problems arising in this\nframework. An interesting result in this course is that ``negation comes for\nfree.'' Indeed, the addition of (even unstratified) negation does not cause any\nfurther increase to the complexity of the abductive reasoning tasks (which\nremains the same as for not-free programs)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111010v1", 
    "other_authors": [
        "Giovambattista Ianni", 
        "Nicola Leone", 
        "Simona Perri", 
        "Francesco Scarcello"
    ], 
    "lead_author": "Nicola Leone", 
    "arxiv-id": "cs/0111010v1", 
    "title": "Abduction with Penalization in Logic Programming", 
    "publish": "2001-11-06T16:33:29Z", 
    "summary": "Abduction, first proposed in the setting of classical logics, has been\nstudied with growing interest in the logic programming area during the last\nyears.\n  In this paper we study {\\em abduction with penalization} in logic\nprogramming. This form of abductive reasoning, which has not been previously\nanalyzed in logic programming, turns out to represent several relevant\nproblems, including optimization problems, very naturally. We define a formal\nmodel for abduction with penalization from logic programs, which extends the\nabductive framework proposed by Kakas and Mancarella. We show the high\nexpressiveness of this formalism, by encoding a couple of relevant problems,\nincluding the well-know Traveling Salesman Problem from optimization theory, in\nthis abductive framework. The resulting encodings are very simple and elegant.\nWe analyze the complexity of the main decisional problems arising in this\nframework. An interesting result in this course is that ``negation comes for\nfree.'' Indeed, the addition of (even unstratified) negation does not cause any\nfurther increase to the complexity of the abductive reasoning tasks (which\nremains the same as for not-free programs)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111010v1", 
    "other_authors": [
        "Giovambattista Ianni", 
        "Nicola Leone", 
        "Simona Perri", 
        "Francesco Scarcello"
    ], 
    "lead_author": "Simona Perri", 
    "arxiv-id": "cs/0111010v1", 
    "title": "Abduction with Penalization in Logic Programming", 
    "publish": "2001-11-06T16:33:29Z", 
    "summary": "Abduction, first proposed in the setting of classical logics, has been\nstudied with growing interest in the logic programming area during the last\nyears.\n  In this paper we study {\\em abduction with penalization} in logic\nprogramming. This form of abductive reasoning, which has not been previously\nanalyzed in logic programming, turns out to represent several relevant\nproblems, including optimization problems, very naturally. We define a formal\nmodel for abduction with penalization from logic programs, which extends the\nabductive framework proposed by Kakas and Mancarella. We show the high\nexpressiveness of this formalism, by encoding a couple of relevant problems,\nincluding the well-know Traveling Salesman Problem from optimization theory, in\nthis abductive framework. The resulting encodings are very simple and elegant.\nWe analyze the complexity of the main decisional problems arising in this\nframework. An interesting result in this course is that ``negation comes for\nfree.'' Indeed, the addition of (even unstratified) negation does not cause any\nfurther increase to the complexity of the abductive reasoning tasks (which\nremains the same as for not-free programs)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111010v1", 
    "other_authors": [
        "Giovambattista Ianni", 
        "Nicola Leone", 
        "Simona Perri", 
        "Francesco Scarcello"
    ], 
    "lead_author": "Simona Perri", 
    "arxiv-id": "cs/0111010v1", 
    "title": "Abduction with Penalization in Logic Programming", 
    "publish": "2001-11-06T16:33:29Z", 
    "summary": "Abduction, first proposed in the setting of classical logics, has been\nstudied with growing interest in the logic programming area during the last\nyears.\n  In this paper we study {\\em abduction with penalization} in logic\nprogramming. This form of abductive reasoning, which has not been previously\nanalyzed in logic programming, turns out to represent several relevant\nproblems, including optimization problems, very naturally. We define a formal\nmodel for abduction with penalization from logic programs, which extends the\nabductive framework proposed by Kakas and Mancarella. We show the high\nexpressiveness of this formalism, by encoding a couple of relevant problems,\nincluding the well-know Traveling Salesman Problem from optimization theory, in\nthis abductive framework. The resulting encodings are very simple and elegant.\nWe analyze the complexity of the main decisional problems arising in this\nframework. An interesting result in this course is that ``negation comes for\nfree.'' Indeed, the addition of (even unstratified) negation does not cause any\nfurther increase to the complexity of the abductive reasoning tasks (which\nremains the same as for not-free programs)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111010v1", 
    "other_authors": [
        "Giovambattista Ianni", 
        "Nicola Leone", 
        "Simona Perri", 
        "Francesco Scarcello"
    ], 
    "lead_author": "Simona Perri", 
    "arxiv-id": "cs/0111010v1", 
    "title": "Abduction with Penalization in Logic Programming", 
    "publish": "2001-11-06T16:33:29Z", 
    "summary": "Abduction, first proposed in the setting of classical logics, has been\nstudied with growing interest in the logic programming area during the last\nyears.\n  In this paper we study {\\em abduction with penalization} in logic\nprogramming. This form of abductive reasoning, which has not been previously\nanalyzed in logic programming, turns out to represent several relevant\nproblems, including optimization problems, very naturally. We define a formal\nmodel for abduction with penalization from logic programs, which extends the\nabductive framework proposed by Kakas and Mancarella. We show the high\nexpressiveness of this formalism, by encoding a couple of relevant problems,\nincluding the well-know Traveling Salesman Problem from optimization theory, in\nthis abductive framework. The resulting encodings are very simple and elegant.\nWe analyze the complexity of the main decisional problems arising in this\nframework. An interesting result in this course is that ``negation comes for\nfree.'' Indeed, the addition of (even unstratified) negation does not cause any\nfurther increase to the complexity of the abductive reasoning tasks (which\nremains the same as for not-free programs)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111010v1", 
    "other_authors": [
        "Giovambattista Ianni", 
        "Nicola Leone", 
        "Simona Perri", 
        "Francesco Scarcello"
    ], 
    "lead_author": "Simona Perri", 
    "arxiv-id": "cs/0111010v1", 
    "title": "Abduction with Penalization in Logic Programming", 
    "publish": "2001-11-06T16:33:29Z", 
    "summary": "Abduction, first proposed in the setting of classical logics, has been\nstudied with growing interest in the logic programming area during the last\nyears.\n  In this paper we study {\\em abduction with penalization} in logic\nprogramming. This form of abductive reasoning, which has not been previously\nanalyzed in logic programming, turns out to represent several relevant\nproblems, including optimization problems, very naturally. We define a formal\nmodel for abduction with penalization from logic programs, which extends the\nabductive framework proposed by Kakas and Mancarella. We show the high\nexpressiveness of this formalism, by encoding a couple of relevant problems,\nincluding the well-know Traveling Salesman Problem from optimization theory, in\nthis abductive framework. The resulting encodings are very simple and elegant.\nWe analyze the complexity of the main decisional problems arising in this\nframework. An interesting result in this course is that ``negation comes for\nfree.'' Indeed, the addition of (even unstratified) negation does not cause any\nfurther increase to the complexity of the abductive reasoning tasks (which\nremains the same as for not-free programs)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111010v1", 
    "other_authors": [
        "Giovambattista Ianni", 
        "Nicola Leone", 
        "Simona Perri", 
        "Francesco Scarcello"
    ], 
    "lead_author": "Simona Perri", 
    "arxiv-id": "cs/0111010v1", 
    "title": "Abduction with Penalization in Logic Programming", 
    "publish": "2001-11-06T16:33:29Z", 
    "summary": "Abduction, first proposed in the setting of classical logics, has been\nstudied with growing interest in the logic programming area during the last\nyears.\n  In this paper we study {\\em abduction with penalization} in logic\nprogramming. This form of abductive reasoning, which has not been previously\nanalyzed in logic programming, turns out to represent several relevant\nproblems, including optimization problems, very naturally. We define a formal\nmodel for abduction with penalization from logic programs, which extends the\nabductive framework proposed by Kakas and Mancarella. We show the high\nexpressiveness of this formalism, by encoding a couple of relevant problems,\nincluding the well-know Traveling Salesman Problem from optimization theory, in\nthis abductive framework. The resulting encodings are very simple and elegant.\nWe analyze the complexity of the main decisional problems arising in this\nframework. An interesting result in this course is that ``negation comes for\nfree.'' Indeed, the addition of (even unstratified) negation does not cause any\nfurther increase to the complexity of the abductive reasoning tasks (which\nremains the same as for not-free programs)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111010v1", 
    "other_authors": [
        "Giovambattista Ianni", 
        "Nicola Leone", 
        "Simona Perri", 
        "Francesco Scarcello"
    ], 
    "lead_author": "Simona Perri", 
    "arxiv-id": "cs/0111010v1", 
    "title": "Abduction with Penalization in Logic Programming", 
    "publish": "2001-11-06T16:33:29Z", 
    "summary": "Abduction, first proposed in the setting of classical logics, has been\nstudied with growing interest in the logic programming area during the last\nyears.\n  In this paper we study {\\em abduction with penalization} in logic\nprogramming. This form of abductive reasoning, which has not been previously\nanalyzed in logic programming, turns out to represent several relevant\nproblems, including optimization problems, very naturally. We define a formal\nmodel for abduction with penalization from logic programs, which extends the\nabductive framework proposed by Kakas and Mancarella. We show the high\nexpressiveness of this formalism, by encoding a couple of relevant problems,\nincluding the well-know Traveling Salesman Problem from optimization theory, in\nthis abductive framework. The resulting encodings are very simple and elegant.\nWe analyze the complexity of the main decisional problems arising in this\nframework. An interesting result in this course is that ``negation comes for\nfree.'' Indeed, the addition of (even unstratified) negation does not cause any\nfurther increase to the complexity of the abductive reasoning tasks (which\nremains the same as for not-free programs)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111010v1", 
    "other_authors": [
        "Giovambattista Ianni", 
        "Nicola Leone", 
        "Simona Perri", 
        "Francesco Scarcello"
    ], 
    "lead_author": "Simona Perri", 
    "arxiv-id": "cs/0111010v1", 
    "title": "Abduction with Penalization in Logic Programming", 
    "publish": "2001-11-06T16:33:29Z", 
    "summary": "Abduction, first proposed in the setting of classical logics, has been\nstudied with growing interest in the logic programming area during the last\nyears.\n  In this paper we study {\\em abduction with penalization} in logic\nprogramming. This form of abductive reasoning, which has not been previously\nanalyzed in logic programming, turns out to represent several relevant\nproblems, including optimization problems, very naturally. We define a formal\nmodel for abduction with penalization from logic programs, which extends the\nabductive framework proposed by Kakas and Mancarella. We show the high\nexpressiveness of this formalism, by encoding a couple of relevant problems,\nincluding the well-know Traveling Salesman Problem from optimization theory, in\nthis abductive framework. The resulting encodings are very simple and elegant.\nWe analyze the complexity of the main decisional problems arising in this\nframework. An interesting result in this course is that ``negation comes for\nfree.'' Indeed, the addition of (even unstratified) negation does not cause any\nfurther increase to the complexity of the abductive reasoning tasks (which\nremains the same as for not-free programs)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111010v1", 
    "other_authors": [
        "Giovambattista Ianni", 
        "Nicola Leone", 
        "Simona Perri", 
        "Francesco Scarcello"
    ], 
    "lead_author": "Simona Perri", 
    "arxiv-id": "cs/0111010v1", 
    "title": "Abduction with Penalization in Logic Programming", 
    "publish": "2001-11-06T16:33:29Z", 
    "summary": "Abduction, first proposed in the setting of classical logics, has been\nstudied with growing interest in the logic programming area during the last\nyears.\n  In this paper we study {\\em abduction with penalization} in logic\nprogramming. This form of abductive reasoning, which has not been previously\nanalyzed in logic programming, turns out to represent several relevant\nproblems, including optimization problems, very naturally. We define a formal\nmodel for abduction with penalization from logic programs, which extends the\nabductive framework proposed by Kakas and Mancarella. We show the high\nexpressiveness of this formalism, by encoding a couple of relevant problems,\nincluding the well-know Traveling Salesman Problem from optimization theory, in\nthis abductive framework. The resulting encodings are very simple and elegant.\nWe analyze the complexity of the main decisional problems arising in this\nframework. An interesting result in this course is that ``negation comes for\nfree.'' Indeed, the addition of (even unstratified) negation does not cause any\nfurther increase to the complexity of the abductive reasoning tasks (which\nremains the same as for not-free programs)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111010v1", 
    "other_authors": [
        "Giovambattista Ianni", 
        "Nicola Leone", 
        "Simona Perri", 
        "Francesco Scarcello"
    ], 
    "lead_author": "Simona Perri", 
    "arxiv-id": "cs/0111010v1", 
    "title": "Abduction with Penalization in Logic Programming", 
    "publish": "2001-11-06T16:33:29Z", 
    "summary": "Abduction, first proposed in the setting of classical logics, has been\nstudied with growing interest in the logic programming area during the last\nyears.\n  In this paper we study {\\em abduction with penalization} in logic\nprogramming. This form of abductive reasoning, which has not been previously\nanalyzed in logic programming, turns out to represent several relevant\nproblems, including optimization problems, very naturally. We define a formal\nmodel for abduction with penalization from logic programs, which extends the\nabductive framework proposed by Kakas and Mancarella. We show the high\nexpressiveness of this formalism, by encoding a couple of relevant problems,\nincluding the well-know Traveling Salesman Problem from optimization theory, in\nthis abductive framework. The resulting encodings are very simple and elegant.\nWe analyze the complexity of the main decisional problems arising in this\nframework. An interesting result in this course is that ``negation comes for\nfree.'' Indeed, the addition of (even unstratified) negation does not cause any\nfurther increase to the complexity of the abductive reasoning tasks (which\nremains the same as for not-free programs)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111010v1", 
    "other_authors": [
        "Giovambattista Ianni", 
        "Nicola Leone", 
        "Simona Perri", 
        "Francesco Scarcello"
    ], 
    "lead_author": "Simona Perri", 
    "arxiv-id": "cs/0111010v1", 
    "title": "Abduction with Penalization in Logic Programming", 
    "publish": "2001-11-06T16:33:29Z", 
    "summary": "Abduction, first proposed in the setting of classical logics, has been\nstudied with growing interest in the logic programming area during the last\nyears.\n  In this paper we study {\\em abduction with penalization} in logic\nprogramming. This form of abductive reasoning, which has not been previously\nanalyzed in logic programming, turns out to represent several relevant\nproblems, including optimization problems, very naturally. We define a formal\nmodel for abduction with penalization from logic programs, which extends the\nabductive framework proposed by Kakas and Mancarella. We show the high\nexpressiveness of this formalism, by encoding a couple of relevant problems,\nincluding the well-know Traveling Salesman Problem from optimization theory, in\nthis abductive framework. The resulting encodings are very simple and elegant.\nWe analyze the complexity of the main decisional problems arising in this\nframework. An interesting result in this course is that ``negation comes for\nfree.'' Indeed, the addition of (even unstratified) negation does not cause any\nfurther increase to the complexity of the abductive reasoning tasks (which\nremains the same as for not-free programs)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111010v1", 
    "other_authors": [
        "Giovambattista Ianni", 
        "Nicola Leone", 
        "Simona Perri", 
        "Francesco Scarcello"
    ], 
    "lead_author": "Simona Perri", 
    "arxiv-id": "cs/0111010v1", 
    "title": "Abduction with Penalization in Logic Programming", 
    "publish": "2001-11-06T16:33:29Z", 
    "summary": "Abduction, first proposed in the setting of classical logics, has been\nstudied with growing interest in the logic programming area during the last\nyears.\n  In this paper we study {\\em abduction with penalization} in logic\nprogramming. This form of abductive reasoning, which has not been previously\nanalyzed in logic programming, turns out to represent several relevant\nproblems, including optimization problems, very naturally. We define a formal\nmodel for abduction with penalization from logic programs, which extends the\nabductive framework proposed by Kakas and Mancarella. We show the high\nexpressiveness of this formalism, by encoding a couple of relevant problems,\nincluding the well-know Traveling Salesman Problem from optimization theory, in\nthis abductive framework. The resulting encodings are very simple and elegant.\nWe analyze the complexity of the main decisional problems arising in this\nframework. An interesting result in this course is that ``negation comes for\nfree.'' Indeed, the addition of (even unstratified) negation does not cause any\nfurther increase to the complexity of the abductive reasoning tasks (which\nremains the same as for not-free programs)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111010v1", 
    "other_authors": [
        "Giovambattista Ianni", 
        "Nicola Leone", 
        "Simona Perri", 
        "Francesco Scarcello"
    ], 
    "lead_author": "Francesco Scarcello", 
    "arxiv-id": "cs/0111010v1", 
    "title": "Abduction with Penalization in Logic Programming", 
    "publish": "2001-11-06T16:33:29Z", 
    "summary": "Abduction, first proposed in the setting of classical logics, has been\nstudied with growing interest in the logic programming area during the last\nyears.\n  In this paper we study {\\em abduction with penalization} in logic\nprogramming. This form of abductive reasoning, which has not been previously\nanalyzed in logic programming, turns out to represent several relevant\nproblems, including optimization problems, very naturally. We define a formal\nmodel for abduction with penalization from logic programs, which extends the\nabductive framework proposed by Kakas and Mancarella. We show the high\nexpressiveness of this formalism, by encoding a couple of relevant problems,\nincluding the well-know Traveling Salesman Problem from optimization theory, in\nthis abductive framework. The resulting encodings are very simple and elegant.\nWe analyze the complexity of the main decisional problems arising in this\nframework. An interesting result in this course is that ``negation comes for\nfree.'' Indeed, the addition of (even unstratified) negation does not cause any\nfurther increase to the complexity of the abductive reasoning tasks (which\nremains the same as for not-free programs)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111010v1", 
    "other_authors": [
        "Giovambattista Ianni", 
        "Nicola Leone", 
        "Simona Perri", 
        "Francesco Scarcello"
    ], 
    "lead_author": "Francesco Scarcello", 
    "arxiv-id": "cs/0111010v1", 
    "title": "Abduction with Penalization in Logic Programming", 
    "publish": "2001-11-06T16:33:29Z", 
    "summary": "Abduction, first proposed in the setting of classical logics, has been\nstudied with growing interest in the logic programming area during the last\nyears.\n  In this paper we study {\\em abduction with penalization} in logic\nprogramming. This form of abductive reasoning, which has not been previously\nanalyzed in logic programming, turns out to represent several relevant\nproblems, including optimization problems, very naturally. We define a formal\nmodel for abduction with penalization from logic programs, which extends the\nabductive framework proposed by Kakas and Mancarella. We show the high\nexpressiveness of this formalism, by encoding a couple of relevant problems,\nincluding the well-know Traveling Salesman Problem from optimization theory, in\nthis abductive framework. The resulting encodings are very simple and elegant.\nWe analyze the complexity of the main decisional problems arising in this\nframework. An interesting result in this course is that ``negation comes for\nfree.'' Indeed, the addition of (even unstratified) negation does not cause any\nfurther increase to the complexity of the abductive reasoning tasks (which\nremains the same as for not-free programs)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111010v1", 
    "other_authors": [
        "Giovambattista Ianni", 
        "Nicola Leone", 
        "Simona Perri", 
        "Francesco Scarcello"
    ], 
    "lead_author": "Francesco Scarcello", 
    "arxiv-id": "cs/0111010v1", 
    "title": "Abduction with Penalization in Logic Programming", 
    "publish": "2001-11-06T16:33:29Z", 
    "summary": "Abduction, first proposed in the setting of classical logics, has been\nstudied with growing interest in the logic programming area during the last\nyears.\n  In this paper we study {\\em abduction with penalization} in logic\nprogramming. This form of abductive reasoning, which has not been previously\nanalyzed in logic programming, turns out to represent several relevant\nproblems, including optimization problems, very naturally. We define a formal\nmodel for abduction with penalization from logic programs, which extends the\nabductive framework proposed by Kakas and Mancarella. We show the high\nexpressiveness of this formalism, by encoding a couple of relevant problems,\nincluding the well-know Traveling Salesman Problem from optimization theory, in\nthis abductive framework. The resulting encodings are very simple and elegant.\nWe analyze the complexity of the main decisional problems arising in this\nframework. An interesting result in this course is that ``negation comes for\nfree.'' Indeed, the addition of (even unstratified) negation does not cause any\nfurther increase to the complexity of the abductive reasoning tasks (which\nremains the same as for not-free programs)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111010v1", 
    "other_authors": [
        "Giovambattista Ianni", 
        "Nicola Leone", 
        "Simona Perri", 
        "Francesco Scarcello"
    ], 
    "lead_author": "Francesco Scarcello", 
    "arxiv-id": "cs/0111010v1", 
    "title": "Abduction with Penalization in Logic Programming", 
    "publish": "2001-11-06T16:33:29Z", 
    "summary": "Abduction, first proposed in the setting of classical logics, has been\nstudied with growing interest in the logic programming area during the last\nyears.\n  In this paper we study {\\em abduction with penalization} in logic\nprogramming. This form of abductive reasoning, which has not been previously\nanalyzed in logic programming, turns out to represent several relevant\nproblems, including optimization problems, very naturally. We define a formal\nmodel for abduction with penalization from logic programs, which extends the\nabductive framework proposed by Kakas and Mancarella. We show the high\nexpressiveness of this formalism, by encoding a couple of relevant problems,\nincluding the well-know Traveling Salesman Problem from optimization theory, in\nthis abductive framework. The resulting encodings are very simple and elegant.\nWe analyze the complexity of the main decisional problems arising in this\nframework. An interesting result in this course is that ``negation comes for\nfree.'' Indeed, the addition of (even unstratified) negation does not cause any\nfurther increase to the complexity of the abductive reasoning tasks (which\nremains the same as for not-free programs)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111010v1", 
    "other_authors": [
        "Giovambattista Ianni", 
        "Nicola Leone", 
        "Simona Perri", 
        "Francesco Scarcello"
    ], 
    "lead_author": "Francesco Scarcello", 
    "arxiv-id": "cs/0111010v1", 
    "title": "Abduction with Penalization in Logic Programming", 
    "publish": "2001-11-06T16:33:29Z", 
    "summary": "Abduction, first proposed in the setting of classical logics, has been\nstudied with growing interest in the logic programming area during the last\nyears.\n  In this paper we study {\\em abduction with penalization} in logic\nprogramming. This form of abductive reasoning, which has not been previously\nanalyzed in logic programming, turns out to represent several relevant\nproblems, including optimization problems, very naturally. We define a formal\nmodel for abduction with penalization from logic programs, which extends the\nabductive framework proposed by Kakas and Mancarella. We show the high\nexpressiveness of this formalism, by encoding a couple of relevant problems,\nincluding the well-know Traveling Salesman Problem from optimization theory, in\nthis abductive framework. The resulting encodings are very simple and elegant.\nWe analyze the complexity of the main decisional problems arising in this\nframework. An interesting result in this course is that ``negation comes for\nfree.'' Indeed, the addition of (even unstratified) negation does not cause any\nfurther increase to the complexity of the abductive reasoning tasks (which\nremains the same as for not-free programs)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111010v1", 
    "other_authors": [
        "Giovambattista Ianni", 
        "Nicola Leone", 
        "Simona Perri", 
        "Francesco Scarcello"
    ], 
    "lead_author": "Francesco Scarcello", 
    "arxiv-id": "cs/0111010v1", 
    "title": "Abduction with Penalization in Logic Programming", 
    "publish": "2001-11-06T16:33:29Z", 
    "summary": "Abduction, first proposed in the setting of classical logics, has been\nstudied with growing interest in the logic programming area during the last\nyears.\n  In this paper we study {\\em abduction with penalization} in logic\nprogramming. This form of abductive reasoning, which has not been previously\nanalyzed in logic programming, turns out to represent several relevant\nproblems, including optimization problems, very naturally. We define a formal\nmodel for abduction with penalization from logic programs, which extends the\nabductive framework proposed by Kakas and Mancarella. We show the high\nexpressiveness of this formalism, by encoding a couple of relevant problems,\nincluding the well-know Traveling Salesman Problem from optimization theory, in\nthis abductive framework. The resulting encodings are very simple and elegant.\nWe analyze the complexity of the main decisional problems arising in this\nframework. An interesting result in this course is that ``negation comes for\nfree.'' Indeed, the addition of (even unstratified) negation does not cause any\nfurther increase to the complexity of the abductive reasoning tasks (which\nremains the same as for not-free programs)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111010v1", 
    "other_authors": [
        "Giovambattista Ianni", 
        "Nicola Leone", 
        "Simona Perri", 
        "Francesco Scarcello"
    ], 
    "lead_author": "Francesco Scarcello", 
    "arxiv-id": "cs/0111010v1", 
    "title": "Abduction with Penalization in Logic Programming", 
    "publish": "2001-11-06T16:33:29Z", 
    "summary": "Abduction, first proposed in the setting of classical logics, has been\nstudied with growing interest in the logic programming area during the last\nyears.\n  In this paper we study {\\em abduction with penalization} in logic\nprogramming. This form of abductive reasoning, which has not been previously\nanalyzed in logic programming, turns out to represent several relevant\nproblems, including optimization problems, very naturally. We define a formal\nmodel for abduction with penalization from logic programs, which extends the\nabductive framework proposed by Kakas and Mancarella. We show the high\nexpressiveness of this formalism, by encoding a couple of relevant problems,\nincluding the well-know Traveling Salesman Problem from optimization theory, in\nthis abductive framework. The resulting encodings are very simple and elegant.\nWe analyze the complexity of the main decisional problems arising in this\nframework. An interesting result in this course is that ``negation comes for\nfree.'' Indeed, the addition of (even unstratified) negation does not cause any\nfurther increase to the complexity of the abductive reasoning tasks (which\nremains the same as for not-free programs)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111010v1", 
    "other_authors": [
        "Giovambattista Ianni", 
        "Nicola Leone", 
        "Simona Perri", 
        "Francesco Scarcello"
    ], 
    "lead_author": "Francesco Scarcello", 
    "arxiv-id": "cs/0111010v1", 
    "title": "Abduction with Penalization in Logic Programming", 
    "publish": "2001-11-06T16:33:29Z", 
    "summary": "Abduction, first proposed in the setting of classical logics, has been\nstudied with growing interest in the logic programming area during the last\nyears.\n  In this paper we study {\\em abduction with penalization} in logic\nprogramming. This form of abductive reasoning, which has not been previously\nanalyzed in logic programming, turns out to represent several relevant\nproblems, including optimization problems, very naturally. We define a formal\nmodel for abduction with penalization from logic programs, which extends the\nabductive framework proposed by Kakas and Mancarella. We show the high\nexpressiveness of this formalism, by encoding a couple of relevant problems,\nincluding the well-know Traveling Salesman Problem from optimization theory, in\nthis abductive framework. The resulting encodings are very simple and elegant.\nWe analyze the complexity of the main decisional problems arising in this\nframework. An interesting result in this course is that ``negation comes for\nfree.'' Indeed, the addition of (even unstratified) negation does not cause any\nfurther increase to the complexity of the abductive reasoning tasks (which\nremains the same as for not-free programs)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111010v1", 
    "other_authors": [
        "Giovambattista Ianni", 
        "Nicola Leone", 
        "Simona Perri", 
        "Francesco Scarcello"
    ], 
    "lead_author": "Francesco Scarcello", 
    "arxiv-id": "cs/0111010v1", 
    "title": "Abduction with Penalization in Logic Programming", 
    "publish": "2001-11-06T16:33:29Z", 
    "summary": "Abduction, first proposed in the setting of classical logics, has been\nstudied with growing interest in the logic programming area during the last\nyears.\n  In this paper we study {\\em abduction with penalization} in logic\nprogramming. This form of abductive reasoning, which has not been previously\nanalyzed in logic programming, turns out to represent several relevant\nproblems, including optimization problems, very naturally. We define a formal\nmodel for abduction with penalization from logic programs, which extends the\nabductive framework proposed by Kakas and Mancarella. We show the high\nexpressiveness of this formalism, by encoding a couple of relevant problems,\nincluding the well-know Traveling Salesman Problem from optimization theory, in\nthis abductive framework. The resulting encodings are very simple and elegant.\nWe analyze the complexity of the main decisional problems arising in this\nframework. An interesting result in this course is that ``negation comes for\nfree.'' Indeed, the addition of (even unstratified) negation does not cause any\nfurther increase to the complexity of the abductive reasoning tasks (which\nremains the same as for not-free programs)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111010v1", 
    "other_authors": [
        "Giovambattista Ianni", 
        "Nicola Leone", 
        "Simona Perri", 
        "Francesco Scarcello"
    ], 
    "lead_author": "Francesco Scarcello", 
    "arxiv-id": "cs/0111010v1", 
    "title": "Abduction with Penalization in Logic Programming", 
    "publish": "2001-11-06T16:33:29Z", 
    "summary": "Abduction, first proposed in the setting of classical logics, has been\nstudied with growing interest in the logic programming area during the last\nyears.\n  In this paper we study {\\em abduction with penalization} in logic\nprogramming. This form of abductive reasoning, which has not been previously\nanalyzed in logic programming, turns out to represent several relevant\nproblems, including optimization problems, very naturally. We define a formal\nmodel for abduction with penalization from logic programs, which extends the\nabductive framework proposed by Kakas and Mancarella. We show the high\nexpressiveness of this formalism, by encoding a couple of relevant problems,\nincluding the well-know Traveling Salesman Problem from optimization theory, in\nthis abductive framework. The resulting encodings are very simple and elegant.\nWe analyze the complexity of the main decisional problems arising in this\nframework. An interesting result in this course is that ``negation comes for\nfree.'' Indeed, the addition of (even unstratified) negation does not cause any\nfurther increase to the complexity of the abductive reasoning tasks (which\nremains the same as for not-free programs)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111010v1", 
    "other_authors": [
        "Giovambattista Ianni", 
        "Nicola Leone", 
        "Simona Perri", 
        "Francesco Scarcello"
    ], 
    "lead_author": "Francesco Scarcello", 
    "arxiv-id": "cs/0111010v1", 
    "title": "Abduction with Penalization in Logic Programming", 
    "publish": "2001-11-06T16:33:29Z", 
    "summary": "Abduction, first proposed in the setting of classical logics, has been\nstudied with growing interest in the logic programming area during the last\nyears.\n  In this paper we study {\\em abduction with penalization} in logic\nprogramming. This form of abductive reasoning, which has not been previously\nanalyzed in logic programming, turns out to represent several relevant\nproblems, including optimization problems, very naturally. We define a formal\nmodel for abduction with penalization from logic programs, which extends the\nabductive framework proposed by Kakas and Mancarella. We show the high\nexpressiveness of this formalism, by encoding a couple of relevant problems,\nincluding the well-know Traveling Salesman Problem from optimization theory, in\nthis abductive framework. The resulting encodings are very simple and elegant.\nWe analyze the complexity of the main decisional problems arising in this\nframework. An interesting result in this course is that ``negation comes for\nfree.'' Indeed, the addition of (even unstratified) negation does not cause any\nfurther increase to the complexity of the abductive reasoning tasks (which\nremains the same as for not-free programs)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111010v1", 
    "other_authors": [
        "Giovambattista Ianni", 
        "Nicola Leone", 
        "Simona Perri", 
        "Francesco Scarcello"
    ], 
    "lead_author": "Francesco Scarcello", 
    "arxiv-id": "cs/0111010v1", 
    "title": "Abduction with Penalization in Logic Programming", 
    "publish": "2001-11-06T16:33:29Z", 
    "summary": "Abduction, first proposed in the setting of classical logics, has been\nstudied with growing interest in the logic programming area during the last\nyears.\n  In this paper we study {\\em abduction with penalization} in logic\nprogramming. This form of abductive reasoning, which has not been previously\nanalyzed in logic programming, turns out to represent several relevant\nproblems, including optimization problems, very naturally. We define a formal\nmodel for abduction with penalization from logic programs, which extends the\nabductive framework proposed by Kakas and Mancarella. We show the high\nexpressiveness of this formalism, by encoding a couple of relevant problems,\nincluding the well-know Traveling Salesman Problem from optimization theory, in\nthis abductive framework. The resulting encodings are very simple and elegant.\nWe analyze the complexity of the main decisional problems arising in this\nframework. An interesting result in this course is that ``negation comes for\nfree.'' Indeed, the addition of (even unstratified) negation does not cause any\nfurther increase to the complexity of the abductive reasoning tasks (which\nremains the same as for not-free programs)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111010v1", 
    "other_authors": [
        "Giovambattista Ianni", 
        "Nicola Leone", 
        "Simona Perri", 
        "Francesco Scarcello"
    ], 
    "lead_author": "Francesco Scarcello", 
    "arxiv-id": "cs/0111010v1", 
    "title": "Abduction with Penalization in Logic Programming", 
    "publish": "2001-11-06T16:33:29Z", 
    "summary": "Abduction, first proposed in the setting of classical logics, has been\nstudied with growing interest in the logic programming area during the last\nyears.\n  In this paper we study {\\em abduction with penalization} in logic\nprogramming. This form of abductive reasoning, which has not been previously\nanalyzed in logic programming, turns out to represent several relevant\nproblems, including optimization problems, very naturally. We define a formal\nmodel for abduction with penalization from logic programs, which extends the\nabductive framework proposed by Kakas and Mancarella. We show the high\nexpressiveness of this formalism, by encoding a couple of relevant problems,\nincluding the well-know Traveling Salesman Problem from optimization theory, in\nthis abductive framework. The resulting encodings are very simple and elegant.\nWe analyze the complexity of the main decisional problems arising in this\nframework. An interesting result in this course is that ``negation comes for\nfree.'' Indeed, the addition of (even unstratified) negation does not cause any\nfurther increase to the complexity of the abductive reasoning tasks (which\nremains the same as for not-free programs)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111010v1", 
    "other_authors": [
        "Giovambattista Ianni", 
        "Nicola Leone", 
        "Simona Perri", 
        "Francesco Scarcello"
    ], 
    "lead_author": "Francesco Scarcello", 
    "arxiv-id": "cs/0111010v1", 
    "title": "Abduction with Penalization in Logic Programming", 
    "publish": "2001-11-06T16:33:29Z", 
    "summary": "Abduction, first proposed in the setting of classical logics, has been\nstudied with growing interest in the logic programming area during the last\nyears.\n  In this paper we study {\\em abduction with penalization} in logic\nprogramming. This form of abductive reasoning, which has not been previously\nanalyzed in logic programming, turns out to represent several relevant\nproblems, including optimization problems, very naturally. We define a formal\nmodel for abduction with penalization from logic programs, which extends the\nabductive framework proposed by Kakas and Mancarella. We show the high\nexpressiveness of this formalism, by encoding a couple of relevant problems,\nincluding the well-know Traveling Salesman Problem from optimization theory, in\nthis abductive framework. The resulting encodings are very simple and elegant.\nWe analyze the complexity of the main decisional problems arising in this\nframework. An interesting result in this course is that ``negation comes for\nfree.'' Indeed, the addition of (even unstratified) negation does not cause any\nfurther increase to the complexity of the abductive reasoning tasks (which\nremains the same as for not-free programs)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111011v1", 
    "other_authors": [
        "Giovambattista Ianni"
    ], 
    "lead_author": "Giovambattista Ianni", 
    "arxiv-id": "cs/0111011v1", 
    "title": "Sintesi di algoritmi con SKY", 
    "publish": "2001-11-06T17:02:25Z", 
    "summary": "This paper describes the semantics and ideas about SKY, a logic programming\nlanguage intended in order to specify algorithmic strategies for the evaluation\nof problems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111011v1", 
    "other_authors": [
        "Giovambattista Ianni"
    ], 
    "lead_author": "Giovambattista Ianni", 
    "arxiv-id": "cs/0111011v1", 
    "title": "Sintesi di algoritmi con SKY", 
    "publish": "2001-11-06T17:02:25Z", 
    "summary": "This paper describes the semantics and ideas about SKY, a logic programming\nlanguage intended in order to specify algorithmic strategies for the evaluation\nof problems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111011v1", 
    "other_authors": [
        "Giovambattista Ianni"
    ], 
    "lead_author": "Giovambattista Ianni", 
    "arxiv-id": "cs/0111011v1", 
    "title": "Sintesi di algoritmi con SKY", 
    "publish": "2001-11-06T17:02:25Z", 
    "summary": "This paper describes the semantics and ideas about SKY, a logic programming\nlanguage intended in order to specify algorithmic strategies for the evaluation\nof problems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111011v1", 
    "other_authors": [
        "Giovambattista Ianni"
    ], 
    "lead_author": "Giovambattista Ianni", 
    "arxiv-id": "cs/0111011v1", 
    "title": "Sintesi di algoritmi con SKY", 
    "publish": "2001-11-06T17:02:25Z", 
    "summary": "This paper describes the semantics and ideas about SKY, a logic programming\nlanguage intended in order to specify algorithmic strategies for the evaluation\nof problems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111011v1", 
    "other_authors": [
        "Giovambattista Ianni"
    ], 
    "lead_author": "Giovambattista Ianni", 
    "arxiv-id": "cs/0111011v1", 
    "title": "Sintesi di algoritmi con SKY", 
    "publish": "2001-11-06T17:02:25Z", 
    "summary": "This paper describes the semantics and ideas about SKY, a logic programming\nlanguage intended in order to specify algorithmic strategies for the evaluation\nof problems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111011v1", 
    "other_authors": [
        "Giovambattista Ianni"
    ], 
    "lead_author": "Giovambattista Ianni", 
    "arxiv-id": "cs/0111011v1", 
    "title": "Sintesi di algoritmi con SKY", 
    "publish": "2001-11-06T17:02:25Z", 
    "summary": "This paper describes the semantics and ideas about SKY, a logic programming\nlanguage intended in order to specify algorithmic strategies for the evaluation\nof problems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111011v1", 
    "other_authors": [
        "Giovambattista Ianni"
    ], 
    "lead_author": "Giovambattista Ianni", 
    "arxiv-id": "cs/0111011v1", 
    "title": "Sintesi di algoritmi con SKY", 
    "publish": "2001-11-06T17:02:25Z", 
    "summary": "This paper describes the semantics and ideas about SKY, a logic programming\nlanguage intended in order to specify algorithmic strategies for the evaluation\nof problems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111011v1", 
    "other_authors": [
        "Giovambattista Ianni"
    ], 
    "lead_author": "Giovambattista Ianni", 
    "arxiv-id": "cs/0111011v1", 
    "title": "Sintesi di algoritmi con SKY", 
    "publish": "2001-11-06T17:02:25Z", 
    "summary": "This paper describes the semantics and ideas about SKY, a logic programming\nlanguage intended in order to specify algorithmic strategies for the evaluation\nof problems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111059v1", 
    "other_authors": [
        "Yann Loyer", 
        "Nicolas Spyratos", 
        "Daniel Stamate"
    ], 
    "lead_author": "Yann Loyer", 
    "arxiv-id": "cs/0111059v1", 
    "title": "Hypotheses Founded Semantics of Logic Programs for Information   Integration in Multi-Valued Logics", 
    "publish": "2001-11-27T17:43:20Z", 
    "summary": "We address the problem of integrating information coming from different\nsources. The information consists of facts that a central server collects and\ntries to combine using (a) a set of logical rules, i.e. a logic program, and\n(b) a hypothesis representing the server's own estimates. In such a setting\nincomplete information from a source or contradictory information from\ndifferent sources necessitate the use of many-valued logics in which programs\ncan be evaluated and hypotheses can be tested. To carry out such activities we\npropose a formal framework based on bilattices such as Belnap's four-valued\nlogics. In this framework we work with the class of programs defined by Fitting\nand we develop a theory for information integration.\n  We also establish an intuitively appealing connection between our hypothesis\ntesting mechanism on the one hand, and the well-founded semantics and\nKripke-Kleene semantics of Datalog programs with negation, on the other hand."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111059v1", 
    "other_authors": [
        "Yann Loyer", 
        "Nicolas Spyratos", 
        "Daniel Stamate"
    ], 
    "lead_author": "Yann Loyer", 
    "arxiv-id": "cs/0111059v1", 
    "title": "Hypotheses Founded Semantics of Logic Programs for Information   Integration in Multi-Valued Logics", 
    "publish": "2001-11-27T17:43:20Z", 
    "summary": "We address the problem of integrating information coming from different\nsources. The information consists of facts that a central server collects and\ntries to combine using (a) a set of logical rules, i.e. a logic program, and\n(b) a hypothesis representing the server's own estimates. In such a setting\nincomplete information from a source or contradictory information from\ndifferent sources necessitate the use of many-valued logics in which programs\ncan be evaluated and hypotheses can be tested. To carry out such activities we\npropose a formal framework based on bilattices such as Belnap's four-valued\nlogics. In this framework we work with the class of programs defined by Fitting\nand we develop a theory for information integration.\n  We also establish an intuitively appealing connection between our hypothesis\ntesting mechanism on the one hand, and the well-founded semantics and\nKripke-Kleene semantics of Datalog programs with negation, on the other hand."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111059v1", 
    "other_authors": [
        "Yann Loyer", 
        "Nicolas Spyratos", 
        "Daniel Stamate"
    ], 
    "lead_author": "Yann Loyer", 
    "arxiv-id": "cs/0111059v1", 
    "title": "Hypotheses Founded Semantics of Logic Programs for Information   Integration in Multi-Valued Logics", 
    "publish": "2001-11-27T17:43:20Z", 
    "summary": "We address the problem of integrating information coming from different\nsources. The information consists of facts that a central server collects and\ntries to combine using (a) a set of logical rules, i.e. a logic program, and\n(b) a hypothesis representing the server's own estimates. In such a setting\nincomplete information from a source or contradictory information from\ndifferent sources necessitate the use of many-valued logics in which programs\ncan be evaluated and hypotheses can be tested. To carry out such activities we\npropose a formal framework based on bilattices such as Belnap's four-valued\nlogics. In this framework we work with the class of programs defined by Fitting\nand we develop a theory for information integration.\n  We also establish an intuitively appealing connection between our hypothesis\ntesting mechanism on the one hand, and the well-founded semantics and\nKripke-Kleene semantics of Datalog programs with negation, on the other hand."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111059v1", 
    "other_authors": [
        "Yann Loyer", 
        "Nicolas Spyratos", 
        "Daniel Stamate"
    ], 
    "lead_author": "Nicolas Spyratos", 
    "arxiv-id": "cs/0111059v1", 
    "title": "Hypotheses Founded Semantics of Logic Programs for Information   Integration in Multi-Valued Logics", 
    "publish": "2001-11-27T17:43:20Z", 
    "summary": "We address the problem of integrating information coming from different\nsources. The information consists of facts that a central server collects and\ntries to combine using (a) a set of logical rules, i.e. a logic program, and\n(b) a hypothesis representing the server's own estimates. In such a setting\nincomplete information from a source or contradictory information from\ndifferent sources necessitate the use of many-valued logics in which programs\ncan be evaluated and hypotheses can be tested. To carry out such activities we\npropose a formal framework based on bilattices such as Belnap's four-valued\nlogics. In this framework we work with the class of programs defined by Fitting\nand we develop a theory for information integration.\n  We also establish an intuitively appealing connection between our hypothesis\ntesting mechanism on the one hand, and the well-founded semantics and\nKripke-Kleene semantics of Datalog programs with negation, on the other hand."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111059v1", 
    "other_authors": [
        "Yann Loyer", 
        "Nicolas Spyratos", 
        "Daniel Stamate"
    ], 
    "lead_author": "Nicolas Spyratos", 
    "arxiv-id": "cs/0111059v1", 
    "title": "Hypotheses Founded Semantics of Logic Programs for Information   Integration in Multi-Valued Logics", 
    "publish": "2001-11-27T17:43:20Z", 
    "summary": "We address the problem of integrating information coming from different\nsources. The information consists of facts that a central server collects and\ntries to combine using (a) a set of logical rules, i.e. a logic program, and\n(b) a hypothesis representing the server's own estimates. In such a setting\nincomplete information from a source or contradictory information from\ndifferent sources necessitate the use of many-valued logics in which programs\ncan be evaluated and hypotheses can be tested. To carry out such activities we\npropose a formal framework based on bilattices such as Belnap's four-valued\nlogics. In this framework we work with the class of programs defined by Fitting\nand we develop a theory for information integration.\n  We also establish an intuitively appealing connection between our hypothesis\ntesting mechanism on the one hand, and the well-founded semantics and\nKripke-Kleene semantics of Datalog programs with negation, on the other hand."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111059v1", 
    "other_authors": [
        "Yann Loyer", 
        "Nicolas Spyratos", 
        "Daniel Stamate"
    ], 
    "lead_author": "Daniel Stamate", 
    "arxiv-id": "cs/0111059v1", 
    "title": "Hypotheses Founded Semantics of Logic Programs for Information   Integration in Multi-Valued Logics", 
    "publish": "2001-11-27T17:43:20Z", 
    "summary": "We address the problem of integrating information coming from different\nsources. The information consists of facts that a central server collects and\ntries to combine using (a) a set of logical rules, i.e. a logic program, and\n(b) a hypothesis representing the server's own estimates. In such a setting\nincomplete information from a source or contradictory information from\ndifferent sources necessitate the use of many-valued logics in which programs\ncan be evaluated and hypotheses can be tested. To carry out such activities we\npropose a formal framework based on bilattices such as Belnap's four-valued\nlogics. In this framework we work with the class of programs defined by Fitting\nand we develop a theory for information integration.\n  We also establish an intuitively appealing connection between our hypothesis\ntesting mechanism on the one hand, and the well-founded semantics and\nKripke-Kleene semantics of Datalog programs with negation, on the other hand."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111059v1", 
    "other_authors": [
        "Yann Loyer", 
        "Nicolas Spyratos", 
        "Daniel Stamate"
    ], 
    "lead_author": "Daniel Stamate", 
    "arxiv-id": "cs/0111059v1", 
    "title": "Hypotheses Founded Semantics of Logic Programs for Information   Integration in Multi-Valued Logics", 
    "publish": "2001-11-27T17:43:20Z", 
    "summary": "We address the problem of integrating information coming from different\nsources. The information consists of facts that a central server collects and\ntries to combine using (a) a set of logical rules, i.e. a logic program, and\n(b) a hypothesis representing the server's own estimates. In such a setting\nincomplete information from a source or contradictory information from\ndifferent sources necessitate the use of many-valued logics in which programs\ncan be evaluated and hypotheses can be tested. To carry out such activities we\npropose a formal framework based on bilattices such as Belnap's four-valued\nlogics. In this framework we work with the class of programs defined by Fitting\nand we develop a theory for information integration.\n  We also establish an intuitively appealing connection between our hypothesis\ntesting mechanism on the one hand, and the well-founded semantics and\nKripke-Kleene semantics of Datalog programs with negation, on the other hand."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111059v1", 
    "other_authors": [
        "Yann Loyer", 
        "Nicolas Spyratos", 
        "Daniel Stamate"
    ], 
    "lead_author": "Daniel Stamate", 
    "arxiv-id": "cs/0111059v1", 
    "title": "Hypotheses Founded Semantics of Logic Programs for Information   Integration in Multi-Valued Logics", 
    "publish": "2001-11-27T17:43:20Z", 
    "summary": "We address the problem of integrating information coming from different\nsources. The information consists of facts that a central server collects and\ntries to combine using (a) a set of logical rules, i.e. a logic program, and\n(b) a hypothesis representing the server's own estimates. In such a setting\nincomplete information from a source or contradictory information from\ndifferent sources necessitate the use of many-valued logics in which programs\ncan be evaluated and hypotheses can be tested. To carry out such activities we\npropose a formal framework based on bilattices such as Belnap's four-valued\nlogics. In this framework we work with the class of programs defined by Fitting\nand we develop a theory for information integration.\n  We also establish an intuitively appealing connection between our hypothesis\ntesting mechanism on the one hand, and the well-founded semantics and\nKripke-Kleene semantics of Datalog programs with negation, on the other hand."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111059v1", 
    "other_authors": [
        "Yann Loyer", 
        "Nicolas Spyratos", 
        "Daniel Stamate"
    ], 
    "lead_author": "Daniel Stamate", 
    "arxiv-id": "cs/0111059v1", 
    "title": "Hypotheses Founded Semantics of Logic Programs for Information   Integration in Multi-Valued Logics", 
    "publish": "2001-11-27T17:43:20Z", 
    "summary": "We address the problem of integrating information coming from different\nsources. The information consists of facts that a central server collects and\ntries to combine using (a) a set of logical rules, i.e. a logic program, and\n(b) a hypothesis representing the server's own estimates. In such a setting\nincomplete information from a source or contradictory information from\ndifferent sources necessitate the use of many-valued logics in which programs\ncan be evaluated and hypotheses can be tested. To carry out such activities we\npropose a formal framework based on bilattices such as Belnap's four-valued\nlogics. In this framework we work with the class of programs defined by Fitting\nand we develop a theory for information integration.\n  We also establish an intuitively appealing connection between our hypothesis\ntesting mechanism on the one hand, and the well-founded semantics and\nKripke-Kleene semantics of Datalog programs with negation, on the other hand."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111059v1", 
    "other_authors": [
        "Yann Loyer", 
        "Nicolas Spyratos", 
        "Daniel Stamate"
    ], 
    "lead_author": "Daniel Stamate", 
    "arxiv-id": "cs/0111059v1", 
    "title": "Hypotheses Founded Semantics of Logic Programs for Information   Integration in Multi-Valued Logics", 
    "publish": "2001-11-27T17:43:20Z", 
    "summary": "We address the problem of integrating information coming from different\nsources. The information consists of facts that a central server collects and\ntries to combine using (a) a set of logical rules, i.e. a logic program, and\n(b) a hypothesis representing the server's own estimates. In such a setting\nincomplete information from a source or contradictory information from\ndifferent sources necessitate the use of many-valued logics in which programs\ncan be evaluated and hypotheses can be tested. To carry out such activities we\npropose a formal framework based on bilattices such as Belnap's four-valued\nlogics. In this framework we work with the class of programs defined by Fitting\nand we develop a theory for information integration.\n  We also establish an intuitively appealing connection between our hypothesis\ntesting mechanism on the one hand, and the well-founded semantics and\nKripke-Kleene semantics of Datalog programs with negation, on the other hand."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111059v1", 
    "other_authors": [
        "Yann Loyer", 
        "Nicolas Spyratos", 
        "Daniel Stamate"
    ], 
    "lead_author": "Daniel Stamate", 
    "arxiv-id": "cs/0111059v1", 
    "title": "Hypotheses Founded Semantics of Logic Programs for Information   Integration in Multi-Valued Logics", 
    "publish": "2001-11-27T17:43:20Z", 
    "summary": "We address the problem of integrating information coming from different\nsources. The information consists of facts that a central server collects and\ntries to combine using (a) a set of logical rules, i.e. a logic program, and\n(b) a hypothesis representing the server's own estimates. In such a setting\nincomplete information from a source or contradictory information from\ndifferent sources necessitate the use of many-valued logics in which programs\ncan be evaluated and hypotheses can be tested. To carry out such activities we\npropose a formal framework based on bilattices such as Belnap's four-valued\nlogics. In this framework we work with the class of programs defined by Fitting\nand we develop a theory for information integration.\n  We also establish an intuitively appealing connection between our hypothesis\ntesting mechanism on the one hand, and the well-founded semantics and\nKripke-Kleene semantics of Datalog programs with negation, on the other hand."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0111059v1", 
    "other_authors": [
        "Yann Loyer", 
        "Nicolas Spyratos", 
        "Daniel Stamate"
    ], 
    "lead_author": "Daniel Stamate", 
    "arxiv-id": "cs/0111059v1", 
    "title": "Hypotheses Founded Semantics of Logic Programs for Information   Integration in Multi-Valued Logics", 
    "publish": "2001-11-27T17:43:20Z", 
    "summary": "We address the problem of integrating information coming from different\nsources. The information consists of facts that a central server collects and\ntries to combine using (a) a set of logical rules, i.e. a logic program, and\n(b) a hypothesis representing the server's own estimates. In such a setting\nincomplete information from a source or contradictory information from\ndifferent sources necessitate the use of many-valued logics in which programs\ncan be evaluated and hypotheses can be tested. To carry out such activities we\npropose a formal framework based on bilattices such as Belnap's four-valued\nlogics. In this framework we work with the class of programs defined by Fitting\nand we develop a theory for information integration.\n  We also establish an intuitively appealing connection between our hypothesis\ntesting mechanism on the one hand, and the well-founded semantics and\nKripke-Kleene semantics of Datalog programs with negation, on the other hand."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204039v1", 
    "other_authors": [
        "B. Bloom", 
        "W. J. Fokkink", 
        "R. J. van Glabbeek"
    ], 
    "lead_author": "B. Bloom", 
    "arxiv-id": "cs/0204039v1", 
    "title": "Precongruence Formats for Decorated Trace Semantics", 
    "publish": "2002-04-17T00:35:04Z", 
    "summary": "This paper explores the connection between semantic equivalences and\npreorders for concrete sequential processes, represented by means of labelled\ntransition systems, and formats of transition system specifications using\nPlotkin's structural approach. For several preorders in the linear time -\nbranching time spectrum a format is given, as general as possible, such that\nthis preorder is a precongruence for all operators specifiable in that format.\nThe formats are derived using the modal characterizations of the corresponding\npreorders."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204039v1", 
    "other_authors": [
        "B. Bloom", 
        "W. J. Fokkink", 
        "R. J. van Glabbeek"
    ], 
    "lead_author": "B. Bloom", 
    "arxiv-id": "cs/0204039v1", 
    "title": "Precongruence Formats for Decorated Trace Semantics", 
    "publish": "2002-04-17T00:35:04Z", 
    "summary": "This paper explores the connection between semantic equivalences and\npreorders for concrete sequential processes, represented by means of labelled\ntransition systems, and formats of transition system specifications using\nPlotkin's structural approach. For several preorders in the linear time -\nbranching time spectrum a format is given, as general as possible, such that\nthis preorder is a precongruence for all operators specifiable in that format.\nThe formats are derived using the modal characterizations of the corresponding\npreorders."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204039v1", 
    "other_authors": [
        "B. Bloom", 
        "W. J. Fokkink", 
        "R. J. van Glabbeek"
    ], 
    "lead_author": "B. Bloom", 
    "arxiv-id": "cs/0204039v1", 
    "title": "Precongruence Formats for Decorated Trace Semantics", 
    "publish": "2002-04-17T00:35:04Z", 
    "summary": "This paper explores the connection between semantic equivalences and\npreorders for concrete sequential processes, represented by means of labelled\ntransition systems, and formats of transition system specifications using\nPlotkin's structural approach. For several preorders in the linear time -\nbranching time spectrum a format is given, as general as possible, such that\nthis preorder is a precongruence for all operators specifiable in that format.\nThe formats are derived using the modal characterizations of the corresponding\npreorders."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204039v1", 
    "other_authors": [
        "B. Bloom", 
        "W. J. Fokkink", 
        "R. J. van Glabbeek"
    ], 
    "lead_author": "B. Bloom", 
    "arxiv-id": "cs/0204039v1", 
    "title": "Precongruence Formats for Decorated Trace Semantics", 
    "publish": "2002-04-17T00:35:04Z", 
    "summary": "This paper explores the connection between semantic equivalences and\npreorders for concrete sequential processes, represented by means of labelled\ntransition systems, and formats of transition system specifications using\nPlotkin's structural approach. For several preorders in the linear time -\nbranching time spectrum a format is given, as general as possible, such that\nthis preorder is a precongruence for all operators specifiable in that format.\nThe formats are derived using the modal characterizations of the corresponding\npreorders."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204039v1", 
    "other_authors": [
        "B. Bloom", 
        "W. J. Fokkink", 
        "R. J. van Glabbeek"
    ], 
    "lead_author": "B. Bloom", 
    "arxiv-id": "cs/0204039v1", 
    "title": "Precongruence Formats for Decorated Trace Semantics", 
    "publish": "2002-04-17T00:35:04Z", 
    "summary": "This paper explores the connection between semantic equivalences and\npreorders for concrete sequential processes, represented by means of labelled\ntransition systems, and formats of transition system specifications using\nPlotkin's structural approach. For several preorders in the linear time -\nbranching time spectrum a format is given, as general as possible, such that\nthis preorder is a precongruence for all operators specifiable in that format.\nThe formats are derived using the modal characterizations of the corresponding\npreorders."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204039v1", 
    "other_authors": [
        "B. Bloom", 
        "W. J. Fokkink", 
        "R. J. van Glabbeek"
    ], 
    "lead_author": "B. Bloom", 
    "arxiv-id": "cs/0204039v1", 
    "title": "Precongruence Formats for Decorated Trace Semantics", 
    "publish": "2002-04-17T00:35:04Z", 
    "summary": "This paper explores the connection between semantic equivalences and\npreorders for concrete sequential processes, represented by means of labelled\ntransition systems, and formats of transition system specifications using\nPlotkin's structural approach. For several preorders in the linear time -\nbranching time spectrum a format is given, as general as possible, such that\nthis preorder is a precongruence for all operators specifiable in that format.\nThe formats are derived using the modal characterizations of the corresponding\npreorders."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204039v1", 
    "other_authors": [
        "B. Bloom", 
        "W. J. Fokkink", 
        "R. J. van Glabbeek"
    ], 
    "lead_author": "B. Bloom", 
    "arxiv-id": "cs/0204039v1", 
    "title": "Precongruence Formats for Decorated Trace Semantics", 
    "publish": "2002-04-17T00:35:04Z", 
    "summary": "This paper explores the connection between semantic equivalences and\npreorders for concrete sequential processes, represented by means of labelled\ntransition systems, and formats of transition system specifications using\nPlotkin's structural approach. For several preorders in the linear time -\nbranching time spectrum a format is given, as general as possible, such that\nthis preorder is a precongruence for all operators specifiable in that format.\nThe formats are derived using the modal characterizations of the corresponding\npreorders."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204039v1", 
    "other_authors": [
        "B. Bloom", 
        "W. J. Fokkink", 
        "R. J. van Glabbeek"
    ], 
    "lead_author": "B. Bloom", 
    "arxiv-id": "cs/0204039v1", 
    "title": "Precongruence Formats for Decorated Trace Semantics", 
    "publish": "2002-04-17T00:35:04Z", 
    "summary": "This paper explores the connection between semantic equivalences and\npreorders for concrete sequential processes, represented by means of labelled\ntransition systems, and formats of transition system specifications using\nPlotkin's structural approach. For several preorders in the linear time -\nbranching time spectrum a format is given, as general as possible, such that\nthis preorder is a precongruence for all operators specifiable in that format.\nThe formats are derived using the modal characterizations of the corresponding\npreorders."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Aleksandar Ignjatovic", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Aleksandar Ignjatovic", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Aleksandar Ignjatovic", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Aleksandar Ignjatovic", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Aleksandar Ignjatovic", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Aleksandar Ignjatovic", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Aleksandar Ignjatovic", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Aleksandar Ignjatovic", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0204045v1", 
    "other_authors": [
        "Aleksandar Ignjatovic", 
        "Arun Sharma"
    ], 
    "lead_author": "Arun Sharma", 
    "arxiv-id": "cs/0204045v1", 
    "title": "Some applications of logic to feasibility in higher types", 
    "publish": "2002-04-22T06:58:56Z", 
    "summary": "In this paper we demonstrate that the class of basic feasible functionals has\nrecursion theoretic properties which naturally generalize the corresponding\nproperties of the class of feasible functions. We also improve the Kapron -\nCook result on mashine representation of basic feasible functionals. Our proofs\nare based on essential applications of logic. We introduce a weak fragment of\nsecond order arithmetic with second order variables ranging over functions from\nN into N which suitably characterizes basic feasible functionals, and show that\nit is a useful tool for investigating the properties of basic feasible\nfunctionals. In particular, we provide an example how one can extract feasible\n\"programs\" from mathematical proofs which use non-feasible functionals (like\nsecond order polynomials)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Samuel R. Buss", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Samuel R. Buss", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Anand Pillay", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Anand Pillay", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Anand Pillay", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Anand Pillay", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Anand Pillay", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Anand Pillay", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Anand Pillay", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Anand Pillay", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Anand Pillay", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Anand Pillay", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Anand Pillay", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Anand Pillay", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Anand Pillay", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Anand Pillay", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Anand Pillay", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Anand Pillay", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Anand Pillay", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Anand Pillay", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Anand Pillay", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Anand Pillay", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Anand Pillay", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Anand Pillay", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Anand Pillay", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Anand Pillay", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Anand Pillay", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Anand Pillay", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Anand Pillay", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Anand Pillay", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Anand Pillay", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Anand Pillay", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Anand Pillay", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Anand Pillay", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Anand Pillay", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Anand Pillay", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Anand Pillay", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Anand Pillay", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Anand Pillay", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Anand Pillay", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Anand Pillay", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Anand Pillay", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Anand Pillay", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Anand Pillay", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Anand Pillay", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Anand Pillay", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Anand Pillay", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Anand Pillay", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Anand Pillay", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Anand Pillay", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Anand Pillay", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Anand Pillay", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Anand Pillay", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Anand Pillay", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Anand Pillay", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Anand Pillay", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Anand Pillay", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Anand Pillay", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Anand Pillay", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Anand Pillay", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Anand Pillay", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Anand Pillay", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Richard A. Shore", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Richard A. Shore", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Richard A. Shore", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Richard A. Shore", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Richard A. Shore", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Richard A. Shore", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Richard A. Shore", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Richard A. Shore", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Richard A. Shore", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Richard A. Shore", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0205003v1", 
    "other_authors": [
        "Samuel R. Buss", 
        "Alexander S. Kechris", 
        "Anand Pillay", 
        "Richard A. Shore"
    ], 
    "lead_author": "Richard A. Shore", 
    "arxiv-id": "cs/0205003v1", 
    "title": "The prospects for mathematical logic in the twenty-first century", 
    "publish": "2002-05-03T22:36:23Z", 
    "summary": "The four authors present their speculations about the future developments of\nmathematical logic in the twenty-first century. The areas of recursion theory,\nproof theory and logic for computer science, model theory, and set theory are\ndiscussed independently."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0206005v1", 
    "other_authors": [
        "Dick de Jongh", 
        "Lex Hendriks"
    ], 
    "lead_author": "Dick de Jongh", 
    "arxiv-id": "cs/0206005v1", 
    "title": "Characterization of Strongly Equivalent Logic Programs in Intermediate   Logics", 
    "publish": "2002-06-03T14:48:41Z", 
    "summary": "The non-classical, nonmonotonic inference relation associated with the answer\nset semantics for logic programs gives rise to a relationship of 'strong\nequivalence' between logical programs that can be verified in 3-valued Goedel\nlogic, G3, the strongest non-classical intermediate propositional logic\n(Lifschitz, Pearce and Valverde, 2001). In this paper we will show that KC (the\nlogic obtained by adding axiom ~A v ~~A to intuitionistic logic), is the\nweakest intermediate logic for which strongly equivalent logic programs, in a\nlanguage allowing negations, are logically equivalent."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0206005v1", 
    "other_authors": [
        "Dick de Jongh", 
        "Lex Hendriks"
    ], 
    "lead_author": "Dick de Jongh", 
    "arxiv-id": "cs/0206005v1", 
    "title": "Characterization of Strongly Equivalent Logic Programs in Intermediate   Logics", 
    "publish": "2002-06-03T14:48:41Z", 
    "summary": "The non-classical, nonmonotonic inference relation associated with the answer\nset semantics for logic programs gives rise to a relationship of 'strong\nequivalence' between logical programs that can be verified in 3-valued Goedel\nlogic, G3, the strongest non-classical intermediate propositional logic\n(Lifschitz, Pearce and Valverde, 2001). In this paper we will show that KC (the\nlogic obtained by adding axiom ~A v ~~A to intuitionistic logic), is the\nweakest intermediate logic for which strongly equivalent logic programs, in a\nlanguage allowing negations, are logically equivalent."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0206005v1", 
    "other_authors": [
        "Dick de Jongh", 
        "Lex Hendriks"
    ], 
    "lead_author": "Lex Hendriks", 
    "arxiv-id": "cs/0206005v1", 
    "title": "Characterization of Strongly Equivalent Logic Programs in Intermediate   Logics", 
    "publish": "2002-06-03T14:48:41Z", 
    "summary": "The non-classical, nonmonotonic inference relation associated with the answer\nset semantics for logic programs gives rise to a relationship of 'strong\nequivalence' between logical programs that can be verified in 3-valued Goedel\nlogic, G3, the strongest non-classical intermediate propositional logic\n(Lifschitz, Pearce and Valverde, 2001). In this paper we will show that KC (the\nlogic obtained by adding axiom ~A v ~~A to intuitionistic logic), is the\nweakest intermediate logic for which strongly equivalent logic programs, in a\nlanguage allowing negations, are logically equivalent."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0206005v1", 
    "other_authors": [
        "Dick de Jongh", 
        "Lex Hendriks"
    ], 
    "lead_author": "Lex Hendriks", 
    "arxiv-id": "cs/0206005v1", 
    "title": "Characterization of Strongly Equivalent Logic Programs in Intermediate   Logics", 
    "publish": "2002-06-03T14:48:41Z", 
    "summary": "The non-classical, nonmonotonic inference relation associated with the answer\nset semantics for logic programs gives rise to a relationship of 'strong\nequivalence' between logical programs that can be verified in 3-valued Goedel\nlogic, G3, the strongest non-classical intermediate propositional logic\n(Lifschitz, Pearce and Valverde, 2001). In this paper we will show that KC (the\nlogic obtained by adding axiom ~A v ~~A to intuitionistic logic), is the\nweakest intermediate logic for which strongly equivalent logic programs, in a\nlanguage allowing negations, are logically equivalent."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0206005v1", 
    "other_authors": [
        "Dick de Jongh", 
        "Lex Hendriks"
    ], 
    "lead_author": "Lex Hendriks", 
    "arxiv-id": "cs/0206005v1", 
    "title": "Characterization of Strongly Equivalent Logic Programs in Intermediate   Logics", 
    "publish": "2002-06-03T14:48:41Z", 
    "summary": "The non-classical, nonmonotonic inference relation associated with the answer\nset semantics for logic programs gives rise to a relationship of 'strong\nequivalence' between logical programs that can be verified in 3-valued Goedel\nlogic, G3, the strongest non-classical intermediate propositional logic\n(Lifschitz, Pearce and Valverde, 2001). In this paper we will show that KC (the\nlogic obtained by adding axiom ~A v ~~A to intuitionistic logic), is the\nweakest intermediate logic for which strongly equivalent logic programs, in a\nlanguage allowing negations, are logically equivalent."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207068v1", 
    "other_authors": [
        "Konstantin Korovin", 
        "Andrei Voronkov"
    ], 
    "lead_author": "Konstantin Korovin", 
    "arxiv-id": "cs/0207068v1", 
    "title": "Knuth-Bendix constraint solving is NP-complete", 
    "publish": "2002-07-17T18:34:45Z", 
    "summary": "We show the NP-completeness of the existential theory of term algebras with\nthe Knuth-Bendix order by giving a nondeterministic polynomial-time algorithm\nfor solving Knuth-Bendix ordering constraints."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207068v1", 
    "other_authors": [
        "Konstantin Korovin", 
        "Andrei Voronkov"
    ], 
    "lead_author": "Konstantin Korovin", 
    "arxiv-id": "cs/0207068v1", 
    "title": "Knuth-Bendix constraint solving is NP-complete", 
    "publish": "2002-07-17T18:34:45Z", 
    "summary": "We show the NP-completeness of the existential theory of term algebras with\nthe Knuth-Bendix order by giving a nondeterministic polynomial-time algorithm\nfor solving Knuth-Bendix ordering constraints."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207068v1", 
    "other_authors": [
        "Konstantin Korovin", 
        "Andrei Voronkov"
    ], 
    "lead_author": "Andrei Voronkov", 
    "arxiv-id": "cs/0207068v1", 
    "title": "Knuth-Bendix constraint solving is NP-complete", 
    "publish": "2002-07-17T18:34:45Z", 
    "summary": "We show the NP-completeness of the existential theory of term algebras with\nthe Knuth-Bendix order by giving a nondeterministic polynomial-time algorithm\nfor solving Knuth-Bendix ordering constraints."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207068v1", 
    "other_authors": [
        "Konstantin Korovin", 
        "Andrei Voronkov"
    ], 
    "lead_author": "Andrei Voronkov", 
    "arxiv-id": "cs/0207068v1", 
    "title": "Knuth-Bendix constraint solving is NP-complete", 
    "publish": "2002-07-17T18:34:45Z", 
    "summary": "We show the NP-completeness of the existential theory of term algebras with\nthe Knuth-Bendix order by giving a nondeterministic polynomial-time algorithm\nfor solving Knuth-Bendix ordering constraints."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207068v1", 
    "other_authors": [
        "Konstantin Korovin", 
        "Andrei Voronkov"
    ], 
    "lead_author": "Andrei Voronkov", 
    "arxiv-id": "cs/0207068v1", 
    "title": "Knuth-Bendix constraint solving is NP-complete", 
    "publish": "2002-07-17T18:34:45Z", 
    "summary": "We show the NP-completeness of the existential theory of term algebras with\nthe Knuth-Bendix order by giving a nondeterministic polynomial-time algorithm\nfor solving Knuth-Bendix ordering constraints."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207068v1", 
    "other_authors": [
        "Konstantin Korovin", 
        "Andrei Voronkov"
    ], 
    "lead_author": "Andrei Voronkov", 
    "arxiv-id": "cs/0207068v1", 
    "title": "Knuth-Bendix constraint solving is NP-complete", 
    "publish": "2002-07-17T18:34:45Z", 
    "summary": "We show the NP-completeness of the existential theory of term algebras with\nthe Knuth-Bendix order by giving a nondeterministic polynomial-time algorithm\nfor solving Knuth-Bendix ordering constraints."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207068v1", 
    "other_authors": [
        "Konstantin Korovin", 
        "Andrei Voronkov"
    ], 
    "lead_author": "Andrei Voronkov", 
    "arxiv-id": "cs/0207068v1", 
    "title": "Knuth-Bendix constraint solving is NP-complete", 
    "publish": "2002-07-17T18:34:45Z", 
    "summary": "We show the NP-completeness of the existential theory of term algebras with\nthe Knuth-Bendix order by giving a nondeterministic polynomial-time algorithm\nfor solving Knuth-Bendix ordering constraints."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207068v1", 
    "other_authors": [
        "Konstantin Korovin", 
        "Andrei Voronkov"
    ], 
    "lead_author": "Andrei Voronkov", 
    "arxiv-id": "cs/0207068v1", 
    "title": "Knuth-Bendix constraint solving is NP-complete", 
    "publish": "2002-07-17T18:34:45Z", 
    "summary": "We show the NP-completeness of the existential theory of term algebras with\nthe Knuth-Bendix order by giving a nondeterministic polynomial-time algorithm\nfor solving Knuth-Bendix ordering constraints."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207068v1", 
    "other_authors": [
        "Konstantin Korovin", 
        "Andrei Voronkov"
    ], 
    "lead_author": "Andrei Voronkov", 
    "arxiv-id": "cs/0207068v1", 
    "title": "Knuth-Bendix constraint solving is NP-complete", 
    "publish": "2002-07-17T18:34:45Z", 
    "summary": "We show the NP-completeness of the existential theory of term algebras with\nthe Knuth-Bendix order by giving a nondeterministic polynomial-time algorithm\nfor solving Knuth-Bendix ordering constraints."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207068v1", 
    "other_authors": [
        "Konstantin Korovin", 
        "Andrei Voronkov"
    ], 
    "lead_author": "Andrei Voronkov", 
    "arxiv-id": "cs/0207068v1", 
    "title": "Knuth-Bendix constraint solving is NP-complete", 
    "publish": "2002-07-17T18:34:45Z", 
    "summary": "We show the NP-completeness of the existential theory of term algebras with\nthe Knuth-Bendix order by giving a nondeterministic polynomial-time algorithm\nfor solving Knuth-Bendix ordering constraints."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207068v1", 
    "other_authors": [
        "Konstantin Korovin", 
        "Andrei Voronkov"
    ], 
    "lead_author": "Andrei Voronkov", 
    "arxiv-id": "cs/0207068v1", 
    "title": "Knuth-Bendix constraint solving is NP-complete", 
    "publish": "2002-07-17T18:34:45Z", 
    "summary": "We show the NP-completeness of the existential theory of term algebras with\nthe Knuth-Bendix order by giving a nondeterministic polynomial-time algorithm\nfor solving Knuth-Bendix ordering constraints."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Dina Goldin", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Peter Wegner", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Peter Wegner", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Peter Wegner", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Peter Wegner", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Peter Wegner", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Peter Wegner", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Peter Wegner", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Peter Wegner", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Peter Wegner", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Peter Wegner", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Peter Wegner", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Peter Wegner", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207074v1", 
    "other_authors": [
        "Dina Goldin", 
        "Peter Wegner"
    ], 
    "lead_author": "Peter Wegner", 
    "arxiv-id": "cs/0207074v1", 
    "title": "Paraconsistency of Interactive Computation", 
    "publish": "2002-07-21T06:19:23Z", 
    "summary": "The goal of computational logic is to allow us to model computation as well\nas to reason about it. We argue that a computational logic must be able to\nmodel interactive computation. We show that first-order logic cannot model\ninteractive computation due to the incompleteness of interaction. We show that\ninteractive computation is necessarily paraconsistent, able to model both a\nfact and its negation, due to the role of the world (environment) in\ndetermining the course of the computation. We conclude that paraconsistency is\na necessary property for a logic that can model interactive computation."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207086v1", 
    "other_authors": [
        "Michael J. Maher"
    ], 
    "lead_author": "Michael J. Maher", 
    "arxiv-id": "cs/0207086v1", 
    "title": "A Model-Theoretic Semantics for Defeasible Logic", 
    "publish": "2002-07-25T15:39:01Z", 
    "summary": "Defeasible logic is an efficient logic for defeasible reasoning. It is\ndefined through a proof theory and, until now, has had no model theory. In this\npaper a model-theoretic semantics is given for defeasible logic. The logic is\nsound and complete with respect to the semantics. We also briefly outline how\nthis approach extends to a wide range of defeasible logics."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207086v1", 
    "other_authors": [
        "Michael J. Maher"
    ], 
    "lead_author": "Michael J. Maher", 
    "arxiv-id": "cs/0207086v1", 
    "title": "A Model-Theoretic Semantics for Defeasible Logic", 
    "publish": "2002-07-25T15:39:01Z", 
    "summary": "Defeasible logic is an efficient logic for defeasible reasoning. It is\ndefined through a proof theory and, until now, has had no model theory. In this\npaper a model-theoretic semantics is given for defeasible logic. The logic is\nsound and complete with respect to the semantics. We also briefly outline how\nthis approach extends to a wide range of defeasible logics."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207086v1", 
    "other_authors": [
        "Michael J. Maher"
    ], 
    "lead_author": "Michael J. Maher", 
    "arxiv-id": "cs/0207086v1", 
    "title": "A Model-Theoretic Semantics for Defeasible Logic", 
    "publish": "2002-07-25T15:39:01Z", 
    "summary": "Defeasible logic is an efficient logic for defeasible reasoning. It is\ndefined through a proof theory and, until now, has had no model theory. In this\npaper a model-theoretic semantics is given for defeasible logic. The logic is\nsound and complete with respect to the semantics. We also briefly outline how\nthis approach extends to a wide range of defeasible logics."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207086v1", 
    "other_authors": [
        "Michael J. Maher"
    ], 
    "lead_author": "Michael J. Maher", 
    "arxiv-id": "cs/0207086v1", 
    "title": "A Model-Theoretic Semantics for Defeasible Logic", 
    "publish": "2002-07-25T15:39:01Z", 
    "summary": "Defeasible logic is an efficient logic for defeasible reasoning. It is\ndefined through a proof theory and, until now, has had no model theory. In this\npaper a model-theoretic semantics is given for defeasible logic. The logic is\nsound and complete with respect to the semantics. We also briefly outline how\nthis approach extends to a wide range of defeasible logics."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207086v1", 
    "other_authors": [
        "Michael J. Maher"
    ], 
    "lead_author": "Michael J. Maher", 
    "arxiv-id": "cs/0207086v1", 
    "title": "A Model-Theoretic Semantics for Defeasible Logic", 
    "publish": "2002-07-25T15:39:01Z", 
    "summary": "Defeasible logic is an efficient logic for defeasible reasoning. It is\ndefined through a proof theory and, until now, has had no model theory. In this\npaper a model-theoretic semantics is given for defeasible logic. The logic is\nsound and complete with respect to the semantics. We also briefly outline how\nthis approach extends to a wide range of defeasible logics."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207086v1", 
    "other_authors": [
        "Michael J. Maher"
    ], 
    "lead_author": "Michael J. Maher", 
    "arxiv-id": "cs/0207086v1", 
    "title": "A Model-Theoretic Semantics for Defeasible Logic", 
    "publish": "2002-07-25T15:39:01Z", 
    "summary": "Defeasible logic is an efficient logic for defeasible reasoning. It is\ndefined through a proof theory and, until now, has had no model theory. In this\npaper a model-theoretic semantics is given for defeasible logic. The logic is\nsound and complete with respect to the semantics. We also briefly outline how\nthis approach extends to a wide range of defeasible logics."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207086v1", 
    "other_authors": [
        "Michael J. Maher"
    ], 
    "lead_author": "Michael J. Maher", 
    "arxiv-id": "cs/0207086v1", 
    "title": "A Model-Theoretic Semantics for Defeasible Logic", 
    "publish": "2002-07-25T15:39:01Z", 
    "summary": "Defeasible logic is an efficient logic for defeasible reasoning. It is\ndefined through a proof theory and, until now, has had no model theory. In this\npaper a model-theoretic semantics is given for defeasible logic. The logic is\nsound and complete with respect to the semantics. We also briefly outline how\nthis approach extends to a wide range of defeasible logics."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207086v1", 
    "other_authors": [
        "Michael J. Maher"
    ], 
    "lead_author": "Michael J. Maher", 
    "arxiv-id": "cs/0207086v1", 
    "title": "A Model-Theoretic Semantics for Defeasible Logic", 
    "publish": "2002-07-25T15:39:01Z", 
    "summary": "Defeasible logic is an efficient logic for defeasible reasoning. It is\ndefined through a proof theory and, until now, has had no model theory. In this\npaper a model-theoretic semantics is given for defeasible logic. The logic is\nsound and complete with respect to the semantics. We also briefly outline how\nthis approach extends to a wide range of defeasible logics."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207086v1", 
    "other_authors": [
        "Michael J. Maher"
    ], 
    "lead_author": "Michael J. Maher", 
    "arxiv-id": "cs/0207086v1", 
    "title": "A Model-Theoretic Semantics for Defeasible Logic", 
    "publish": "2002-07-25T15:39:01Z", 
    "summary": "Defeasible logic is an efficient logic for defeasible reasoning. It is\ndefined through a proof theory and, until now, has had no model theory. In this\npaper a model-theoretic semantics is given for defeasible logic. The logic is\nsound and complete with respect to the semantics. We also briefly outline how\nthis approach extends to a wide range of defeasible logics."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207086v1", 
    "other_authors": [
        "Michael J. Maher"
    ], 
    "lead_author": "Michael J. Maher", 
    "arxiv-id": "cs/0207086v1", 
    "title": "A Model-Theoretic Semantics for Defeasible Logic", 
    "publish": "2002-07-25T15:39:01Z", 
    "summary": "Defeasible logic is an efficient logic for defeasible reasoning. It is\ndefined through a proof theory and, until now, has had no model theory. In this\npaper a model-theoretic semantics is given for defeasible logic. The logic is\nsound and complete with respect to the semantics. We also briefly outline how\nthis approach extends to a wide range of defeasible logics."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207086v1", 
    "other_authors": [
        "Michael J. Maher"
    ], 
    "lead_author": "Michael J. Maher", 
    "arxiv-id": "cs/0207086v1", 
    "title": "A Model-Theoretic Semantics for Defeasible Logic", 
    "publish": "2002-07-25T15:39:01Z", 
    "summary": "Defeasible logic is an efficient logic for defeasible reasoning. It is\ndefined through a proof theory and, until now, has had no model theory. In this\npaper a model-theoretic semantics is given for defeasible logic. The logic is\nsound and complete with respect to the semantics. We also briefly outline how\nthis approach extends to a wide range of defeasible logics."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207086v1", 
    "other_authors": [
        "Michael J. Maher"
    ], 
    "lead_author": "Michael J. Maher", 
    "arxiv-id": "cs/0207086v1", 
    "title": "A Model-Theoretic Semantics for Defeasible Logic", 
    "publish": "2002-07-25T15:39:01Z", 
    "summary": "Defeasible logic is an efficient logic for defeasible reasoning. It is\ndefined through a proof theory and, until now, has had no model theory. In this\npaper a model-theoretic semantics is given for defeasible logic. The logic is\nsound and complete with respect to the semantics. We also briefly outline how\nthis approach extends to a wide range of defeasible logics."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207086v1", 
    "other_authors": [
        "Michael J. Maher"
    ], 
    "lead_author": "Michael J. Maher", 
    "arxiv-id": "cs/0207086v1", 
    "title": "A Model-Theoretic Semantics for Defeasible Logic", 
    "publish": "2002-07-25T15:39:01Z", 
    "summary": "Defeasible logic is an efficient logic for defeasible reasoning. It is\ndefined through a proof theory and, until now, has had no model theory. In this\npaper a model-theoretic semantics is given for defeasible logic. The logic is\nsound and complete with respect to the semantics. We also briefly outline how\nthis approach extends to a wide range of defeasible logics."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207086v1", 
    "other_authors": [
        "Michael J. Maher"
    ], 
    "lead_author": "Michael J. Maher", 
    "arxiv-id": "cs/0207086v1", 
    "title": "A Model-Theoretic Semantics for Defeasible Logic", 
    "publish": "2002-07-25T15:39:01Z", 
    "summary": "Defeasible logic is an efficient logic for defeasible reasoning. It is\ndefined through a proof theory and, until now, has had no model theory. In this\npaper a model-theoretic semantics is given for defeasible logic. The logic is\nsound and complete with respect to the semantics. We also briefly outline how\nthis approach extends to a wide range of defeasible logics."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207086v1", 
    "other_authors": [
        "Michael J. Maher"
    ], 
    "lead_author": "Michael J. Maher", 
    "arxiv-id": "cs/0207086v1", 
    "title": "A Model-Theoretic Semantics for Defeasible Logic", 
    "publish": "2002-07-25T15:39:01Z", 
    "summary": "Defeasible logic is an efficient logic for defeasible reasoning. It is\ndefined through a proof theory and, until now, has had no model theory. In this\npaper a model-theoretic semantics is given for defeasible logic. The logic is\nsound and complete with respect to the semantics. We also briefly outline how\nthis approach extends to a wide range of defeasible logics."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207086v1", 
    "other_authors": [
        "Michael J. Maher"
    ], 
    "lead_author": "Michael J. Maher", 
    "arxiv-id": "cs/0207086v1", 
    "title": "A Model-Theoretic Semantics for Defeasible Logic", 
    "publish": "2002-07-25T15:39:01Z", 
    "summary": "Defeasible logic is an efficient logic for defeasible reasoning. It is\ndefined through a proof theory and, until now, has had no model theory. In this\npaper a model-theoretic semantics is given for defeasible logic. The logic is\nsound and complete with respect to the semantics. We also briefly outline how\nthis approach extends to a wide range of defeasible logics."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207087v1", 
    "other_authors": [
        "Guo-Qiang Zhang"
    ], 
    "lead_author": "Guo-Qiang Zhang", 
    "arxiv-id": "cs/0207087v1", 
    "title": "Axiomatic Aspects of Default Inference", 
    "publish": "2002-07-25T16:19:51Z", 
    "summary": "This paper studies axioms for nonmonotonic consequences from a\nsemantics-based point of view, focusing on a class of mathematical structures\nfor reasoning about partial information without a predefined syntax/logic. This\nstructure is called a default structure. We study axioms for the nonmonotonic\nconsequence relation derived from extensions as in Reiter's default logic,\nusing skeptical reasoning, but extensions are now used for the construction of\npossible worlds in a default information structure.\n  In previous work we showed that skeptical reasoning arising from\ndefault-extensions obeys a well-behaved set of axioms including the axiom of\ncautious cut. We show here that, remarkably, the converse is also true: any\nconsequence relation obeying this set of axioms can be represented as one\nconstructed from skeptical reasoning. We provide representation theorems to\nrelate axioms for nonmonotonic consequence relation and properties about\nextensions, and provide one-to-one correspondence between nonmonotonic systems\nwhich satisfies the law of cautious monotony and default structures with unique\nextensions. Our results give a theoretical justification for a set of basic\nrules governing the update of nonmonotonic knowledge bases, demonstrating the\nderivation of them from the more concrete and primitive construction of\nextensions. It is also striking to note that proofs of the representation\ntheorems show that only shallow extensions are necessary, in the sense that the\nnumber of iterations needed to achieve an extension is at most three. All of\nthese developments are made possible by taking a more liberal view of\nconsistency: consistency is a user defined predicate, satisfying some basic\nproperties."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207090v1", 
    "other_authors": [
        "Diderik Batens"
    ], 
    "lead_author": "Diderik Batens", 
    "arxiv-id": "cs/0207090v1", 
    "title": "On a Partial Decision Method for Dynamic Proofs", 
    "publish": "2002-07-25T17:14:16Z", 
    "summary": "This paper concerns a goal directed proof procedure for the propositional\nfragment of the adaptive logic ACLuN1. At the propositional level, it forms an\nalgorithm for final derivability. If extended to the predicative level, it\nprovides a criterion for final derivability. This is essential in view of the\nabsence of a positive test. The procedure may be generalized to all flat\nadaptive logics."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0207091v1", 
    "other_authors": [
        "Fran\u00e7ois Bry"
    ], 
    "lead_author": "Fran\u00e7ois Bry", 
    "arxiv-id": "cs/0207091v1", 
    "title": "An Almost Classical Logic for Logic Programming and Nonmonotonic   Reasoning", 
    "publish": "2002-07-25T17:40:14Z", 
    "summary": "The model theory of a first-order logic called N^4 is introduced. N^4 does\nnot eliminate double negations, as classical logic does, but instead reduces\nfourfold negations. N^4 is very close to classical logic: N^4 has two truth\nvalues; implications in N^4 are material, like in classical logic; and negation\ndistributes over compound formulas in N^4 as it does in classical logic.\nResults suggest that the semantics of normal logic programs is conveniently\nformalized in N^4: Classical logic Herbrand interpretations generalize\nstraightforwardly to N^4; the classical minimal Herbrand model of a positive\nlogic program coincides with its unique minimal N^4 Herbrand model; the stable\nmodels of a normal logic program and its so-called complete minimal N^4\nHerbrand models coincide."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0208032v2", 
    "other_authors": [
        "K. R. Apt", 
        "C. F. M. Vermeulen"
    ], 
    "lead_author": "C. F. M. Vermeulen", 
    "arxiv-id": "cs/0208032v2", 
    "title": "First-order Logic as a Constraint Programming Language", 
    "publish": "2002-08-20T14:53:37Z", 
    "summary": "We provide a denotational semantics for first-order logic that captures the\ntwo-level view of the computation process typical for constraint programming.\nAt one level we have the usual program execution. At the other level an\nautomatic maintenance of the constraint store takes place. We prove that the\nresulting semantics is sound with respect to the truth definition. By\ninstantiating it by specific forms of constraint management policies we obtain\nseveral sound evaluation policies of first-order formulas. This semantics can\nalso be used a basis for sound implementation of constraint maintenance in\npresence of block declarations and conditionals."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0208032v2", 
    "other_authors": [
        "K. R. Apt", 
        "C. F. M. Vermeulen"
    ], 
    "lead_author": "C. F. M. Vermeulen", 
    "arxiv-id": "cs/0208032v2", 
    "title": "First-order Logic as a Constraint Programming Language", 
    "publish": "2002-08-20T14:53:37Z", 
    "summary": "We provide a denotational semantics for first-order logic that captures the\ntwo-level view of the computation process typical for constraint programming.\nAt one level we have the usual program execution. At the other level an\nautomatic maintenance of the constraint store takes place. We prove that the\nresulting semantics is sound with respect to the truth definition. By\ninstantiating it by specific forms of constraint management policies we obtain\nseveral sound evaluation policies of first-order formulas. This semantics can\nalso be used a basis for sound implementation of constraint maintenance in\npresence of block declarations and conditionals."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0208032v2", 
    "other_authors": [
        "K. R. Apt", 
        "C. F. M. Vermeulen"
    ], 
    "lead_author": "C. F. M. Vermeulen", 
    "arxiv-id": "cs/0208032v2", 
    "title": "First-order Logic as a Constraint Programming Language", 
    "publish": "2002-08-20T14:53:37Z", 
    "summary": "We provide a denotational semantics for first-order logic that captures the\ntwo-level view of the computation process typical for constraint programming.\nAt one level we have the usual program execution. At the other level an\nautomatic maintenance of the constraint store takes place. We prove that the\nresulting semantics is sound with respect to the truth definition. By\ninstantiating it by specific forms of constraint management policies we obtain\nseveral sound evaluation policies of first-order formulas. This semantics can\nalso be used a basis for sound implementation of constraint maintenance in\npresence of block declarations and conditionals."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0208032v2", 
    "other_authors": [
        "K. R. Apt", 
        "C. F. M. Vermeulen"
    ], 
    "lead_author": "C. F. M. Vermeulen", 
    "arxiv-id": "cs/0208032v2", 
    "title": "First-order Logic as a Constraint Programming Language", 
    "publish": "2002-08-20T14:53:37Z", 
    "summary": "We provide a denotational semantics for first-order logic that captures the\ntwo-level view of the computation process typical for constraint programming.\nAt one level we have the usual program execution. At the other level an\nautomatic maintenance of the constraint store takes place. We prove that the\nresulting semantics is sound with respect to the truth definition. By\ninstantiating it by specific forms of constraint management policies we obtain\nseveral sound evaluation policies of first-order formulas. This semantics can\nalso be used a basis for sound implementation of constraint maintenance in\npresence of block declarations and conditionals."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0208032v2", 
    "other_authors": [
        "K. R. Apt", 
        "C. F. M. Vermeulen"
    ], 
    "lead_author": "C. F. M. Vermeulen", 
    "arxiv-id": "cs/0208032v2", 
    "title": "First-order Logic as a Constraint Programming Language", 
    "publish": "2002-08-20T14:53:37Z", 
    "summary": "We provide a denotational semantics for first-order logic that captures the\ntwo-level view of the computation process typical for constraint programming.\nAt one level we have the usual program execution. At the other level an\nautomatic maintenance of the constraint store takes place. We prove that the\nresulting semantics is sound with respect to the truth definition. By\ninstantiating it by specific forms of constraint management policies we obtain\nseveral sound evaluation policies of first-order formulas. This semantics can\nalso be used a basis for sound implementation of constraint maintenance in\npresence of block declarations and conditionals."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0208032v2", 
    "other_authors": [
        "K. R. Apt", 
        "C. F. M. Vermeulen"
    ], 
    "lead_author": "C. F. M. Vermeulen", 
    "arxiv-id": "cs/0208032v2", 
    "title": "First-order Logic as a Constraint Programming Language", 
    "publish": "2002-08-20T14:53:37Z", 
    "summary": "We provide a denotational semantics for first-order logic that captures the\ntwo-level view of the computation process typical for constraint programming.\nAt one level we have the usual program execution. At the other level an\nautomatic maintenance of the constraint store takes place. We prove that the\nresulting semantics is sound with respect to the truth definition. By\ninstantiating it by specific forms of constraint management policies we obtain\nseveral sound evaluation policies of first-order formulas. This semantics can\nalso be used a basis for sound implementation of constraint maintenance in\npresence of block declarations and conditionals."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0208032v2", 
    "other_authors": [
        "K. R. Apt", 
        "C. F. M. Vermeulen"
    ], 
    "lead_author": "C. F. M. Vermeulen", 
    "arxiv-id": "cs/0208032v2", 
    "title": "First-order Logic as a Constraint Programming Language", 
    "publish": "2002-08-20T14:53:37Z", 
    "summary": "We provide a denotational semantics for first-order logic that captures the\ntwo-level view of the computation process typical for constraint programming.\nAt one level we have the usual program execution. At the other level an\nautomatic maintenance of the constraint store takes place. We prove that the\nresulting semantics is sound with respect to the truth definition. By\ninstantiating it by specific forms of constraint management policies we obtain\nseveral sound evaluation policies of first-order formulas. This semantics can\nalso be used a basis for sound implementation of constraint maintenance in\npresence of block declarations and conditionals."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0208032v2", 
    "other_authors": [
        "K. R. Apt", 
        "C. F. M. Vermeulen"
    ], 
    "lead_author": "C. F. M. Vermeulen", 
    "arxiv-id": "cs/0208032v2", 
    "title": "First-order Logic as a Constraint Programming Language", 
    "publish": "2002-08-20T14:53:37Z", 
    "summary": "We provide a denotational semantics for first-order logic that captures the\ntwo-level view of the computation process typical for constraint programming.\nAt one level we have the usual program execution. At the other level an\nautomatic maintenance of the constraint store takes place. We prove that the\nresulting semantics is sound with respect to the truth definition. By\ninstantiating it by specific forms of constraint management policies we obtain\nseveral sound evaluation policies of first-order formulas. This semantics can\nalso be used a basis for sound implementation of constraint maintenance in\npresence of block declarations and conditionals."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0208032v2", 
    "other_authors": [
        "K. R. Apt", 
        "C. F. M. Vermeulen"
    ], 
    "lead_author": "C. F. M. Vermeulen", 
    "arxiv-id": "cs/0208032v2", 
    "title": "First-order Logic as a Constraint Programming Language", 
    "publish": "2002-08-20T14:53:37Z", 
    "summary": "We provide a denotational semantics for first-order logic that captures the\ntwo-level view of the computation process typical for constraint programming.\nAt one level we have the usual program execution. At the other level an\nautomatic maintenance of the constraint store takes place. We prove that the\nresulting semantics is sound with respect to the truth definition. By\ninstantiating it by specific forms of constraint management policies we obtain\nseveral sound evaluation policies of first-order formulas. This semantics can\nalso be used a basis for sound implementation of constraint maintenance in\npresence of block declarations and conditionals."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0210022v3", 
    "other_authors": [
        "Klaus Aehlig", 
        "Jan Johannsen"
    ], 
    "lead_author": "Klaus Aehlig", 
    "arxiv-id": "cs/0210022v3", 
    "title": "An Elementary Fragment of Second-Order Lambda Calculus", 
    "publish": "2002-10-25T10:31:39Z", 
    "summary": "A fragment of second-order lambda calculus (System F) is defined that\ncharacterizes the elementary recursive functions. Type quantification is\nrestricted to be non-interleaved and stratified, i.e., the types are assigned\nlevels, and a quantified variable can only be instantiated by a type of smaller\nlevel, with a slightly liberalized treatment of the level zero."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0210022v3", 
    "other_authors": [
        "Klaus Aehlig", 
        "Jan Johannsen"
    ], 
    "lead_author": "Klaus Aehlig", 
    "arxiv-id": "cs/0210022v3", 
    "title": "An Elementary Fragment of Second-Order Lambda Calculus", 
    "publish": "2002-10-25T10:31:39Z", 
    "summary": "A fragment of second-order lambda calculus (System F) is defined that\ncharacterizes the elementary recursive functions. Type quantification is\nrestricted to be non-interleaved and stratified, i.e., the types are assigned\nlevels, and a quantified variable can only be instantiated by a type of smaller\nlevel, with a slightly liberalized treatment of the level zero."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0210022v3", 
    "other_authors": [
        "Klaus Aehlig", 
        "Jan Johannsen"
    ], 
    "lead_author": "Klaus Aehlig", 
    "arxiv-id": "cs/0210022v3", 
    "title": "An Elementary Fragment of Second-Order Lambda Calculus", 
    "publish": "2002-10-25T10:31:39Z", 
    "summary": "A fragment of second-order lambda calculus (System F) is defined that\ncharacterizes the elementary recursive functions. Type quantification is\nrestricted to be non-interleaved and stratified, i.e., the types are assigned\nlevels, and a quantified variable can only be instantiated by a type of smaller\nlevel, with a slightly liberalized treatment of the level zero."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0210022v3", 
    "other_authors": [
        "Klaus Aehlig", 
        "Jan Johannsen"
    ], 
    "lead_author": "Klaus Aehlig", 
    "arxiv-id": "cs/0210022v3", 
    "title": "An Elementary Fragment of Second-Order Lambda Calculus", 
    "publish": "2002-10-25T10:31:39Z", 
    "summary": "A fragment of second-order lambda calculus (System F) is defined that\ncharacterizes the elementary recursive functions. Type quantification is\nrestricted to be non-interleaved and stratified, i.e., the types are assigned\nlevels, and a quantified variable can only be instantiated by a type of smaller\nlevel, with a slightly liberalized treatment of the level zero."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0210022v3", 
    "other_authors": [
        "Klaus Aehlig", 
        "Jan Johannsen"
    ], 
    "lead_author": "Klaus Aehlig", 
    "arxiv-id": "cs/0210022v3", 
    "title": "An Elementary Fragment of Second-Order Lambda Calculus", 
    "publish": "2002-10-25T10:31:39Z", 
    "summary": "A fragment of second-order lambda calculus (System F) is defined that\ncharacterizes the elementary recursive functions. Type quantification is\nrestricted to be non-interleaved and stratified, i.e., the types are assigned\nlevels, and a quantified variable can only be instantiated by a type of smaller\nlevel, with a slightly liberalized treatment of the level zero."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0210022v3", 
    "other_authors": [
        "Klaus Aehlig", 
        "Jan Johannsen"
    ], 
    "lead_author": "Klaus Aehlig", 
    "arxiv-id": "cs/0210022v3", 
    "title": "An Elementary Fragment of Second-Order Lambda Calculus", 
    "publish": "2002-10-25T10:31:39Z", 
    "summary": "A fragment of second-order lambda calculus (System F) is defined that\ncharacterizes the elementary recursive functions. Type quantification is\nrestricted to be non-interleaved and stratified, i.e., the types are assigned\nlevels, and a quantified variable can only be instantiated by a type of smaller\nlevel, with a slightly liberalized treatment of the level zero."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0210022v3", 
    "other_authors": [
        "Klaus Aehlig", 
        "Jan Johannsen"
    ], 
    "lead_author": "Jan Johannsen", 
    "arxiv-id": "cs/0210022v3", 
    "title": "An Elementary Fragment of Second-Order Lambda Calculus", 
    "publish": "2002-10-25T10:31:39Z", 
    "summary": "A fragment of second-order lambda calculus (System F) is defined that\ncharacterizes the elementary recursive functions. Type quantification is\nrestricted to be non-interleaved and stratified, i.e., the types are assigned\nlevels, and a quantified variable can only be instantiated by a type of smaller\nlevel, with a slightly liberalized treatment of the level zero."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0210022v3", 
    "other_authors": [
        "Klaus Aehlig", 
        "Jan Johannsen"
    ], 
    "lead_author": "Jan Johannsen", 
    "arxiv-id": "cs/0210022v3", 
    "title": "An Elementary Fragment of Second-Order Lambda Calculus", 
    "publish": "2002-10-25T10:31:39Z", 
    "summary": "A fragment of second-order lambda calculus (System F) is defined that\ncharacterizes the elementary recursive functions. Type quantification is\nrestricted to be non-interleaved and stratified, i.e., the types are assigned\nlevels, and a quantified variable can only be instantiated by a type of smaller\nlevel, with a slightly liberalized treatment of the level zero."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0210022v3", 
    "other_authors": [
        "Klaus Aehlig", 
        "Jan Johannsen"
    ], 
    "lead_author": "Jan Johannsen", 
    "arxiv-id": "cs/0210022v3", 
    "title": "An Elementary Fragment of Second-Order Lambda Calculus", 
    "publish": "2002-10-25T10:31:39Z", 
    "summary": "A fragment of second-order lambda calculus (System F) is defined that\ncharacterizes the elementary recursive functions. Type quantification is\nrestricted to be non-interleaved and stratified, i.e., the types are assigned\nlevels, and a quantified variable can only be instantiated by a type of smaller\nlevel, with a slightly liberalized treatment of the level zero."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0210022v3", 
    "other_authors": [
        "Klaus Aehlig", 
        "Jan Johannsen"
    ], 
    "lead_author": "Jan Johannsen", 
    "arxiv-id": "cs/0210022v3", 
    "title": "An Elementary Fragment of Second-Order Lambda Calculus", 
    "publish": "2002-10-25T10:31:39Z", 
    "summary": "A fragment of second-order lambda calculus (System F) is defined that\ncharacterizes the elementary recursive functions. Type quantification is\nrestricted to be non-interleaved and stratified, i.e., the types are assigned\nlevels, and a quantified variable can only be instantiated by a type of smaller\nlevel, with a slightly liberalized treatment of the level zero."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0210022v3", 
    "other_authors": [
        "Klaus Aehlig", 
        "Jan Johannsen"
    ], 
    "lead_author": "Jan Johannsen", 
    "arxiv-id": "cs/0210022v3", 
    "title": "An Elementary Fragment of Second-Order Lambda Calculus", 
    "publish": "2002-10-25T10:31:39Z", 
    "summary": "A fragment of second-order lambda calculus (System F) is defined that\ncharacterizes the elementary recursive functions. Type quantification is\nrestricted to be non-interleaved and stratified, i.e., the types are assigned\nlevels, and a quantified variable can only be instantiated by a type of smaller\nlevel, with a slightly liberalized treatment of the level zero."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0210022v3", 
    "other_authors": [
        "Klaus Aehlig", 
        "Jan Johannsen"
    ], 
    "lead_author": "Jan Johannsen", 
    "arxiv-id": "cs/0210022v3", 
    "title": "An Elementary Fragment of Second-Order Lambda Calculus", 
    "publish": "2002-10-25T10:31:39Z", 
    "summary": "A fragment of second-order lambda calculus (System F) is defined that\ncharacterizes the elementary recursive functions. Type quantification is\nrestricted to be non-interleaved and stratified, i.e., the types are assigned\nlevels, and a quantified variable can only be instantiated by a type of smaller\nlevel, with a slightly liberalized treatment of the level zero."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0210022v3", 
    "other_authors": [
        "Klaus Aehlig", 
        "Jan Johannsen"
    ], 
    "lead_author": "Jan Johannsen", 
    "arxiv-id": "cs/0210022v3", 
    "title": "An Elementary Fragment of Second-Order Lambda Calculus", 
    "publish": "2002-10-25T10:31:39Z", 
    "summary": "A fragment of second-order lambda calculus (System F) is defined that\ncharacterizes the elementary recursive functions. Type quantification is\nrestricted to be non-interleaved and stratified, i.e., the types are assigned\nlevels, and a quantified variable can only be instantiated by a type of smaller\nlevel, with a slightly liberalized treatment of the level zero."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0210022v3", 
    "other_authors": [
        "Klaus Aehlig", 
        "Jan Johannsen"
    ], 
    "lead_author": "Jan Johannsen", 
    "arxiv-id": "cs/0210022v3", 
    "title": "An Elementary Fragment of Second-Order Lambda Calculus", 
    "publish": "2002-10-25T10:31:39Z", 
    "summary": "A fragment of second-order lambda calculus (System F) is defined that\ncharacterizes the elementary recursive functions. Type quantification is\nrestricted to be non-interleaved and stratified, i.e., the types are assigned\nlevels, and a quantified variable can only be instantiated by a type of smaller\nlevel, with a slightly liberalized treatment of the level zero."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0210022v3", 
    "other_authors": [
        "Klaus Aehlig", 
        "Jan Johannsen"
    ], 
    "lead_author": "Jan Johannsen", 
    "arxiv-id": "cs/0210022v3", 
    "title": "An Elementary Fragment of Second-Order Lambda Calculus", 
    "publish": "2002-10-25T10:31:39Z", 
    "summary": "A fragment of second-order lambda calculus (System F) is defined that\ncharacterizes the elementary recursive functions. Type quantification is\nrestricted to be non-interleaved and stratified, i.e., the types are assigned\nlevels, and a quantified variable can only be instantiated by a type of smaller\nlevel, with a slightly liberalized treatment of the level zero."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0210022v3", 
    "other_authors": [
        "Klaus Aehlig", 
        "Jan Johannsen"
    ], 
    "lead_author": "Jan Johannsen", 
    "arxiv-id": "cs/0210022v3", 
    "title": "An Elementary Fragment of Second-Order Lambda Calculus", 
    "publish": "2002-10-25T10:31:39Z", 
    "summary": "A fragment of second-order lambda calculus (System F) is defined that\ncharacterizes the elementary recursive functions. Type quantification is\nrestricted to be non-interleaved and stratified, i.e., the types are assigned\nlevels, and a quantified variable can only be instantiated by a type of smaller\nlevel, with a slightly liberalized treatment of the level zero."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0210022v3", 
    "other_authors": [
        "Klaus Aehlig", 
        "Jan Johannsen"
    ], 
    "lead_author": "Jan Johannsen", 
    "arxiv-id": "cs/0210022v3", 
    "title": "An Elementary Fragment of Second-Order Lambda Calculus", 
    "publish": "2002-10-25T10:31:39Z", 
    "summary": "A fragment of second-order lambda calculus (System F) is defined that\ncharacterizes the elementary recursive functions. Type quantification is\nrestricted to be non-interleaved and stratified, i.e., the types are assigned\nlevels, and a quantified variable can only be instantiated by a type of smaller\nlevel, with a slightly liberalized treatment of the level zero."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0210022v3", 
    "other_authors": [
        "Klaus Aehlig", 
        "Jan Johannsen"
    ], 
    "lead_author": "Jan Johannsen", 
    "arxiv-id": "cs/0210022v3", 
    "title": "An Elementary Fragment of Second-Order Lambda Calculus", 
    "publish": "2002-10-25T10:31:39Z", 
    "summary": "A fragment of second-order lambda calculus (System F) is defined that\ncharacterizes the elementary recursive functions. Type quantification is\nrestricted to be non-interleaved and stratified, i.e., the types are assigned\nlevels, and a quantified variable can only be instantiated by a type of smaller\nlevel, with a slightly liberalized treatment of the level zero."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0210022v3", 
    "other_authors": [
        "Klaus Aehlig", 
        "Jan Johannsen"
    ], 
    "lead_author": "Jan Johannsen", 
    "arxiv-id": "cs/0210022v3", 
    "title": "An Elementary Fragment of Second-Order Lambda Calculus", 
    "publish": "2002-10-25T10:31:39Z", 
    "summary": "A fragment of second-order lambda calculus (System F) is defined that\ncharacterizes the elementary recursive functions. Type quantification is\nrestricted to be non-interleaved and stratified, i.e., the types are assigned\nlevels, and a quantified variable can only be instantiated by a type of smaller\nlevel, with a slightly liberalized treatment of the level zero."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0210022v3", 
    "other_authors": [
        "Klaus Aehlig", 
        "Jan Johannsen"
    ], 
    "lead_author": "Jan Johannsen", 
    "arxiv-id": "cs/0210022v3", 
    "title": "An Elementary Fragment of Second-Order Lambda Calculus", 
    "publish": "2002-10-25T10:31:39Z", 
    "summary": "A fragment of second-order lambda calculus (System F) is defined that\ncharacterizes the elementary recursive functions. Type quantification is\nrestricted to be non-interleaved and stratified, i.e., the types are assigned\nlevels, and a quantified variable can only be instantiated by a type of smaller\nlevel, with a slightly liberalized treatment of the level zero."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0210022v3", 
    "other_authors": [
        "Klaus Aehlig", 
        "Jan Johannsen"
    ], 
    "lead_author": "Jan Johannsen", 
    "arxiv-id": "cs/0210022v3", 
    "title": "An Elementary Fragment of Second-Order Lambda Calculus", 
    "publish": "2002-10-25T10:31:39Z", 
    "summary": "A fragment of second-order lambda calculus (System F) is defined that\ncharacterizes the elementary recursive functions. Type quantification is\nrestricted to be non-interleaved and stratified, i.e., the types are assigned\nlevels, and a quantified variable can only be instantiated by a type of smaller\nlevel, with a slightly liberalized treatment of the level zero."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0210022v3", 
    "other_authors": [
        "Klaus Aehlig", 
        "Jan Johannsen"
    ], 
    "lead_author": "Jan Johannsen", 
    "arxiv-id": "cs/0210022v3", 
    "title": "An Elementary Fragment of Second-Order Lambda Calculus", 
    "publish": "2002-10-25T10:31:39Z", 
    "summary": "A fragment of second-order lambda calculus (System F) is defined that\ncharacterizes the elementary recursive functions. Type quantification is\nrestricted to be non-interleaved and stratified, i.e., the types are assigned\nlevels, and a quantified variable can only be instantiated by a type of smaller\nlevel, with a slightly liberalized treatment of the level zero."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0210022v3", 
    "other_authors": [
        "Klaus Aehlig", 
        "Jan Johannsen"
    ], 
    "lead_author": "Jan Johannsen", 
    "arxiv-id": "cs/0210022v3", 
    "title": "An Elementary Fragment of Second-Order Lambda Calculus", 
    "publish": "2002-10-25T10:31:39Z", 
    "summary": "A fragment of second-order lambda calculus (System F) is defined that\ncharacterizes the elementary recursive functions. Type quantification is\nrestricted to be non-interleaved and stratified, i.e., the types are assigned\nlevels, and a quantified variable can only be instantiated by a type of smaller\nlevel, with a slightly liberalized treatment of the level zero."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0211011v1", 
    "other_authors": [
        "M. Dezani-Ciancaglini", 
        "S. Lusin"
    ], 
    "lead_author": "S. Lusin", 
    "arxiv-id": "cs/0211011v1", 
    "title": "Intersection Types and Lambda Theories", 
    "publish": "2002-11-12T21:33:33Z", 
    "summary": "We illustrate the use of intersection types as a semantic tool for showing\nproperties of the lattice of lambda theories. Relying on the notion of easy\nintersection type theory we successfully build a filter model in which the\ninterpretation of an arbitrary simple easy term is any filter which can be\ndescribed in an uniform way by a predicate. This allows us to prove the\nconsistency of a well-know lambda theory: this consistency has interesting\nconsequences on the algebraic structure of the lattice of lambda theories."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0211021v1", 
    "other_authors": [
        "G. Metcalfe", 
        "N. Olivetti", 
        "D. Gabbay"
    ], 
    "lead_author": "G. Metcalfe", 
    "arxiv-id": "cs/0211021v1", 
    "title": "Sequent and Hypersequent Calculi for Abelian and Lukasiewicz Logics", 
    "publish": "2002-11-18T12:08:17Z", 
    "summary": "We present two embeddings of infinite-valued Lukasiewicz logic L into Meyer\nand Slaney's abelian logic A, the logic of lattice-ordered abelian groups. We\ngive new analytic proof systems for A and use the embeddings to derive\ncorresponding systems for L. These include: hypersequent calculi for A and L\nand terminating versions of these calculi; labelled single sequent calculi for\nA and L of complexity co-NP; unlabelled single sequent calculi for A and L."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0211021v1", 
    "other_authors": [
        "G. Metcalfe", 
        "N. Olivetti", 
        "D. Gabbay"
    ], 
    "lead_author": "G. Metcalfe", 
    "arxiv-id": "cs/0211021v1", 
    "title": "Sequent and Hypersequent Calculi for Abelian and Lukasiewicz Logics", 
    "publish": "2002-11-18T12:08:17Z", 
    "summary": "We present two embeddings of infinite-valued Lukasiewicz logic L into Meyer\nand Slaney's abelian logic A, the logic of lattice-ordered abelian groups. We\ngive new analytic proof systems for A and use the embeddings to derive\ncorresponding systems for L. These include: hypersequent calculi for A and L\nand terminating versions of these calculi; labelled single sequent calculi for\nA and L of complexity co-NP; unlabelled single sequent calculi for A and L."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0211021v1", 
    "other_authors": [
        "G. Metcalfe", 
        "N. Olivetti", 
        "D. Gabbay"
    ], 
    "lead_author": "G. Metcalfe", 
    "arxiv-id": "cs/0211021v1", 
    "title": "Sequent and Hypersequent Calculi for Abelian and Lukasiewicz Logics", 
    "publish": "2002-11-18T12:08:17Z", 
    "summary": "We present two embeddings of infinite-valued Lukasiewicz logic L into Meyer\nand Slaney's abelian logic A, the logic of lattice-ordered abelian groups. We\ngive new analytic proof systems for A and use the embeddings to derive\ncorresponding systems for L. These include: hypersequent calculi for A and L\nand terminating versions of these calculi; labelled single sequent calculi for\nA and L of complexity co-NP; unlabelled single sequent calculi for A and L."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0211021v1", 
    "other_authors": [
        "G. Metcalfe", 
        "N. Olivetti", 
        "D. Gabbay"
    ], 
    "lead_author": "G. Metcalfe", 
    "arxiv-id": "cs/0211021v1", 
    "title": "Sequent and Hypersequent Calculi for Abelian and Lukasiewicz Logics", 
    "publish": "2002-11-18T12:08:17Z", 
    "summary": "We present two embeddings of infinite-valued Lukasiewicz logic L into Meyer\nand Slaney's abelian logic A, the logic of lattice-ordered abelian groups. We\ngive new analytic proof systems for A and use the embeddings to derive\ncorresponding systems for L. These include: hypersequent calculi for A and L\nand terminating versions of these calculi; labelled single sequent calculi for\nA and L of complexity co-NP; unlabelled single sequent calculi for A and L."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0211021v1", 
    "other_authors": [
        "G. Metcalfe", 
        "N. Olivetti", 
        "D. Gabbay"
    ], 
    "lead_author": "G. Metcalfe", 
    "arxiv-id": "cs/0211021v1", 
    "title": "Sequent and Hypersequent Calculi for Abelian and Lukasiewicz Logics", 
    "publish": "2002-11-18T12:08:17Z", 
    "summary": "We present two embeddings of infinite-valued Lukasiewicz logic L into Meyer\nand Slaney's abelian logic A, the logic of lattice-ordered abelian groups. We\ngive new analytic proof systems for A and use the embeddings to derive\ncorresponding systems for L. These include: hypersequent calculi for A and L\nand terminating versions of these calculi; labelled single sequent calculi for\nA and L of complexity co-NP; unlabelled single sequent calculi for A and L."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0211021v1", 
    "other_authors": [
        "G. Metcalfe", 
        "N. Olivetti", 
        "D. Gabbay"
    ], 
    "lead_author": "G. Metcalfe", 
    "arxiv-id": "cs/0211021v1", 
    "title": "Sequent and Hypersequent Calculi for Abelian and Lukasiewicz Logics", 
    "publish": "2002-11-18T12:08:17Z", 
    "summary": "We present two embeddings of infinite-valued Lukasiewicz logic L into Meyer\nand Slaney's abelian logic A, the logic of lattice-ordered abelian groups. We\ngive new analytic proof systems for A and use the embeddings to derive\ncorresponding systems for L. These include: hypersequent calculi for A and L\nand terminating versions of these calculi; labelled single sequent calculi for\nA and L of complexity co-NP; unlabelled single sequent calculi for A and L."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0211021v1", 
    "other_authors": [
        "G. Metcalfe", 
        "N. Olivetti", 
        "D. Gabbay"
    ], 
    "lead_author": "G. Metcalfe", 
    "arxiv-id": "cs/0211021v1", 
    "title": "Sequent and Hypersequent Calculi for Abelian and Lukasiewicz Logics", 
    "publish": "2002-11-18T12:08:17Z", 
    "summary": "We present two embeddings of infinite-valued Lukasiewicz logic L into Meyer\nand Slaney's abelian logic A, the logic of lattice-ordered abelian groups. We\ngive new analytic proof systems for A and use the embeddings to derive\ncorresponding systems for L. These include: hypersequent calculi for A and L\nand terminating versions of these calculi; labelled single sequent calculi for\nA and L of complexity co-NP; unlabelled single sequent calculi for A and L."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0211021v1", 
    "other_authors": [
        "G. Metcalfe", 
        "N. Olivetti", 
        "D. Gabbay"
    ], 
    "lead_author": "G. Metcalfe", 
    "arxiv-id": "cs/0211021v1", 
    "title": "Sequent and Hypersequent Calculi for Abelian and Lukasiewicz Logics", 
    "publish": "2002-11-18T12:08:17Z", 
    "summary": "We present two embeddings of infinite-valued Lukasiewicz logic L into Meyer\nand Slaney's abelian logic A, the logic of lattice-ordered abelian groups. We\ngive new analytic proof systems for A and use the embeddings to derive\ncorresponding systems for L. These include: hypersequent calculi for A and L\nand terminating versions of these calculi; labelled single sequent calculi for\nA and L of complexity co-NP; unlabelled single sequent calculi for A and L."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0211021v1", 
    "other_authors": [
        "G. Metcalfe", 
        "N. Olivetti", 
        "D. Gabbay"
    ], 
    "lead_author": "G. Metcalfe", 
    "arxiv-id": "cs/0211021v1", 
    "title": "Sequent and Hypersequent Calculi for Abelian and Lukasiewicz Logics", 
    "publish": "2002-11-18T12:08:17Z", 
    "summary": "We present two embeddings of infinite-valued Lukasiewicz logic L into Meyer\nand Slaney's abelian logic A, the logic of lattice-ordered abelian groups. We\ngive new analytic proof systems for A and use the embeddings to derive\ncorresponding systems for L. These include: hypersequent calculi for A and L\nand terminating versions of these calculi; labelled single sequent calculi for\nA and L of complexity co-NP; unlabelled single sequent calculi for A and L."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0211021v1", 
    "other_authors": [
        "G. Metcalfe", 
        "N. Olivetti", 
        "D. Gabbay"
    ], 
    "lead_author": "G. Metcalfe", 
    "arxiv-id": "cs/0211021v1", 
    "title": "Sequent and Hypersequent Calculi for Abelian and Lukasiewicz Logics", 
    "publish": "2002-11-18T12:08:17Z", 
    "summary": "We present two embeddings of infinite-valued Lukasiewicz logic L into Meyer\nand Slaney's abelian logic A, the logic of lattice-ordered abelian groups. We\ngive new analytic proof systems for A and use the embeddings to derive\ncorresponding systems for L. These include: hypersequent calculi for A and L\nand terminating versions of these calculi; labelled single sequent calculi for\nA and L of complexity co-NP; unlabelled single sequent calculi for A and L."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0211021v1", 
    "other_authors": [
        "G. Metcalfe", 
        "N. Olivetti", 
        "D. Gabbay"
    ], 
    "lead_author": "G. Metcalfe", 
    "arxiv-id": "cs/0211021v1", 
    "title": "Sequent and Hypersequent Calculi for Abelian and Lukasiewicz Logics", 
    "publish": "2002-11-18T12:08:17Z", 
    "summary": "We present two embeddings of infinite-valued Lukasiewicz logic L into Meyer\nand Slaney's abelian logic A, the logic of lattice-ordered abelian groups. We\ngive new analytic proof systems for A and use the embeddings to derive\ncorresponding systems for L. These include: hypersequent calculi for A and L\nand terminating versions of these calculi; labelled single sequent calculi for\nA and L of complexity co-NP; unlabelled single sequent calculi for A and L."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0211021v1", 
    "other_authors": [
        "G. Metcalfe", 
        "N. Olivetti", 
        "D. Gabbay"
    ], 
    "lead_author": "G. Metcalfe", 
    "arxiv-id": "cs/0211021v1", 
    "title": "Sequent and Hypersequent Calculi for Abelian and Lukasiewicz Logics", 
    "publish": "2002-11-18T12:08:17Z", 
    "summary": "We present two embeddings of infinite-valued Lukasiewicz logic L into Meyer\nand Slaney's abelian logic A, the logic of lattice-ordered abelian groups. We\ngive new analytic proof systems for A and use the embeddings to derive\ncorresponding systems for L. These include: hypersequent calculi for A and L\nand terminating versions of these calculi; labelled single sequent calculi for\nA and L of complexity co-NP; unlabelled single sequent calculi for A and L."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0211021v1", 
    "other_authors": [
        "G. Metcalfe", 
        "N. Olivetti", 
        "D. Gabbay"
    ], 
    "lead_author": "N. Olivetti", 
    "arxiv-id": "cs/0211021v1", 
    "title": "Sequent and Hypersequent Calculi for Abelian and Lukasiewicz Logics", 
    "publish": "2002-11-18T12:08:17Z", 
    "summary": "We present two embeddings of infinite-valued Lukasiewicz logic L into Meyer\nand Slaney's abelian logic A, the logic of lattice-ordered abelian groups. We\ngive new analytic proof systems for A and use the embeddings to derive\ncorresponding systems for L. These include: hypersequent calculi for A and L\nand terminating versions of these calculi; labelled single sequent calculi for\nA and L of complexity co-NP; unlabelled single sequent calculi for A and L."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0211021v1", 
    "other_authors": [
        "G. Metcalfe", 
        "N. Olivetti", 
        "D. Gabbay"
    ], 
    "lead_author": "N. Olivetti", 
    "arxiv-id": "cs/0211021v1", 
    "title": "Sequent and Hypersequent Calculi for Abelian and Lukasiewicz Logics", 
    "publish": "2002-11-18T12:08:17Z", 
    "summary": "We present two embeddings of infinite-valued Lukasiewicz logic L into Meyer\nand Slaney's abelian logic A, the logic of lattice-ordered abelian groups. We\ngive new analytic proof systems for A and use the embeddings to derive\ncorresponding systems for L. These include: hypersequent calculi for A and L\nand terminating versions of these calculi; labelled single sequent calculi for\nA and L of complexity co-NP; unlabelled single sequent calculi for A and L."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0211021v1", 
    "other_authors": [
        "G. Metcalfe", 
        "N. Olivetti", 
        "D. Gabbay"
    ], 
    "lead_author": "N. Olivetti", 
    "arxiv-id": "cs/0211021v1", 
    "title": "Sequent and Hypersequent Calculi for Abelian and Lukasiewicz Logics", 
    "publish": "2002-11-18T12:08:17Z", 
    "summary": "We present two embeddings of infinite-valued Lukasiewicz logic L into Meyer\nand Slaney's abelian logic A, the logic of lattice-ordered abelian groups. We\ngive new analytic proof systems for A and use the embeddings to derive\ncorresponding systems for L. These include: hypersequent calculi for A and L\nand terminating versions of these calculi; labelled single sequent calculi for\nA and L of complexity co-NP; unlabelled single sequent calculi for A and L."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0211021v1", 
    "other_authors": [
        "G. Metcalfe", 
        "N. Olivetti", 
        "D. Gabbay"
    ], 
    "lead_author": "N. Olivetti", 
    "arxiv-id": "cs/0211021v1", 
    "title": "Sequent and Hypersequent Calculi for Abelian and Lukasiewicz Logics", 
    "publish": "2002-11-18T12:08:17Z", 
    "summary": "We present two embeddings of infinite-valued Lukasiewicz logic L into Meyer\nand Slaney's abelian logic A, the logic of lattice-ordered abelian groups. We\ngive new analytic proof systems for A and use the embeddings to derive\ncorresponding systems for L. These include: hypersequent calculi for A and L\nand terminating versions of these calculi; labelled single sequent calculi for\nA and L of complexity co-NP; unlabelled single sequent calculi for A and L."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0211021v1", 
    "other_authors": [
        "G. Metcalfe", 
        "N. Olivetti", 
        "D. Gabbay"
    ], 
    "lead_author": "N. Olivetti", 
    "arxiv-id": "cs/0211021v1", 
    "title": "Sequent and Hypersequent Calculi for Abelian and Lukasiewicz Logics", 
    "publish": "2002-11-18T12:08:17Z", 
    "summary": "We present two embeddings of infinite-valued Lukasiewicz logic L into Meyer\nand Slaney's abelian logic A, the logic of lattice-ordered abelian groups. We\ngive new analytic proof systems for A and use the embeddings to derive\ncorresponding systems for L. These include: hypersequent calculi for A and L\nand terminating versions of these calculi; labelled single sequent calculi for\nA and L of complexity co-NP; unlabelled single sequent calculi for A and L."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0211021v1", 
    "other_authors": [
        "G. Metcalfe", 
        "N. Olivetti", 
        "D. Gabbay"
    ], 
    "lead_author": "N. Olivetti", 
    "arxiv-id": "cs/0211021v1", 
    "title": "Sequent and Hypersequent Calculi for Abelian and Lukasiewicz Logics", 
    "publish": "2002-11-18T12:08:17Z", 
    "summary": "We present two embeddings of infinite-valued Lukasiewicz logic L into Meyer\nand Slaney's abelian logic A, the logic of lattice-ordered abelian groups. We\ngive new analytic proof systems for A and use the embeddings to derive\ncorresponding systems for L. These include: hypersequent calculi for A and L\nand terminating versions of these calculi; labelled single sequent calculi for\nA and L of complexity co-NP; unlabelled single sequent calculi for A and L."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0211021v1", 
    "other_authors": [
        "G. Metcalfe", 
        "N. Olivetti", 
        "D. Gabbay"
    ], 
    "lead_author": "N. Olivetti", 
    "arxiv-id": "cs/0211021v1", 
    "title": "Sequent and Hypersequent Calculi for Abelian and Lukasiewicz Logics", 
    "publish": "2002-11-18T12:08:17Z", 
    "summary": "We present two embeddings of infinite-valued Lukasiewicz logic L into Meyer\nand Slaney's abelian logic A, the logic of lattice-ordered abelian groups. We\ngive new analytic proof systems for A and use the embeddings to derive\ncorresponding systems for L. These include: hypersequent calculi for A and L\nand terminating versions of these calculi; labelled single sequent calculi for\nA and L of complexity co-NP; unlabelled single sequent calculi for A and L."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0211021v1", 
    "other_authors": [
        "G. Metcalfe", 
        "N. Olivetti", 
        "D. Gabbay"
    ], 
    "lead_author": "D. Gabbay", 
    "arxiv-id": "cs/0211021v1", 
    "title": "Sequent and Hypersequent Calculi for Abelian and Lukasiewicz Logics", 
    "publish": "2002-11-18T12:08:17Z", 
    "summary": "We present two embeddings of infinite-valued Lukasiewicz logic L into Meyer\nand Slaney's abelian logic A, the logic of lattice-ordered abelian groups. We\ngive new analytic proof systems for A and use the embeddings to derive\ncorresponding systems for L. These include: hypersequent calculi for A and L\nand terminating versions of these calculi; labelled single sequent calculi for\nA and L of complexity co-NP; unlabelled single sequent calculi for A and L."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0211021v1", 
    "other_authors": [
        "G. Metcalfe", 
        "N. Olivetti", 
        "D. Gabbay"
    ], 
    "lead_author": "D. Gabbay", 
    "arxiv-id": "cs/0211021v1", 
    "title": "Sequent and Hypersequent Calculi for Abelian and Lukasiewicz Logics", 
    "publish": "2002-11-18T12:08:17Z", 
    "summary": "We present two embeddings of infinite-valued Lukasiewicz logic L into Meyer\nand Slaney's abelian logic A, the logic of lattice-ordered abelian groups. We\ngive new analytic proof systems for A and use the embeddings to derive\ncorresponding systems for L. These include: hypersequent calculi for A and L\nand terminating versions of these calculi; labelled single sequent calculi for\nA and L of complexity co-NP; unlabelled single sequent calculi for A and L."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0211021v1", 
    "other_authors": [
        "G. Metcalfe", 
        "N. Olivetti", 
        "D. Gabbay"
    ], 
    "lead_author": "D. Gabbay", 
    "arxiv-id": "cs/0211021v1", 
    "title": "Sequent and Hypersequent Calculi for Abelian and Lukasiewicz Logics", 
    "publish": "2002-11-18T12:08:17Z", 
    "summary": "We present two embeddings of infinite-valued Lukasiewicz logic L into Meyer\nand Slaney's abelian logic A, the logic of lattice-ordered abelian groups. We\ngive new analytic proof systems for A and use the embeddings to derive\ncorresponding systems for L. These include: hypersequent calculi for A and L\nand terminating versions of these calculi; labelled single sequent calculi for\nA and L of complexity co-NP; unlabelled single sequent calculi for A and L."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0211021v1", 
    "other_authors": [
        "G. Metcalfe", 
        "N. Olivetti", 
        "D. Gabbay"
    ], 
    "lead_author": "D. Gabbay", 
    "arxiv-id": "cs/0211021v1", 
    "title": "Sequent and Hypersequent Calculi for Abelian and Lukasiewicz Logics", 
    "publish": "2002-11-18T12:08:17Z", 
    "summary": "We present two embeddings of infinite-valued Lukasiewicz logic L into Meyer\nand Slaney's abelian logic A, the logic of lattice-ordered abelian groups. We\ngive new analytic proof systems for A and use the embeddings to derive\ncorresponding systems for L. These include: hypersequent calculi for A and L\nand terminating versions of these calculi; labelled single sequent calculi for\nA and L of complexity co-NP; unlabelled single sequent calculi for A and L."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0211021v1", 
    "other_authors": [
        "G. Metcalfe", 
        "N. Olivetti", 
        "D. Gabbay"
    ], 
    "lead_author": "D. Gabbay", 
    "arxiv-id": "cs/0211021v1", 
    "title": "Sequent and Hypersequent Calculi for Abelian and Lukasiewicz Logics", 
    "publish": "2002-11-18T12:08:17Z", 
    "summary": "We present two embeddings of infinite-valued Lukasiewicz logic L into Meyer\nand Slaney's abelian logic A, the logic of lattice-ordered abelian groups. We\ngive new analytic proof systems for A and use the embeddings to derive\ncorresponding systems for L. These include: hypersequent calculi for A and L\nand terminating versions of these calculi; labelled single sequent calculi for\nA and L of complexity co-NP; unlabelled single sequent calculi for A and L."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0211021v1", 
    "other_authors": [
        "G. Metcalfe", 
        "N. Olivetti", 
        "D. Gabbay"
    ], 
    "lead_author": "D. Gabbay", 
    "arxiv-id": "cs/0211021v1", 
    "title": "Sequent and Hypersequent Calculi for Abelian and Lukasiewicz Logics", 
    "publish": "2002-11-18T12:08:17Z", 
    "summary": "We present two embeddings of infinite-valued Lukasiewicz logic L into Meyer\nand Slaney's abelian logic A, the logic of lattice-ordered abelian groups. We\ngive new analytic proof systems for A and use the embeddings to derive\ncorresponding systems for L. These include: hypersequent calculi for A and L\nand terminating versions of these calculi; labelled single sequent calculi for\nA and L of complexity co-NP; unlabelled single sequent calculi for A and L."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0211021v1", 
    "other_authors": [
        "G. Metcalfe", 
        "N. Olivetti", 
        "D. Gabbay"
    ], 
    "lead_author": "D. Gabbay", 
    "arxiv-id": "cs/0211021v1", 
    "title": "Sequent and Hypersequent Calculi for Abelian and Lukasiewicz Logics", 
    "publish": "2002-11-18T12:08:17Z", 
    "summary": "We present two embeddings of infinite-valued Lukasiewicz logic L into Meyer\nand Slaney's abelian logic A, the logic of lattice-ordered abelian groups. We\ngive new analytic proof systems for A and use the embeddings to derive\ncorresponding systems for L. These include: hypersequent calculi for A and L\nand terminating versions of these calculi; labelled single sequent calculi for\nA and L of complexity co-NP; unlabelled single sequent calculi for A and L."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0211021v1", 
    "other_authors": [
        "G. Metcalfe", 
        "N. Olivetti", 
        "D. Gabbay"
    ], 
    "lead_author": "D. Gabbay", 
    "arxiv-id": "cs/0211021v1", 
    "title": "Sequent and Hypersequent Calculi for Abelian and Lukasiewicz Logics", 
    "publish": "2002-11-18T12:08:17Z", 
    "summary": "We present two embeddings of infinite-valued Lukasiewicz logic L into Meyer\nand Slaney's abelian logic A, the logic of lattice-ordered abelian groups. We\ngive new analytic proof systems for A and use the embeddings to derive\ncorresponding systems for L. These include: hypersequent calculi for A and L\nand terminating versions of these calculi; labelled single sequent calculi for\nA and L of complexity co-NP; unlabelled single sequent calculi for A and L."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0211021v1", 
    "other_authors": [
        "G. Metcalfe", 
        "N. Olivetti", 
        "D. Gabbay"
    ], 
    "lead_author": "D. Gabbay", 
    "arxiv-id": "cs/0211021v1", 
    "title": "Sequent and Hypersequent Calculi for Abelian and Lukasiewicz Logics", 
    "publish": "2002-11-18T12:08:17Z", 
    "summary": "We present two embeddings of infinite-valued Lukasiewicz logic L into Meyer\nand Slaney's abelian logic A, the logic of lattice-ordered abelian groups. We\ngive new analytic proof systems for A and use the embeddings to derive\ncorresponding systems for L. These include: hypersequent calculi for A and L\nand terminating versions of these calculi; labelled single sequent calculi for\nA and L of complexity co-NP; unlabelled single sequent calculi for A and L."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0211021v1", 
    "other_authors": [
        "G. Metcalfe", 
        "N. Olivetti", 
        "D. Gabbay"
    ], 
    "lead_author": "D. Gabbay", 
    "arxiv-id": "cs/0211021v1", 
    "title": "Sequent and Hypersequent Calculi for Abelian and Lukasiewicz Logics", 
    "publish": "2002-11-18T12:08:17Z", 
    "summary": "We present two embeddings of infinite-valued Lukasiewicz logic L into Meyer\nand Slaney's abelian logic A, the logic of lattice-ordered abelian groups. We\ngive new analytic proof systems for A and use the embeddings to derive\ncorresponding systems for L. These include: hypersequent calculi for A and L\nand terminating versions of these calculi; labelled single sequent calculi for\nA and L of complexity co-NP; unlabelled single sequent calculi for A and L."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0211021v1", 
    "other_authors": [
        "G. Metcalfe", 
        "N. Olivetti", 
        "D. Gabbay"
    ], 
    "lead_author": "D. Gabbay", 
    "arxiv-id": "cs/0211021v1", 
    "title": "Sequent and Hypersequent Calculi for Abelian and Lukasiewicz Logics", 
    "publish": "2002-11-18T12:08:17Z", 
    "summary": "We present two embeddings of infinite-valued Lukasiewicz logic L into Meyer\nand Slaney's abelian logic A, the logic of lattice-ordered abelian groups. We\ngive new analytic proof systems for A and use the embeddings to derive\ncorresponding systems for L. These include: hypersequent calculi for A and L\nand terminating versions of these calculi; labelled single sequent calculi for\nA and L of complexity co-NP; unlabelled single sequent calculi for A and L."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0211021v1", 
    "other_authors": [
        "G. Metcalfe", 
        "N. Olivetti", 
        "D. Gabbay"
    ], 
    "lead_author": "D. Gabbay", 
    "arxiv-id": "cs/0211021v1", 
    "title": "Sequent and Hypersequent Calculi for Abelian and Lukasiewicz Logics", 
    "publish": "2002-11-18T12:08:17Z", 
    "summary": "We present two embeddings of infinite-valued Lukasiewicz logic L into Meyer\nand Slaney's abelian logic A, the logic of lattice-ordered abelian groups. We\ngive new analytic proof systems for A and use the embeddings to derive\ncorresponding systems for L. These include: hypersequent calculi for A and L\nand terminating versions of these calculi; labelled single sequent calculi for\nA and L of complexity co-NP; unlabelled single sequent calculi for A and L."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0211021v1", 
    "other_authors": [
        "G. Metcalfe", 
        "N. Olivetti", 
        "D. Gabbay"
    ], 
    "lead_author": "D. Gabbay", 
    "arxiv-id": "cs/0211021v1", 
    "title": "Sequent and Hypersequent Calculi for Abelian and Lukasiewicz Logics", 
    "publish": "2002-11-18T12:08:17Z", 
    "summary": "We present two embeddings of infinite-valued Lukasiewicz logic L into Meyer\nand Slaney's abelian logic A, the logic of lattice-ordered abelian groups. We\ngive new analytic proof systems for A and use the embeddings to derive\ncorresponding systems for L. These include: hypersequent calculi for A and L\nand terminating versions of these calculi; labelled single sequent calculi for\nA and L of complexity co-NP; unlabelled single sequent calculi for A and L."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0211021v1", 
    "other_authors": [
        "G. Metcalfe", 
        "N. Olivetti", 
        "D. Gabbay"
    ], 
    "lead_author": "D. Gabbay", 
    "arxiv-id": "cs/0211021v1", 
    "title": "Sequent and Hypersequent Calculi for Abelian and Lukasiewicz Logics", 
    "publish": "2002-11-18T12:08:17Z", 
    "summary": "We present two embeddings of infinite-valued Lukasiewicz logic L into Meyer\nand Slaney's abelian logic A, the logic of lattice-ordered abelian groups. We\ngive new analytic proof systems for A and use the embeddings to derive\ncorresponding systems for L. These include: hypersequent calculi for A and L\nand terminating versions of these calculi; labelled single sequent calculi for\nA and L of complexity co-NP; unlabelled single sequent calculi for A and L."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0211021v1", 
    "other_authors": [
        "G. Metcalfe", 
        "N. Olivetti", 
        "D. Gabbay"
    ], 
    "lead_author": "D. Gabbay", 
    "arxiv-id": "cs/0211021v1", 
    "title": "Sequent and Hypersequent Calculi for Abelian and Lukasiewicz Logics", 
    "publish": "2002-11-18T12:08:17Z", 
    "summary": "We present two embeddings of infinite-valued Lukasiewicz logic L into Meyer\nand Slaney's abelian logic A, the logic of lattice-ordered abelian groups. We\ngive new analytic proof systems for A and use the embeddings to derive\ncorresponding systems for L. These include: hypersequent calculi for A and L\nand terminating versions of these calculi; labelled single sequent calculi for\nA and L of complexity co-NP; unlabelled single sequent calculi for A and L."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0211021v1", 
    "other_authors": [
        "G. Metcalfe", 
        "N. Olivetti", 
        "D. Gabbay"
    ], 
    "lead_author": "D. Gabbay", 
    "arxiv-id": "cs/0211021v1", 
    "title": "Sequent and Hypersequent Calculi for Abelian and Lukasiewicz Logics", 
    "publish": "2002-11-18T12:08:17Z", 
    "summary": "We present two embeddings of infinite-valued Lukasiewicz logic L into Meyer\nand Slaney's abelian logic A, the logic of lattice-ordered abelian groups. We\ngive new analytic proof systems for A and use the embeddings to derive\ncorresponding systems for L. These include: hypersequent calculi for A and L\nand terminating versions of these calculi; labelled single sequent calculi for\nA and L of complexity co-NP; unlabelled single sequent calculi for A and L."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0211021v1", 
    "other_authors": [
        "G. Metcalfe", 
        "N. Olivetti", 
        "D. Gabbay"
    ], 
    "lead_author": "D. Gabbay", 
    "arxiv-id": "cs/0211021v1", 
    "title": "Sequent and Hypersequent Calculi for Abelian and Lukasiewicz Logics", 
    "publish": "2002-11-18T12:08:17Z", 
    "summary": "We present two embeddings of infinite-valued Lukasiewicz logic L into Meyer\nand Slaney's abelian logic A, the logic of lattice-ordered abelian groups. We\ngive new analytic proof systems for A and use the embeddings to derive\ncorresponding systems for L. These include: hypersequent calculi for A and L\nand terminating versions of these calculi; labelled single sequent calculi for\nA and L of complexity co-NP; unlabelled single sequent calculi for A and L."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0211021v1", 
    "other_authors": [
        "G. Metcalfe", 
        "N. Olivetti", 
        "D. Gabbay"
    ], 
    "lead_author": "D. Gabbay", 
    "arxiv-id": "cs/0211021v1", 
    "title": "Sequent and Hypersequent Calculi for Abelian and Lukasiewicz Logics", 
    "publish": "2002-11-18T12:08:17Z", 
    "summary": "We present two embeddings of infinite-valued Lukasiewicz logic L into Meyer\nand Slaney's abelian logic A, the logic of lattice-ordered abelian groups. We\ngive new analytic proof systems for A and use the embeddings to derive\ncorresponding systems for L. These include: hypersequent calculi for A and L\nand terminating versions of these calculi; labelled single sequent calculi for\nA and L of complexity co-NP; unlabelled single sequent calculi for A and L."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0211021v1", 
    "other_authors": [
        "G. Metcalfe", 
        "N. Olivetti", 
        "D. Gabbay"
    ], 
    "lead_author": "D. Gabbay", 
    "arxiv-id": "cs/0211021v1", 
    "title": "Sequent and Hypersequent Calculi for Abelian and Lukasiewicz Logics", 
    "publish": "2002-11-18T12:08:17Z", 
    "summary": "We present two embeddings of infinite-valued Lukasiewicz logic L into Meyer\nand Slaney's abelian logic A, the logic of lattice-ordered abelian groups. We\ngive new analytic proof systems for A and use the embeddings to derive\ncorresponding systems for L. These include: hypersequent calculi for A and L\nand terminating versions of these calculi; labelled single sequent calculi for\nA and L of complexity co-NP; unlabelled single sequent calculi for A and L."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0211021v1", 
    "other_authors": [
        "G. Metcalfe", 
        "N. Olivetti", 
        "D. Gabbay"
    ], 
    "lead_author": "D. Gabbay", 
    "arxiv-id": "cs/0211021v1", 
    "title": "Sequent and Hypersequent Calculi for Abelian and Lukasiewicz Logics", 
    "publish": "2002-11-18T12:08:17Z", 
    "summary": "We present two embeddings of infinite-valued Lukasiewicz logic L into Meyer\nand Slaney's abelian logic A, the logic of lattice-ordered abelian groups. We\ngive new analytic proof systems for A and use the embeddings to derive\ncorresponding systems for L. These include: hypersequent calculi for A and L\nand terminating versions of these calculi; labelled single sequent calculi for\nA and L of complexity co-NP; unlabelled single sequent calculi for A and L."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0211021v1", 
    "other_authors": [
        "G. Metcalfe", 
        "N. Olivetti", 
        "D. Gabbay"
    ], 
    "lead_author": "D. Gabbay", 
    "arxiv-id": "cs/0211021v1", 
    "title": "Sequent and Hypersequent Calculi for Abelian and Lukasiewicz Logics", 
    "publish": "2002-11-18T12:08:17Z", 
    "summary": "We present two embeddings of infinite-valued Lukasiewicz logic L into Meyer\nand Slaney's abelian logic A, the logic of lattice-ordered abelian groups. We\ngive new analytic proof systems for A and use the embeddings to derive\ncorresponding systems for L. These include: hypersequent calculi for A and L\nand terminating versions of these calculi; labelled single sequent calculi for\nA and L of complexity co-NP; unlabelled single sequent calculi for A and L."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0211021v1", 
    "other_authors": [
        "G. Metcalfe", 
        "N. Olivetti", 
        "D. Gabbay"
    ], 
    "lead_author": "D. Gabbay", 
    "arxiv-id": "cs/0211021v1", 
    "title": "Sequent and Hypersequent Calculi for Abelian and Lukasiewicz Logics", 
    "publish": "2002-11-18T12:08:17Z", 
    "summary": "We present two embeddings of infinite-valued Lukasiewicz logic L into Meyer\nand Slaney's abelian logic A, the logic of lattice-ordered abelian groups. We\ngive new analytic proof systems for A and use the embeddings to derive\ncorresponding systems for L. These include: hypersequent calculi for A and L\nand terminating versions of these calculi; labelled single sequent calculi for\nA and L of complexity co-NP; unlabelled single sequent calculi for A and L."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0211021v1", 
    "other_authors": [
        "G. Metcalfe", 
        "N. Olivetti", 
        "D. Gabbay"
    ], 
    "lead_author": "D. Gabbay", 
    "arxiv-id": "cs/0211021v1", 
    "title": "Sequent and Hypersequent Calculi for Abelian and Lukasiewicz Logics", 
    "publish": "2002-11-18T12:08:17Z", 
    "summary": "We present two embeddings of infinite-valued Lukasiewicz logic L into Meyer\nand Slaney's abelian logic A, the logic of lattice-ordered abelian groups. We\ngive new analytic proof systems for A and use the embeddings to derive\ncorresponding systems for L. These include: hypersequent calculi for A and L\nand terminating versions of these calculi; labelled single sequent calculi for\nA and L of complexity co-NP; unlabelled single sequent calculi for A and L."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0211021v1", 
    "other_authors": [
        "G. Metcalfe", 
        "N. Olivetti", 
        "D. Gabbay"
    ], 
    "lead_author": "D. Gabbay", 
    "arxiv-id": "cs/0211021v1", 
    "title": "Sequent and Hypersequent Calculi for Abelian and Lukasiewicz Logics", 
    "publish": "2002-11-18T12:08:17Z", 
    "summary": "We present two embeddings of infinite-valued Lukasiewicz logic L into Meyer\nand Slaney's abelian logic A, the logic of lattice-ordered abelian groups. We\ngive new analytic proof systems for A and use the embeddings to derive\ncorresponding systems for L. These include: hypersequent calculi for A and L\nand terminating versions of these calculi; labelled single sequent calculi for\nA and L of complexity co-NP; unlabelled single sequent calculi for A and L."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0211021v1", 
    "other_authors": [
        "G. Metcalfe", 
        "N. Olivetti", 
        "D. Gabbay"
    ], 
    "lead_author": "D. Gabbay", 
    "arxiv-id": "cs/0211021v1", 
    "title": "Sequent and Hypersequent Calculi for Abelian and Lukasiewicz Logics", 
    "publish": "2002-11-18T12:08:17Z", 
    "summary": "We present two embeddings of infinite-valued Lukasiewicz logic L into Meyer\nand Slaney's abelian logic A, the logic of lattice-ordered abelian groups. We\ngive new analytic proof systems for A and use the embeddings to derive\ncorresponding systems for L. These include: hypersequent calculi for A and L\nand terminating versions of these calculi; labelled single sequent calculi for\nA and L of complexity co-NP; unlabelled single sequent calculi for A and L."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0211021v1", 
    "other_authors": [
        "G. Metcalfe", 
        "N. Olivetti", 
        "D. Gabbay"
    ], 
    "lead_author": "D. Gabbay", 
    "arxiv-id": "cs/0211021v1", 
    "title": "Sequent and Hypersequent Calculi for Abelian and Lukasiewicz Logics", 
    "publish": "2002-11-18T12:08:17Z", 
    "summary": "We present two embeddings of infinite-valued Lukasiewicz logic L into Meyer\nand Slaney's abelian logic A, the logic of lattice-ordered abelian groups. We\ngive new analytic proof systems for A and use the embeddings to derive\ncorresponding systems for L. These include: hypersequent calculi for A and L\nand terminating versions of these calculi; labelled single sequent calculi for\nA and L of complexity co-NP; unlabelled single sequent calculi for A and L."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0211021v1", 
    "other_authors": [
        "G. Metcalfe", 
        "N. Olivetti", 
        "D. Gabbay"
    ], 
    "lead_author": "D. Gabbay", 
    "arxiv-id": "cs/0211021v1", 
    "title": "Sequent and Hypersequent Calculi for Abelian and Lukasiewicz Logics", 
    "publish": "2002-11-18T12:08:17Z", 
    "summary": "We present two embeddings of infinite-valued Lukasiewicz logic L into Meyer\nand Slaney's abelian logic A, the logic of lattice-ordered abelian groups. We\ngive new analytic proof systems for A and use the embeddings to derive\ncorresponding systems for L. These include: hypersequent calculi for A and L\nand terminating versions of these calculi; labelled single sequent calculi for\nA and L of complexity co-NP; unlabelled single sequent calculi for A and L."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0211022v1", 
    "other_authors": [
        "Nicole Schweikardt"
    ], 
    "lead_author": "Nicole Schweikardt", 
    "arxiv-id": "cs/0211022v1", 
    "title": "Arithmetic, First-Order Logic, and Counting Quantifiers", 
    "publish": "2002-11-19T19:15:51Z", 
    "summary": "This paper gives a thorough overview of what is known about first-order logic\nwith counting quantifiers and with arithmetic predicates. As a main theorem we\nshow that Presburger arithmetic is closed under unary counting quantifiers.\nPrecisely, this means that for every first-order formula phi(y,z_1,...,z_k)\nover the signature {<,+} there is a first-order formula psi(x,z_1,...,z_k)\nwhich expresses over the structure <Nat,<,+> (respectively, over initial\nsegments of this structure) that the variable x is interpreted exactly by the\nnumber of possible interpretations of the variable y for which the formula\nphi(y,z_1,...,z_k) is satisfied. Applying this theorem, we obtain an easy proof\nof Ruhl's result that reachability (and similarly, connectivity) in finite\ngraphs is not expressible in first-order logic with unary counting quantifiers\nand addition. Furthermore, the above result on Presburger arithmetic helps to\nshow the failure of a particular version of the Crane Beach conjecture."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0211022v1", 
    "other_authors": [
        "Nicole Schweikardt"
    ], 
    "lead_author": "Nicole Schweikardt", 
    "arxiv-id": "cs/0211022v1", 
    "title": "Arithmetic, First-Order Logic, and Counting Quantifiers", 
    "publish": "2002-11-19T19:15:51Z", 
    "summary": "This paper gives a thorough overview of what is known about first-order logic\nwith counting quantifiers and with arithmetic predicates. As a main theorem we\nshow that Presburger arithmetic is closed under unary counting quantifiers.\nPrecisely, this means that for every first-order formula phi(y,z_1,...,z_k)\nover the signature {<,+} there is a first-order formula psi(x,z_1,...,z_k)\nwhich expresses over the structure <Nat,<,+> (respectively, over initial\nsegments of this structure) that the variable x is interpreted exactly by the\nnumber of possible interpretations of the variable y for which the formula\nphi(y,z_1,...,z_k) is satisfied. Applying this theorem, we obtain an easy proof\nof Ruhl's result that reachability (and similarly, connectivity) in finite\ngraphs is not expressible in first-order logic with unary counting quantifiers\nand addition. Furthermore, the above result on Presburger arithmetic helps to\nshow the failure of a particular version of the Crane Beach conjecture."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0211022v1", 
    "other_authors": [
        "Nicole Schweikardt"
    ], 
    "lead_author": "Nicole Schweikardt", 
    "arxiv-id": "cs/0211022v1", 
    "title": "Arithmetic, First-Order Logic, and Counting Quantifiers", 
    "publish": "2002-11-19T19:15:51Z", 
    "summary": "This paper gives a thorough overview of what is known about first-order logic\nwith counting quantifiers and with arithmetic predicates. As a main theorem we\nshow that Presburger arithmetic is closed under unary counting quantifiers.\nPrecisely, this means that for every first-order formula phi(y,z_1,...,z_k)\nover the signature {<,+} there is a first-order formula psi(x,z_1,...,z_k)\nwhich expresses over the structure <Nat,<,+> (respectively, over initial\nsegments of this structure) that the variable x is interpreted exactly by the\nnumber of possible interpretations of the variable y for which the formula\nphi(y,z_1,...,z_k) is satisfied. Applying this theorem, we obtain an easy proof\nof Ruhl's result that reachability (and similarly, connectivity) in finite\ngraphs is not expressible in first-order logic with unary counting quantifiers\nand addition. Furthermore, the above result on Presburger arithmetic helps to\nshow the failure of a particular version of the Crane Beach conjecture."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0211022v1", 
    "other_authors": [
        "Nicole Schweikardt"
    ], 
    "lead_author": "Nicole Schweikardt", 
    "arxiv-id": "cs/0211022v1", 
    "title": "Arithmetic, First-Order Logic, and Counting Quantifiers", 
    "publish": "2002-11-19T19:15:51Z", 
    "summary": "This paper gives a thorough overview of what is known about first-order logic\nwith counting quantifiers and with arithmetic predicates. As a main theorem we\nshow that Presburger arithmetic is closed under unary counting quantifiers.\nPrecisely, this means that for every first-order formula phi(y,z_1,...,z_k)\nover the signature {<,+} there is a first-order formula psi(x,z_1,...,z_k)\nwhich expresses over the structure <Nat,<,+> (respectively, over initial\nsegments of this structure) that the variable x is interpreted exactly by the\nnumber of possible interpretations of the variable y for which the formula\nphi(y,z_1,...,z_k) is satisfied. Applying this theorem, we obtain an easy proof\nof Ruhl's result that reachability (and similarly, connectivity) in finite\ngraphs is not expressible in first-order logic with unary counting quantifiers\nand addition. Furthermore, the above result on Presburger arithmetic helps to\nshow the failure of a particular version of the Crane Beach conjecture."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0211022v1", 
    "other_authors": [
        "Nicole Schweikardt"
    ], 
    "lead_author": "Nicole Schweikardt", 
    "arxiv-id": "cs/0211022v1", 
    "title": "Arithmetic, First-Order Logic, and Counting Quantifiers", 
    "publish": "2002-11-19T19:15:51Z", 
    "summary": "This paper gives a thorough overview of what is known about first-order logic\nwith counting quantifiers and with arithmetic predicates. As a main theorem we\nshow that Presburger arithmetic is closed under unary counting quantifiers.\nPrecisely, this means that for every first-order formula phi(y,z_1,...,z_k)\nover the signature {<,+} there is a first-order formula psi(x,z_1,...,z_k)\nwhich expresses over the structure <Nat,<,+> (respectively, over initial\nsegments of this structure) that the variable x is interpreted exactly by the\nnumber of possible interpretations of the variable y for which the formula\nphi(y,z_1,...,z_k) is satisfied. Applying this theorem, we obtain an easy proof\nof Ruhl's result that reachability (and similarly, connectivity) in finite\ngraphs is not expressible in first-order logic with unary counting quantifiers\nand addition. Furthermore, the above result on Presburger arithmetic helps to\nshow the failure of a particular version of the Crane Beach conjecture."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0211022v1", 
    "other_authors": [
        "Nicole Schweikardt"
    ], 
    "lead_author": "Nicole Schweikardt", 
    "arxiv-id": "cs/0211022v1", 
    "title": "Arithmetic, First-Order Logic, and Counting Quantifiers", 
    "publish": "2002-11-19T19:15:51Z", 
    "summary": "This paper gives a thorough overview of what is known about first-order logic\nwith counting quantifiers and with arithmetic predicates. As a main theorem we\nshow that Presburger arithmetic is closed under unary counting quantifiers.\nPrecisely, this means that for every first-order formula phi(y,z_1,...,z_k)\nover the signature {<,+} there is a first-order formula psi(x,z_1,...,z_k)\nwhich expresses over the structure <Nat,<,+> (respectively, over initial\nsegments of this structure) that the variable x is interpreted exactly by the\nnumber of possible interpretations of the variable y for which the formula\nphi(y,z_1,...,z_k) is satisfied. Applying this theorem, we obtain an easy proof\nof Ruhl's result that reachability (and similarly, connectivity) in finite\ngraphs is not expressible in first-order logic with unary counting quantifiers\nand addition. Furthermore, the above result on Presburger arithmetic helps to\nshow the failure of a particular version of the Crane Beach conjecture."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0211022v1", 
    "other_authors": [
        "Nicole Schweikardt"
    ], 
    "lead_author": "Nicole Schweikardt", 
    "arxiv-id": "cs/0211022v1", 
    "title": "Arithmetic, First-Order Logic, and Counting Quantifiers", 
    "publish": "2002-11-19T19:15:51Z", 
    "summary": "This paper gives a thorough overview of what is known about first-order logic\nwith counting quantifiers and with arithmetic predicates. As a main theorem we\nshow that Presburger arithmetic is closed under unary counting quantifiers.\nPrecisely, this means that for every first-order formula phi(y,z_1,...,z_k)\nover the signature {<,+} there is a first-order formula psi(x,z_1,...,z_k)\nwhich expresses over the structure <Nat,<,+> (respectively, over initial\nsegments of this structure) that the variable x is interpreted exactly by the\nnumber of possible interpretations of the variable y for which the formula\nphi(y,z_1,...,z_k) is satisfied. Applying this theorem, we obtain an easy proof\nof Ruhl's result that reachability (and similarly, connectivity) in finite\ngraphs is not expressible in first-order logic with unary counting quantifiers\nand addition. Furthermore, the above result on Presburger arithmetic helps to\nshow the failure of a particular version of the Crane Beach conjecture."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0211022v1", 
    "other_authors": [
        "Nicole Schweikardt"
    ], 
    "lead_author": "Nicole Schweikardt", 
    "arxiv-id": "cs/0211022v1", 
    "title": "Arithmetic, First-Order Logic, and Counting Quantifiers", 
    "publish": "2002-11-19T19:15:51Z", 
    "summary": "This paper gives a thorough overview of what is known about first-order logic\nwith counting quantifiers and with arithmetic predicates. As a main theorem we\nshow that Presburger arithmetic is closed under unary counting quantifiers.\nPrecisely, this means that for every first-order formula phi(y,z_1,...,z_k)\nover the signature {<,+} there is a first-order formula psi(x,z_1,...,z_k)\nwhich expresses over the structure <Nat,<,+> (respectively, over initial\nsegments of this structure) that the variable x is interpreted exactly by the\nnumber of possible interpretations of the variable y for which the formula\nphi(y,z_1,...,z_k) is satisfied. Applying this theorem, we obtain an easy proof\nof Ruhl's result that reachability (and similarly, connectivity) in finite\ngraphs is not expressible in first-order logic with unary counting quantifiers\nand addition. Furthermore, the above result on Presburger arithmetic helps to\nshow the failure of a particular version of the Crane Beach conjecture."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0211022v1", 
    "other_authors": [
        "Nicole Schweikardt"
    ], 
    "lead_author": "Nicole Schweikardt", 
    "arxiv-id": "cs/0211022v1", 
    "title": "Arithmetic, First-Order Logic, and Counting Quantifiers", 
    "publish": "2002-11-19T19:15:51Z", 
    "summary": "This paper gives a thorough overview of what is known about first-order logic\nwith counting quantifiers and with arithmetic predicates. As a main theorem we\nshow that Presburger arithmetic is closed under unary counting quantifiers.\nPrecisely, this means that for every first-order formula phi(y,z_1,...,z_k)\nover the signature {<,+} there is a first-order formula psi(x,z_1,...,z_k)\nwhich expresses over the structure <Nat,<,+> (respectively, over initial\nsegments of this structure) that the variable x is interpreted exactly by the\nnumber of possible interpretations of the variable y for which the formula\nphi(y,z_1,...,z_k) is satisfied. Applying this theorem, we obtain an easy proof\nof Ruhl's result that reachability (and similarly, connectivity) in finite\ngraphs is not expressible in first-order logic with unary counting quantifiers\nand addition. Furthermore, the above result on Presburger arithmetic helps to\nshow the failure of a particular version of the Crane Beach conjecture."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0211022v1", 
    "other_authors": [
        "Nicole Schweikardt"
    ], 
    "lead_author": "Nicole Schweikardt", 
    "arxiv-id": "cs/0211022v1", 
    "title": "Arithmetic, First-Order Logic, and Counting Quantifiers", 
    "publish": "2002-11-19T19:15:51Z", 
    "summary": "This paper gives a thorough overview of what is known about first-order logic\nwith counting quantifiers and with arithmetic predicates. As a main theorem we\nshow that Presburger arithmetic is closed under unary counting quantifiers.\nPrecisely, this means that for every first-order formula phi(y,z_1,...,z_k)\nover the signature {<,+} there is a first-order formula psi(x,z_1,...,z_k)\nwhich expresses over the structure <Nat,<,+> (respectively, over initial\nsegments of this structure) that the variable x is interpreted exactly by the\nnumber of possible interpretations of the variable y for which the formula\nphi(y,z_1,...,z_k) is satisfied. Applying this theorem, we obtain an easy proof\nof Ruhl's result that reachability (and similarly, connectivity) in finite\ngraphs is not expressible in first-order logic with unary counting quantifiers\nand addition. Furthermore, the above result on Presburger arithmetic helps to\nshow the failure of a particular version of the Crane Beach conjecture."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0211022v1", 
    "other_authors": [
        "Nicole Schweikardt"
    ], 
    "lead_author": "Nicole Schweikardt", 
    "arxiv-id": "cs/0211022v1", 
    "title": "Arithmetic, First-Order Logic, and Counting Quantifiers", 
    "publish": "2002-11-19T19:15:51Z", 
    "summary": "This paper gives a thorough overview of what is known about first-order logic\nwith counting quantifiers and with arithmetic predicates. As a main theorem we\nshow that Presburger arithmetic is closed under unary counting quantifiers.\nPrecisely, this means that for every first-order formula phi(y,z_1,...,z_k)\nover the signature {<,+} there is a first-order formula psi(x,z_1,...,z_k)\nwhich expresses over the structure <Nat,<,+> (respectively, over initial\nsegments of this structure) that the variable x is interpreted exactly by the\nnumber of possible interpretations of the variable y for which the formula\nphi(y,z_1,...,z_k) is satisfied. Applying this theorem, we obtain an easy proof\nof Ruhl's result that reachability (and similarly, connectivity) in finite\ngraphs is not expressible in first-order logic with unary counting quantifiers\nand addition. Furthermore, the above result on Presburger arithmetic helps to\nshow the failure of a particular version of the Crane Beach conjecture."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0211022v1", 
    "other_authors": [
        "Nicole Schweikardt"
    ], 
    "lead_author": "Nicole Schweikardt", 
    "arxiv-id": "cs/0211022v1", 
    "title": "Arithmetic, First-Order Logic, and Counting Quantifiers", 
    "publish": "2002-11-19T19:15:51Z", 
    "summary": "This paper gives a thorough overview of what is known about first-order logic\nwith counting quantifiers and with arithmetic predicates. As a main theorem we\nshow that Presburger arithmetic is closed under unary counting quantifiers.\nPrecisely, this means that for every first-order formula phi(y,z_1,...,z_k)\nover the signature {<,+} there is a first-order formula psi(x,z_1,...,z_k)\nwhich expresses over the structure <Nat,<,+> (respectively, over initial\nsegments of this structure) that the variable x is interpreted exactly by the\nnumber of possible interpretations of the variable y for which the formula\nphi(y,z_1,...,z_k) is satisfied. Applying this theorem, we obtain an easy proof\nof Ruhl's result that reachability (and similarly, connectivity) in finite\ngraphs is not expressible in first-order logic with unary counting quantifiers\nand addition. Furthermore, the above result on Presburger arithmetic helps to\nshow the failure of a particular version of the Crane Beach conjecture."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0211022v1", 
    "other_authors": [
        "Nicole Schweikardt"
    ], 
    "lead_author": "Nicole Schweikardt", 
    "arxiv-id": "cs/0211022v1", 
    "title": "Arithmetic, First-Order Logic, and Counting Quantifiers", 
    "publish": "2002-11-19T19:15:51Z", 
    "summary": "This paper gives a thorough overview of what is known about first-order logic\nwith counting quantifiers and with arithmetic predicates. As a main theorem we\nshow that Presburger arithmetic is closed under unary counting quantifiers.\nPrecisely, this means that for every first-order formula phi(y,z_1,...,z_k)\nover the signature {<,+} there is a first-order formula psi(x,z_1,...,z_k)\nwhich expresses over the structure <Nat,<,+> (respectively, over initial\nsegments of this structure) that the variable x is interpreted exactly by the\nnumber of possible interpretations of the variable y for which the formula\nphi(y,z_1,...,z_k) is satisfied. Applying this theorem, we obtain an easy proof\nof Ruhl's result that reachability (and similarly, connectivity) in finite\ngraphs is not expressible in first-order logic with unary counting quantifiers\nand addition. Furthermore, the above result on Presburger arithmetic helps to\nshow the failure of a particular version of the Crane Beach conjecture."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0211022v1", 
    "other_authors": [
        "Nicole Schweikardt"
    ], 
    "lead_author": "Nicole Schweikardt", 
    "arxiv-id": "cs/0211022v1", 
    "title": "Arithmetic, First-Order Logic, and Counting Quantifiers", 
    "publish": "2002-11-19T19:15:51Z", 
    "summary": "This paper gives a thorough overview of what is known about first-order logic\nwith counting quantifiers and with arithmetic predicates. As a main theorem we\nshow that Presburger arithmetic is closed under unary counting quantifiers.\nPrecisely, this means that for every first-order formula phi(y,z_1,...,z_k)\nover the signature {<,+} there is a first-order formula psi(x,z_1,...,z_k)\nwhich expresses over the structure <Nat,<,+> (respectively, over initial\nsegments of this structure) that the variable x is interpreted exactly by the\nnumber of possible interpretations of the variable y for which the formula\nphi(y,z_1,...,z_k) is satisfied. Applying this theorem, we obtain an easy proof\nof Ruhl's result that reachability (and similarly, connectivity) in finite\ngraphs is not expressible in first-order logic with unary counting quantifiers\nand addition. Furthermore, the above result on Presburger arithmetic helps to\nshow the failure of a particular version of the Crane Beach conjecture."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0211022v1", 
    "other_authors": [
        "Nicole Schweikardt"
    ], 
    "lead_author": "Nicole Schweikardt", 
    "arxiv-id": "cs/0211022v1", 
    "title": "Arithmetic, First-Order Logic, and Counting Quantifiers", 
    "publish": "2002-11-19T19:15:51Z", 
    "summary": "This paper gives a thorough overview of what is known about first-order logic\nwith counting quantifiers and with arithmetic predicates. As a main theorem we\nshow that Presburger arithmetic is closed under unary counting quantifiers.\nPrecisely, this means that for every first-order formula phi(y,z_1,...,z_k)\nover the signature {<,+} there is a first-order formula psi(x,z_1,...,z_k)\nwhich expresses over the structure <Nat,<,+> (respectively, over initial\nsegments of this structure) that the variable x is interpreted exactly by the\nnumber of possible interpretations of the variable y for which the formula\nphi(y,z_1,...,z_k) is satisfied. Applying this theorem, we obtain an easy proof\nof Ruhl's result that reachability (and similarly, connectivity) in finite\ngraphs is not expressible in first-order logic with unary counting quantifiers\nand addition. Furthermore, the above result on Presburger arithmetic helps to\nshow the failure of a particular version of the Crane Beach conjecture."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0211022v1", 
    "other_authors": [
        "Nicole Schweikardt"
    ], 
    "lead_author": "Nicole Schweikardt", 
    "arxiv-id": "cs/0211022v1", 
    "title": "Arithmetic, First-Order Logic, and Counting Quantifiers", 
    "publish": "2002-11-19T19:15:51Z", 
    "summary": "This paper gives a thorough overview of what is known about first-order logic\nwith counting quantifiers and with arithmetic predicates. As a main theorem we\nshow that Presburger arithmetic is closed under unary counting quantifiers.\nPrecisely, this means that for every first-order formula phi(y,z_1,...,z_k)\nover the signature {<,+} there is a first-order formula psi(x,z_1,...,z_k)\nwhich expresses over the structure <Nat,<,+> (respectively, over initial\nsegments of this structure) that the variable x is interpreted exactly by the\nnumber of possible interpretations of the variable y for which the formula\nphi(y,z_1,...,z_k) is satisfied. Applying this theorem, we obtain an easy proof\nof Ruhl's result that reachability (and similarly, connectivity) in finite\ngraphs is not expressible in first-order logic with unary counting quantifiers\nand addition. Furthermore, the above result on Presburger arithmetic helps to\nshow the failure of a particular version of the Crane Beach conjecture."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0212005v1", 
    "other_authors": [
        "Laurent Regnier", 
        "Pawel Urzyczyn"
    ], 
    "lead_author": "Laurent Regnier", 
    "arxiv-id": "cs/0212005v1", 
    "title": "Retractions of Types with Many Atoms", 
    "publish": "2002-12-05T17:29:12Z", 
    "summary": "We define a sound and complete proof system for affine beta-eta-retractions\nin simple types built over many atoms, and we state simple necessary conditions\nfor arbitrary beta-eta-retractions in simple and polymorphic types."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0212005v1", 
    "other_authors": [
        "Laurent Regnier", 
        "Pawel Urzyczyn"
    ], 
    "lead_author": "Pawel Urzyczyn", 
    "arxiv-id": "cs/0212005v1", 
    "title": "Retractions of Types with Many Atoms", 
    "publish": "2002-12-05T17:29:12Z", 
    "summary": "We define a sound and complete proof system for affine beta-eta-retractions\nin simple types built over many atoms, and we state simple necessary conditions\nfor arbitrary beta-eta-retractions in simple and polymorphic types."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0212005v1", 
    "other_authors": [
        "Laurent Regnier", 
        "Pawel Urzyczyn"
    ], 
    "lead_author": "Pawel Urzyczyn", 
    "arxiv-id": "cs/0212005v1", 
    "title": "Retractions of Types with Many Atoms", 
    "publish": "2002-12-05T17:29:12Z", 
    "summary": "We define a sound and complete proof system for affine beta-eta-retractions\nin simple types built over many atoms, and we state simple necessary conditions\nfor arbitrary beta-eta-retractions in simple and polymorphic types."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0212005v1", 
    "other_authors": [
        "Laurent Regnier", 
        "Pawel Urzyczyn"
    ], 
    "lead_author": "Pawel Urzyczyn", 
    "arxiv-id": "cs/0212005v1", 
    "title": "Retractions of Types with Many Atoms", 
    "publish": "2002-12-05T17:29:12Z", 
    "summary": "We define a sound and complete proof system for affine beta-eta-retractions\nin simple types built over many atoms, and we state simple necessary conditions\nfor arbitrary beta-eta-retractions in simple and polymorphic types."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0212026v1", 
    "other_authors": [
        "Etienne Payet", 
        "Fred Mesnard"
    ], 
    "lead_author": "Etienne Payet", 
    "arxiv-id": "cs/0212026v1", 
    "title": "A Generalization of the Lifting Lemma for Logic Programming", 
    "publish": "2002-12-11T09:48:39Z", 
    "summary": "Since the seminal work of J. A. Robinson on resolution, many lifting lemmas\nfor simplifying proofs of completeness of resolution have been proposed in the\nliterature. In the logic programming framework, they may also help to detect\nsome infinite derivations while proving goals under the SLD-resolution. In this\npaper, we first generalize a version of the lifting lemma, by extending the\nrelation \"is more general than\" so that it takes into account only some\narguments of the atoms. The other arguments, which we call neutral arguments,\nare disregarded. Then we propose two syntactic conditions of increasing power\nfor identifying neutral arguments from mere inspection of the text of a logic\nprogram."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0212026v1", 
    "other_authors": [
        "Etienne Payet", 
        "Fred Mesnard"
    ], 
    "lead_author": "Etienne Payet", 
    "arxiv-id": "cs/0212026v1", 
    "title": "A Generalization of the Lifting Lemma for Logic Programming", 
    "publish": "2002-12-11T09:48:39Z", 
    "summary": "Since the seminal work of J. A. Robinson on resolution, many lifting lemmas\nfor simplifying proofs of completeness of resolution have been proposed in the\nliterature. In the logic programming framework, they may also help to detect\nsome infinite derivations while proving goals under the SLD-resolution. In this\npaper, we first generalize a version of the lifting lemma, by extending the\nrelation \"is more general than\" so that it takes into account only some\narguments of the atoms. The other arguments, which we call neutral arguments,\nare disregarded. Then we propose two syntactic conditions of increasing power\nfor identifying neutral arguments from mere inspection of the text of a logic\nprogram."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0212026v1", 
    "other_authors": [
        "Etienne Payet", 
        "Fred Mesnard"
    ], 
    "lead_author": "Etienne Payet", 
    "arxiv-id": "cs/0212026v1", 
    "title": "A Generalization of the Lifting Lemma for Logic Programming", 
    "publish": "2002-12-11T09:48:39Z", 
    "summary": "Since the seminal work of J. A. Robinson on resolution, many lifting lemmas\nfor simplifying proofs of completeness of resolution have been proposed in the\nliterature. In the logic programming framework, they may also help to detect\nsome infinite derivations while proving goals under the SLD-resolution. In this\npaper, we first generalize a version of the lifting lemma, by extending the\nrelation \"is more general than\" so that it takes into account only some\narguments of the atoms. The other arguments, which we call neutral arguments,\nare disregarded. Then we propose two syntactic conditions of increasing power\nfor identifying neutral arguments from mere inspection of the text of a logic\nprogram."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0212026v1", 
    "other_authors": [
        "Etienne Payet", 
        "Fred Mesnard"
    ], 
    "lead_author": "Etienne Payet", 
    "arxiv-id": "cs/0212026v1", 
    "title": "A Generalization of the Lifting Lemma for Logic Programming", 
    "publish": "2002-12-11T09:48:39Z", 
    "summary": "Since the seminal work of J. A. Robinson on resolution, many lifting lemmas\nfor simplifying proofs of completeness of resolution have been proposed in the\nliterature. In the logic programming framework, they may also help to detect\nsome infinite derivations while proving goals under the SLD-resolution. In this\npaper, we first generalize a version of the lifting lemma, by extending the\nrelation \"is more general than\" so that it takes into account only some\narguments of the atoms. The other arguments, which we call neutral arguments,\nare disregarded. Then we propose two syntactic conditions of increasing power\nfor identifying neutral arguments from mere inspection of the text of a logic\nprogram."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0212026v1", 
    "other_authors": [
        "Etienne Payet", 
        "Fred Mesnard"
    ], 
    "lead_author": "Etienne Payet", 
    "arxiv-id": "cs/0212026v1", 
    "title": "A Generalization of the Lifting Lemma for Logic Programming", 
    "publish": "2002-12-11T09:48:39Z", 
    "summary": "Since the seminal work of J. A. Robinson on resolution, many lifting lemmas\nfor simplifying proofs of completeness of resolution have been proposed in the\nliterature. In the logic programming framework, they may also help to detect\nsome infinite derivations while proving goals under the SLD-resolution. In this\npaper, we first generalize a version of the lifting lemma, by extending the\nrelation \"is more general than\" so that it takes into account only some\narguments of the atoms. The other arguments, which we call neutral arguments,\nare disregarded. Then we propose two syntactic conditions of increasing power\nfor identifying neutral arguments from mere inspection of the text of a logic\nprogram."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0212026v1", 
    "other_authors": [
        "Etienne Payet", 
        "Fred Mesnard"
    ], 
    "lead_author": "Etienne Payet", 
    "arxiv-id": "cs/0212026v1", 
    "title": "A Generalization of the Lifting Lemma for Logic Programming", 
    "publish": "2002-12-11T09:48:39Z", 
    "summary": "Since the seminal work of J. A. Robinson on resolution, many lifting lemmas\nfor simplifying proofs of completeness of resolution have been proposed in the\nliterature. In the logic programming framework, they may also help to detect\nsome infinite derivations while proving goals under the SLD-resolution. In this\npaper, we first generalize a version of the lifting lemma, by extending the\nrelation \"is more general than\" so that it takes into account only some\narguments of the atoms. The other arguments, which we call neutral arguments,\nare disregarded. Then we propose two syntactic conditions of increasing power\nfor identifying neutral arguments from mere inspection of the text of a logic\nprogram."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0212026v1", 
    "other_authors": [
        "Etienne Payet", 
        "Fred Mesnard"
    ], 
    "lead_author": "Etienne Payet", 
    "arxiv-id": "cs/0212026v1", 
    "title": "A Generalization of the Lifting Lemma for Logic Programming", 
    "publish": "2002-12-11T09:48:39Z", 
    "summary": "Since the seminal work of J. A. Robinson on resolution, many lifting lemmas\nfor simplifying proofs of completeness of resolution have been proposed in the\nliterature. In the logic programming framework, they may also help to detect\nsome infinite derivations while proving goals under the SLD-resolution. In this\npaper, we first generalize a version of the lifting lemma, by extending the\nrelation \"is more general than\" so that it takes into account only some\narguments of the atoms. The other arguments, which we call neutral arguments,\nare disregarded. Then we propose two syntactic conditions of increasing power\nfor identifying neutral arguments from mere inspection of the text of a logic\nprogram."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0212026v1", 
    "other_authors": [
        "Etienne Payet", 
        "Fred Mesnard"
    ], 
    "lead_author": "Etienne Payet", 
    "arxiv-id": "cs/0212026v1", 
    "title": "A Generalization of the Lifting Lemma for Logic Programming", 
    "publish": "2002-12-11T09:48:39Z", 
    "summary": "Since the seminal work of J. A. Robinson on resolution, many lifting lemmas\nfor simplifying proofs of completeness of resolution have been proposed in the\nliterature. In the logic programming framework, they may also help to detect\nsome infinite derivations while proving goals under the SLD-resolution. In this\npaper, we first generalize a version of the lifting lemma, by extending the\nrelation \"is more general than\" so that it takes into account only some\narguments of the atoms. The other arguments, which we call neutral arguments,\nare disregarded. Then we propose two syntactic conditions of increasing power\nfor identifying neutral arguments from mere inspection of the text of a logic\nprogram."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0212026v1", 
    "other_authors": [
        "Etienne Payet", 
        "Fred Mesnard"
    ], 
    "lead_author": "Etienne Payet", 
    "arxiv-id": "cs/0212026v1", 
    "title": "A Generalization of the Lifting Lemma for Logic Programming", 
    "publish": "2002-12-11T09:48:39Z", 
    "summary": "Since the seminal work of J. A. Robinson on resolution, many lifting lemmas\nfor simplifying proofs of completeness of resolution have been proposed in the\nliterature. In the logic programming framework, they may also help to detect\nsome infinite derivations while proving goals under the SLD-resolution. In this\npaper, we first generalize a version of the lifting lemma, by extending the\nrelation \"is more general than\" so that it takes into account only some\narguments of the atoms. The other arguments, which we call neutral arguments,\nare disregarded. Then we propose two syntactic conditions of increasing power\nfor identifying neutral arguments from mere inspection of the text of a logic\nprogram."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0212026v1", 
    "other_authors": [
        "Etienne Payet", 
        "Fred Mesnard"
    ], 
    "lead_author": "Fred Mesnard", 
    "arxiv-id": "cs/0212026v1", 
    "title": "A Generalization of the Lifting Lemma for Logic Programming", 
    "publish": "2002-12-11T09:48:39Z", 
    "summary": "Since the seminal work of J. A. Robinson on resolution, many lifting lemmas\nfor simplifying proofs of completeness of resolution have been proposed in the\nliterature. In the logic programming framework, they may also help to detect\nsome infinite derivations while proving goals under the SLD-resolution. In this\npaper, we first generalize a version of the lifting lemma, by extending the\nrelation \"is more general than\" so that it takes into account only some\narguments of the atoms. The other arguments, which we call neutral arguments,\nare disregarded. Then we propose two syntactic conditions of increasing power\nfor identifying neutral arguments from mere inspection of the text of a logic\nprogram."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0212026v1", 
    "other_authors": [
        "Etienne Payet", 
        "Fred Mesnard"
    ], 
    "lead_author": "Fred Mesnard", 
    "arxiv-id": "cs/0212026v1", 
    "title": "A Generalization of the Lifting Lemma for Logic Programming", 
    "publish": "2002-12-11T09:48:39Z", 
    "summary": "Since the seminal work of J. A. Robinson on resolution, many lifting lemmas\nfor simplifying proofs of completeness of resolution have been proposed in the\nliterature. In the logic programming framework, they may also help to detect\nsome infinite derivations while proving goals under the SLD-resolution. In this\npaper, we first generalize a version of the lifting lemma, by extending the\nrelation \"is more general than\" so that it takes into account only some\narguments of the atoms. The other arguments, which we call neutral arguments,\nare disregarded. Then we propose two syntactic conditions of increasing power\nfor identifying neutral arguments from mere inspection of the text of a logic\nprogram."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0212026v1", 
    "other_authors": [
        "Etienne Payet", 
        "Fred Mesnard"
    ], 
    "lead_author": "Fred Mesnard", 
    "arxiv-id": "cs/0212026v1", 
    "title": "A Generalization of the Lifting Lemma for Logic Programming", 
    "publish": "2002-12-11T09:48:39Z", 
    "summary": "Since the seminal work of J. A. Robinson on resolution, many lifting lemmas\nfor simplifying proofs of completeness of resolution have been proposed in the\nliterature. In the logic programming framework, they may also help to detect\nsome infinite derivations while proving goals under the SLD-resolution. In this\npaper, we first generalize a version of the lifting lemma, by extending the\nrelation \"is more general than\" so that it takes into account only some\narguments of the atoms. The other arguments, which we call neutral arguments,\nare disregarded. Then we propose two syntactic conditions of increasing power\nfor identifying neutral arguments from mere inspection of the text of a logic\nprogram."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0212026v1", 
    "other_authors": [
        "Etienne Payet", 
        "Fred Mesnard"
    ], 
    "lead_author": "Fred Mesnard", 
    "arxiv-id": "cs/0212026v1", 
    "title": "A Generalization of the Lifting Lemma for Logic Programming", 
    "publish": "2002-12-11T09:48:39Z", 
    "summary": "Since the seminal work of J. A. Robinson on resolution, many lifting lemmas\nfor simplifying proofs of completeness of resolution have been proposed in the\nliterature. In the logic programming framework, they may also help to detect\nsome infinite derivations while proving goals under the SLD-resolution. In this\npaper, we first generalize a version of the lifting lemma, by extending the\nrelation \"is more general than\" so that it takes into account only some\narguments of the atoms. The other arguments, which we call neutral arguments,\nare disregarded. Then we propose two syntactic conditions of increasing power\nfor identifying neutral arguments from mere inspection of the text of a logic\nprogram."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0212026v1", 
    "other_authors": [
        "Etienne Payet", 
        "Fred Mesnard"
    ], 
    "lead_author": "Fred Mesnard", 
    "arxiv-id": "cs/0212026v1", 
    "title": "A Generalization of the Lifting Lemma for Logic Programming", 
    "publish": "2002-12-11T09:48:39Z", 
    "summary": "Since the seminal work of J. A. Robinson on resolution, many lifting lemmas\nfor simplifying proofs of completeness of resolution have been proposed in the\nliterature. In the logic programming framework, they may also help to detect\nsome infinite derivations while proving goals under the SLD-resolution. In this\npaper, we first generalize a version of the lifting lemma, by extending the\nrelation \"is more general than\" so that it takes into account only some\narguments of the atoms. The other arguments, which we call neutral arguments,\nare disregarded. Then we propose two syntactic conditions of increasing power\nfor identifying neutral arguments from mere inspection of the text of a logic\nprogram."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0212026v1", 
    "other_authors": [
        "Etienne Payet", 
        "Fred Mesnard"
    ], 
    "lead_author": "Fred Mesnard", 
    "arxiv-id": "cs/0212026v1", 
    "title": "A Generalization of the Lifting Lemma for Logic Programming", 
    "publish": "2002-12-11T09:48:39Z", 
    "summary": "Since the seminal work of J. A. Robinson on resolution, many lifting lemmas\nfor simplifying proofs of completeness of resolution have been proposed in the\nliterature. In the logic programming framework, they may also help to detect\nsome infinite derivations while proving goals under the SLD-resolution. In this\npaper, we first generalize a version of the lifting lemma, by extending the\nrelation \"is more general than\" so that it takes into account only some\narguments of the atoms. The other arguments, which we call neutral arguments,\nare disregarded. Then we propose two syntactic conditions of increasing power\nfor identifying neutral arguments from mere inspection of the text of a logic\nprogram."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0212026v1", 
    "other_authors": [
        "Etienne Payet", 
        "Fred Mesnard"
    ], 
    "lead_author": "Fred Mesnard", 
    "arxiv-id": "cs/0212026v1", 
    "title": "A Generalization of the Lifting Lemma for Logic Programming", 
    "publish": "2002-12-11T09:48:39Z", 
    "summary": "Since the seminal work of J. A. Robinson on resolution, many lifting lemmas\nfor simplifying proofs of completeness of resolution have been proposed in the\nliterature. In the logic programming framework, they may also help to detect\nsome infinite derivations while proving goals under the SLD-resolution. In this\npaper, we first generalize a version of the lifting lemma, by extending the\nrelation \"is more general than\" so that it takes into account only some\narguments of the atoms. The other arguments, which we call neutral arguments,\nare disregarded. Then we propose two syntactic conditions of increasing power\nfor identifying neutral arguments from mere inspection of the text of a logic\nprogram."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0212026v1", 
    "other_authors": [
        "Etienne Payet", 
        "Fred Mesnard"
    ], 
    "lead_author": "Fred Mesnard", 
    "arxiv-id": "cs/0212026v1", 
    "title": "A Generalization of the Lifting Lemma for Logic Programming", 
    "publish": "2002-12-11T09:48:39Z", 
    "summary": "Since the seminal work of J. A. Robinson on resolution, many lifting lemmas\nfor simplifying proofs of completeness of resolution have been proposed in the\nliterature. In the logic programming framework, they may also help to detect\nsome infinite derivations while proving goals under the SLD-resolution. In this\npaper, we first generalize a version of the lifting lemma, by extending the\nrelation \"is more general than\" so that it takes into account only some\narguments of the atoms. The other arguments, which we call neutral arguments,\nare disregarded. Then we propose two syntactic conditions of increasing power\nfor identifying neutral arguments from mere inspection of the text of a logic\nprogram."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0212026v1", 
    "other_authors": [
        "Etienne Payet", 
        "Fred Mesnard"
    ], 
    "lead_author": "Fred Mesnard", 
    "arxiv-id": "cs/0212026v1", 
    "title": "A Generalization of the Lifting Lemma for Logic Programming", 
    "publish": "2002-12-11T09:48:39Z", 
    "summary": "Since the seminal work of J. A. Robinson on resolution, many lifting lemmas\nfor simplifying proofs of completeness of resolution have been proposed in the\nliterature. In the logic programming framework, they may also help to detect\nsome infinite derivations while proving goals under the SLD-resolution. In this\npaper, we first generalize a version of the lifting lemma, by extending the\nrelation \"is more general than\" so that it takes into account only some\narguments of the atoms. The other arguments, which we call neutral arguments,\nare disregarded. Then we propose two syntactic conditions of increasing power\nfor identifying neutral arguments from mere inspection of the text of a logic\nprogram."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0212026v1", 
    "other_authors": [
        "Etienne Payet", 
        "Fred Mesnard"
    ], 
    "lead_author": "Fred Mesnard", 
    "arxiv-id": "cs/0212026v1", 
    "title": "A Generalization of the Lifting Lemma for Logic Programming", 
    "publish": "2002-12-11T09:48:39Z", 
    "summary": "Since the seminal work of J. A. Robinson on resolution, many lifting lemmas\nfor simplifying proofs of completeness of resolution have been proposed in the\nliterature. In the logic programming framework, they may also help to detect\nsome infinite derivations while proving goals under the SLD-resolution. In this\npaper, we first generalize a version of the lifting lemma, by extending the\nrelation \"is more general than\" so that it takes into account only some\narguments of the atoms. The other arguments, which we call neutral arguments,\nare disregarded. Then we propose two syntactic conditions of increasing power\nfor identifying neutral arguments from mere inspection of the text of a logic\nprogram."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0212026v1", 
    "other_authors": [
        "Etienne Payet", 
        "Fred Mesnard"
    ], 
    "lead_author": "Fred Mesnard", 
    "arxiv-id": "cs/0212026v1", 
    "title": "A Generalization of the Lifting Lemma for Logic Programming", 
    "publish": "2002-12-11T09:48:39Z", 
    "summary": "Since the seminal work of J. A. Robinson on resolution, many lifting lemmas\nfor simplifying proofs of completeness of resolution have been proposed in the\nliterature. In the logic programming framework, they may also help to detect\nsome infinite derivations while proving goals under the SLD-resolution. In this\npaper, we first generalize a version of the lifting lemma, by extending the\nrelation \"is more general than\" so that it takes into account only some\narguments of the atoms. The other arguments, which we call neutral arguments,\nare disregarded. Then we propose two syntactic conditions of increasing power\nfor identifying neutral arguments from mere inspection of the text of a logic\nprogram."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0212026v1", 
    "other_authors": [
        "Etienne Payet", 
        "Fred Mesnard"
    ], 
    "lead_author": "Fred Mesnard", 
    "arxiv-id": "cs/0212026v1", 
    "title": "A Generalization of the Lifting Lemma for Logic Programming", 
    "publish": "2002-12-11T09:48:39Z", 
    "summary": "Since the seminal work of J. A. Robinson on resolution, many lifting lemmas\nfor simplifying proofs of completeness of resolution have been proposed in the\nliterature. In the logic programming framework, they may also help to detect\nsome infinite derivations while proving goals under the SLD-resolution. In this\npaper, we first generalize a version of the lifting lemma, by extending the\nrelation \"is more general than\" so that it takes into account only some\narguments of the atoms. The other arguments, which we call neutral arguments,\nare disregarded. Then we propose two syntactic conditions of increasing power\nfor identifying neutral arguments from mere inspection of the text of a logic\nprogram."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0212026v1", 
    "other_authors": [
        "Etienne Payet", 
        "Fred Mesnard"
    ], 
    "lead_author": "Fred Mesnard", 
    "arxiv-id": "cs/0212026v1", 
    "title": "A Generalization of the Lifting Lemma for Logic Programming", 
    "publish": "2002-12-11T09:48:39Z", 
    "summary": "Since the seminal work of J. A. Robinson on resolution, many lifting lemmas\nfor simplifying proofs of completeness of resolution have been proposed in the\nliterature. In the logic programming framework, they may also help to detect\nsome infinite derivations while proving goals under the SLD-resolution. In this\npaper, we first generalize a version of the lifting lemma, by extending the\nrelation \"is more general than\" so that it takes into account only some\narguments of the atoms. The other arguments, which we call neutral arguments,\nare disregarded. Then we propose two syntactic conditions of increasing power\nfor identifying neutral arguments from mere inspection of the text of a logic\nprogram."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0212026v1", 
    "other_authors": [
        "Etienne Payet", 
        "Fred Mesnard"
    ], 
    "lead_author": "Fred Mesnard", 
    "arxiv-id": "cs/0212026v1", 
    "title": "A Generalization of the Lifting Lemma for Logic Programming", 
    "publish": "2002-12-11T09:48:39Z", 
    "summary": "Since the seminal work of J. A. Robinson on resolution, many lifting lemmas\nfor simplifying proofs of completeness of resolution have been proposed in the\nliterature. In the logic programming framework, they may also help to detect\nsome infinite derivations while proving goals under the SLD-resolution. In this\npaper, we first generalize a version of the lifting lemma, by extending the\nrelation \"is more general than\" so that it takes into account only some\narguments of the atoms. The other arguments, which we call neutral arguments,\nare disregarded. Then we propose two syntactic conditions of increasing power\nfor identifying neutral arguments from mere inspection of the text of a logic\nprogram."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0301026v1", 
    "other_authors": [
        "Michael Beeson", 
        "Robert Veroff", 
        "Larry Wos"
    ], 
    "lead_author": "Michael Beeson", 
    "arxiv-id": "cs/0301026v1", 
    "title": "Double-Negation Elimination in Some Propositional Logics", 
    "publish": "2003-01-24T20:25:50Z", 
    "summary": "This article answers two questions (posed in the literature), each concerning\nthe guaranteed existence of proofs free of double negation. A proof is free of\ndouble negation if none of its deduced steps contains a term of the form\nn(n(t)) for some term t, where n denotes negation. The first question asks for\nconditions on the hypotheses that, if satisfied, guarantee the existence of a\ndouble-negation-free proof when the conclusion is free of double negation. The\nsecond question asks about the existence of an axiom system for classical\npropositional calculus whose use, for theorems with a conclusion free of double\nnegation, guarantees the existence of a double-negation-free proof. After\ngiving conditions that answer the first question, we answer the second question\nby focusing on the Lukasiewicz three-axiom system. We then extend our studies\nto infinite-valued sentential calculus and to intuitionistic logic and\ngeneralize the notion of being double-negation free. The double-negation proofs\nof interest rely exclusively on the inference rule condensed detachment, a rule\nthat combines modus ponens with an appropriately general rule of substitution.\nThe automated reasoning program OTTER played an indispensable role in this\nstudy."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0301026v1", 
    "other_authors": [
        "Michael Beeson", 
        "Robert Veroff", 
        "Larry Wos"
    ], 
    "lead_author": "Michael Beeson", 
    "arxiv-id": "cs/0301026v1", 
    "title": "Double-Negation Elimination in Some Propositional Logics", 
    "publish": "2003-01-24T20:25:50Z", 
    "summary": "This article answers two questions (posed in the literature), each concerning\nthe guaranteed existence of proofs free of double negation. A proof is free of\ndouble negation if none of its deduced steps contains a term of the form\nn(n(t)) for some term t, where n denotes negation. The first question asks for\nconditions on the hypotheses that, if satisfied, guarantee the existence of a\ndouble-negation-free proof when the conclusion is free of double negation. The\nsecond question asks about the existence of an axiom system for classical\npropositional calculus whose use, for theorems with a conclusion free of double\nnegation, guarantees the existence of a double-negation-free proof. After\ngiving conditions that answer the first question, we answer the second question\nby focusing on the Lukasiewicz three-axiom system. We then extend our studies\nto infinite-valued sentential calculus and to intuitionistic logic and\ngeneralize the notion of being double-negation free. The double-negation proofs\nof interest rely exclusively on the inference rule condensed detachment, a rule\nthat combines modus ponens with an appropriately general rule of substitution.\nThe automated reasoning program OTTER played an indispensable role in this\nstudy."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0301026v1", 
    "other_authors": [
        "Michael Beeson", 
        "Robert Veroff", 
        "Larry Wos"
    ], 
    "lead_author": "Michael Beeson", 
    "arxiv-id": "cs/0301026v1", 
    "title": "Double-Negation Elimination in Some Propositional Logics", 
    "publish": "2003-01-24T20:25:50Z", 
    "summary": "This article answers two questions (posed in the literature), each concerning\nthe guaranteed existence of proofs free of double negation. A proof is free of\ndouble negation if none of its deduced steps contains a term of the form\nn(n(t)) for some term t, where n denotes negation. The first question asks for\nconditions on the hypotheses that, if satisfied, guarantee the existence of a\ndouble-negation-free proof when the conclusion is free of double negation. The\nsecond question asks about the existence of an axiom system for classical\npropositional calculus whose use, for theorems with a conclusion free of double\nnegation, guarantees the existence of a double-negation-free proof. After\ngiving conditions that answer the first question, we answer the second question\nby focusing on the Lukasiewicz three-axiom system. We then extend our studies\nto infinite-valued sentential calculus and to intuitionistic logic and\ngeneralize the notion of being double-negation free. The double-negation proofs\nof interest rely exclusively on the inference rule condensed detachment, a rule\nthat combines modus ponens with an appropriately general rule of substitution.\nThe automated reasoning program OTTER played an indispensable role in this\nstudy."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0301026v1", 
    "other_authors": [
        "Michael Beeson", 
        "Robert Veroff", 
        "Larry Wos"
    ], 
    "lead_author": "Michael Beeson", 
    "arxiv-id": "cs/0301026v1", 
    "title": "Double-Negation Elimination in Some Propositional Logics", 
    "publish": "2003-01-24T20:25:50Z", 
    "summary": "This article answers two questions (posed in the literature), each concerning\nthe guaranteed existence of proofs free of double negation. A proof is free of\ndouble negation if none of its deduced steps contains a term of the form\nn(n(t)) for some term t, where n denotes negation. The first question asks for\nconditions on the hypotheses that, if satisfied, guarantee the existence of a\ndouble-negation-free proof when the conclusion is free of double negation. The\nsecond question asks about the existence of an axiom system for classical\npropositional calculus whose use, for theorems with a conclusion free of double\nnegation, guarantees the existence of a double-negation-free proof. After\ngiving conditions that answer the first question, we answer the second question\nby focusing on the Lukasiewicz three-axiom system. We then extend our studies\nto infinite-valued sentential calculus and to intuitionistic logic and\ngeneralize the notion of being double-negation free. The double-negation proofs\nof interest rely exclusively on the inference rule condensed detachment, a rule\nthat combines modus ponens with an appropriately general rule of substitution.\nThe automated reasoning program OTTER played an indispensable role in this\nstudy."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0301026v1", 
    "other_authors": [
        "Michael Beeson", 
        "Robert Veroff", 
        "Larry Wos"
    ], 
    "lead_author": "Michael Beeson", 
    "arxiv-id": "cs/0301026v1", 
    "title": "Double-Negation Elimination in Some Propositional Logics", 
    "publish": "2003-01-24T20:25:50Z", 
    "summary": "This article answers two questions (posed in the literature), each concerning\nthe guaranteed existence of proofs free of double negation. A proof is free of\ndouble negation if none of its deduced steps contains a term of the form\nn(n(t)) for some term t, where n denotes negation. The first question asks for\nconditions on the hypotheses that, if satisfied, guarantee the existence of a\ndouble-negation-free proof when the conclusion is free of double negation. The\nsecond question asks about the existence of an axiom system for classical\npropositional calculus whose use, for theorems with a conclusion free of double\nnegation, guarantees the existence of a double-negation-free proof. After\ngiving conditions that answer the first question, we answer the second question\nby focusing on the Lukasiewicz three-axiom system. We then extend our studies\nto infinite-valued sentential calculus and to intuitionistic logic and\ngeneralize the notion of being double-negation free. The double-negation proofs\nof interest rely exclusively on the inference rule condensed detachment, a rule\nthat combines modus ponens with an appropriately general rule of substitution.\nThe automated reasoning program OTTER played an indispensable role in this\nstudy."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0301026v1", 
    "other_authors": [
        "Michael Beeson", 
        "Robert Veroff", 
        "Larry Wos"
    ], 
    "lead_author": "Michael Beeson", 
    "arxiv-id": "cs/0301026v1", 
    "title": "Double-Negation Elimination in Some Propositional Logics", 
    "publish": "2003-01-24T20:25:50Z", 
    "summary": "This article answers two questions (posed in the literature), each concerning\nthe guaranteed existence of proofs free of double negation. A proof is free of\ndouble negation if none of its deduced steps contains a term of the form\nn(n(t)) for some term t, where n denotes negation. The first question asks for\nconditions on the hypotheses that, if satisfied, guarantee the existence of a\ndouble-negation-free proof when the conclusion is free of double negation. The\nsecond question asks about the existence of an axiom system for classical\npropositional calculus whose use, for theorems with a conclusion free of double\nnegation, guarantees the existence of a double-negation-free proof. After\ngiving conditions that answer the first question, we answer the second question\nby focusing on the Lukasiewicz three-axiom system. We then extend our studies\nto infinite-valued sentential calculus and to intuitionistic logic and\ngeneralize the notion of being double-negation free. The double-negation proofs\nof interest rely exclusively on the inference rule condensed detachment, a rule\nthat combines modus ponens with an appropriately general rule of substitution.\nThe automated reasoning program OTTER played an indispensable role in this\nstudy."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0301026v1", 
    "other_authors": [
        "Michael Beeson", 
        "Robert Veroff", 
        "Larry Wos"
    ], 
    "lead_author": "Michael Beeson", 
    "arxiv-id": "cs/0301026v1", 
    "title": "Double-Negation Elimination in Some Propositional Logics", 
    "publish": "2003-01-24T20:25:50Z", 
    "summary": "This article answers two questions (posed in the literature), each concerning\nthe guaranteed existence of proofs free of double negation. A proof is free of\ndouble negation if none of its deduced steps contains a term of the form\nn(n(t)) for some term t, where n denotes negation. The first question asks for\nconditions on the hypotheses that, if satisfied, guarantee the existence of a\ndouble-negation-free proof when the conclusion is free of double negation. The\nsecond question asks about the existence of an axiom system for classical\npropositional calculus whose use, for theorems with a conclusion free of double\nnegation, guarantees the existence of a double-negation-free proof. After\ngiving conditions that answer the first question, we answer the second question\nby focusing on the Lukasiewicz three-axiom system. We then extend our studies\nto infinite-valued sentential calculus and to intuitionistic logic and\ngeneralize the notion of being double-negation free. The double-negation proofs\nof interest rely exclusively on the inference rule condensed detachment, a rule\nthat combines modus ponens with an appropriately general rule of substitution.\nThe automated reasoning program OTTER played an indispensable role in this\nstudy."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0301026v1", 
    "other_authors": [
        "Michael Beeson", 
        "Robert Veroff", 
        "Larry Wos"
    ], 
    "lead_author": "Michael Beeson", 
    "arxiv-id": "cs/0301026v1", 
    "title": "Double-Negation Elimination in Some Propositional Logics", 
    "publish": "2003-01-24T20:25:50Z", 
    "summary": "This article answers two questions (posed in the literature), each concerning\nthe guaranteed existence of proofs free of double negation. A proof is free of\ndouble negation if none of its deduced steps contains a term of the form\nn(n(t)) for some term t, where n denotes negation. The first question asks for\nconditions on the hypotheses that, if satisfied, guarantee the existence of a\ndouble-negation-free proof when the conclusion is free of double negation. The\nsecond question asks about the existence of an axiom system for classical\npropositional calculus whose use, for theorems with a conclusion free of double\nnegation, guarantees the existence of a double-negation-free proof. After\ngiving conditions that answer the first question, we answer the second question\nby focusing on the Lukasiewicz three-axiom system. We then extend our studies\nto infinite-valued sentential calculus and to intuitionistic logic and\ngeneralize the notion of being double-negation free. The double-negation proofs\nof interest rely exclusively on the inference rule condensed detachment, a rule\nthat combines modus ponens with an appropriately general rule of substitution.\nThe automated reasoning program OTTER played an indispensable role in this\nstudy."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0301026v1", 
    "other_authors": [
        "Michael Beeson", 
        "Robert Veroff", 
        "Larry Wos"
    ], 
    "lead_author": "Michael Beeson", 
    "arxiv-id": "cs/0301026v1", 
    "title": "Double-Negation Elimination in Some Propositional Logics", 
    "publish": "2003-01-24T20:25:50Z", 
    "summary": "This article answers two questions (posed in the literature), each concerning\nthe guaranteed existence of proofs free of double negation. A proof is free of\ndouble negation if none of its deduced steps contains a term of the form\nn(n(t)) for some term t, where n denotes negation. The first question asks for\nconditions on the hypotheses that, if satisfied, guarantee the existence of a\ndouble-negation-free proof when the conclusion is free of double negation. The\nsecond question asks about the existence of an axiom system for classical\npropositional calculus whose use, for theorems with a conclusion free of double\nnegation, guarantees the existence of a double-negation-free proof. After\ngiving conditions that answer the first question, we answer the second question\nby focusing on the Lukasiewicz three-axiom system. We then extend our studies\nto infinite-valued sentential calculus and to intuitionistic logic and\ngeneralize the notion of being double-negation free. The double-negation proofs\nof interest rely exclusively on the inference rule condensed detachment, a rule\nthat combines modus ponens with an appropriately general rule of substitution.\nThe automated reasoning program OTTER played an indispensable role in this\nstudy."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0301026v1", 
    "other_authors": [
        "Michael Beeson", 
        "Robert Veroff", 
        "Larry Wos"
    ], 
    "lead_author": "Michael Beeson", 
    "arxiv-id": "cs/0301026v1", 
    "title": "Double-Negation Elimination in Some Propositional Logics", 
    "publish": "2003-01-24T20:25:50Z", 
    "summary": "This article answers two questions (posed in the literature), each concerning\nthe guaranteed existence of proofs free of double negation. A proof is free of\ndouble negation if none of its deduced steps contains a term of the form\nn(n(t)) for some term t, where n denotes negation. The first question asks for\nconditions on the hypotheses that, if satisfied, guarantee the existence of a\ndouble-negation-free proof when the conclusion is free of double negation. The\nsecond question asks about the existence of an axiom system for classical\npropositional calculus whose use, for theorems with a conclusion free of double\nnegation, guarantees the existence of a double-negation-free proof. After\ngiving conditions that answer the first question, we answer the second question\nby focusing on the Lukasiewicz three-axiom system. We then extend our studies\nto infinite-valued sentential calculus and to intuitionistic logic and\ngeneralize the notion of being double-negation free. The double-negation proofs\nof interest rely exclusively on the inference rule condensed detachment, a rule\nthat combines modus ponens with an appropriately general rule of substitution.\nThe automated reasoning program OTTER played an indispensable role in this\nstudy."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0301026v1", 
    "other_authors": [
        "Michael Beeson", 
        "Robert Veroff", 
        "Larry Wos"
    ], 
    "lead_author": "Michael Beeson", 
    "arxiv-id": "cs/0301026v1", 
    "title": "Double-Negation Elimination in Some Propositional Logics", 
    "publish": "2003-01-24T20:25:50Z", 
    "summary": "This article answers two questions (posed in the literature), each concerning\nthe guaranteed existence of proofs free of double negation. A proof is free of\ndouble negation if none of its deduced steps contains a term of the form\nn(n(t)) for some term t, where n denotes negation. The first question asks for\nconditions on the hypotheses that, if satisfied, guarantee the existence of a\ndouble-negation-free proof when the conclusion is free of double negation. The\nsecond question asks about the existence of an axiom system for classical\npropositional calculus whose use, for theorems with a conclusion free of double\nnegation, guarantees the existence of a double-negation-free proof. After\ngiving conditions that answer the first question, we answer the second question\nby focusing on the Lukasiewicz three-axiom system. We then extend our studies\nto infinite-valued sentential calculus and to intuitionistic logic and\ngeneralize the notion of being double-negation free. The double-negation proofs\nof interest rely exclusively on the inference rule condensed detachment, a rule\nthat combines modus ponens with an appropriately general rule of substitution.\nThe automated reasoning program OTTER played an indispensable role in this\nstudy."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0301026v1", 
    "other_authors": [
        "Michael Beeson", 
        "Robert Veroff", 
        "Larry Wos"
    ], 
    "lead_author": "Michael Beeson", 
    "arxiv-id": "cs/0301026v1", 
    "title": "Double-Negation Elimination in Some Propositional Logics", 
    "publish": "2003-01-24T20:25:50Z", 
    "summary": "This article answers two questions (posed in the literature), each concerning\nthe guaranteed existence of proofs free of double negation. A proof is free of\ndouble negation if none of its deduced steps contains a term of the form\nn(n(t)) for some term t, where n denotes negation. The first question asks for\nconditions on the hypotheses that, if satisfied, guarantee the existence of a\ndouble-negation-free proof when the conclusion is free of double negation. The\nsecond question asks about the existence of an axiom system for classical\npropositional calculus whose use, for theorems with a conclusion free of double\nnegation, guarantees the existence of a double-negation-free proof. After\ngiving conditions that answer the first question, we answer the second question\nby focusing on the Lukasiewicz three-axiom system. We then extend our studies\nto infinite-valued sentential calculus and to intuitionistic logic and\ngeneralize the notion of being double-negation free. The double-negation proofs\nof interest rely exclusively on the inference rule condensed detachment, a rule\nthat combines modus ponens with an appropriately general rule of substitution.\nThe automated reasoning program OTTER played an indispensable role in this\nstudy."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0301026v1", 
    "other_authors": [
        "Michael Beeson", 
        "Robert Veroff", 
        "Larry Wos"
    ], 
    "lead_author": "Robert Veroff", 
    "arxiv-id": "cs/0301026v1", 
    "title": "Double-Negation Elimination in Some Propositional Logics", 
    "publish": "2003-01-24T20:25:50Z", 
    "summary": "This article answers two questions (posed in the literature), each concerning\nthe guaranteed existence of proofs free of double negation. A proof is free of\ndouble negation if none of its deduced steps contains a term of the form\nn(n(t)) for some term t, where n denotes negation. The first question asks for\nconditions on the hypotheses that, if satisfied, guarantee the existence of a\ndouble-negation-free proof when the conclusion is free of double negation. The\nsecond question asks about the existence of an axiom system for classical\npropositional calculus whose use, for theorems with a conclusion free of double\nnegation, guarantees the existence of a double-negation-free proof. After\ngiving conditions that answer the first question, we answer the second question\nby focusing on the Lukasiewicz three-axiom system. We then extend our studies\nto infinite-valued sentential calculus and to intuitionistic logic and\ngeneralize the notion of being double-negation free. The double-negation proofs\nof interest rely exclusively on the inference rule condensed detachment, a rule\nthat combines modus ponens with an appropriately general rule of substitution.\nThe automated reasoning program OTTER played an indispensable role in this\nstudy."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0301026v1", 
    "other_authors": [
        "Michael Beeson", 
        "Robert Veroff", 
        "Larry Wos"
    ], 
    "lead_author": "Robert Veroff", 
    "arxiv-id": "cs/0301026v1", 
    "title": "Double-Negation Elimination in Some Propositional Logics", 
    "publish": "2003-01-24T20:25:50Z", 
    "summary": "This article answers two questions (posed in the literature), each concerning\nthe guaranteed existence of proofs free of double negation. A proof is free of\ndouble negation if none of its deduced steps contains a term of the form\nn(n(t)) for some term t, where n denotes negation. The first question asks for\nconditions on the hypotheses that, if satisfied, guarantee the existence of a\ndouble-negation-free proof when the conclusion is free of double negation. The\nsecond question asks about the existence of an axiom system for classical\npropositional calculus whose use, for theorems with a conclusion free of double\nnegation, guarantees the existence of a double-negation-free proof. After\ngiving conditions that answer the first question, we answer the second question\nby focusing on the Lukasiewicz three-axiom system. We then extend our studies\nto infinite-valued sentential calculus and to intuitionistic logic and\ngeneralize the notion of being double-negation free. The double-negation proofs\nof interest rely exclusively on the inference rule condensed detachment, a rule\nthat combines modus ponens with an appropriately general rule of substitution.\nThe automated reasoning program OTTER played an indispensable role in this\nstudy."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0301026v1", 
    "other_authors": [
        "Michael Beeson", 
        "Robert Veroff", 
        "Larry Wos"
    ], 
    "lead_author": "Robert Veroff", 
    "arxiv-id": "cs/0301026v1", 
    "title": "Double-Negation Elimination in Some Propositional Logics", 
    "publish": "2003-01-24T20:25:50Z", 
    "summary": "This article answers two questions (posed in the literature), each concerning\nthe guaranteed existence of proofs free of double negation. A proof is free of\ndouble negation if none of its deduced steps contains a term of the form\nn(n(t)) for some term t, where n denotes negation. The first question asks for\nconditions on the hypotheses that, if satisfied, guarantee the existence of a\ndouble-negation-free proof when the conclusion is free of double negation. The\nsecond question asks about the existence of an axiom system for classical\npropositional calculus whose use, for theorems with a conclusion free of double\nnegation, guarantees the existence of a double-negation-free proof. After\ngiving conditions that answer the first question, we answer the second question\nby focusing on the Lukasiewicz three-axiom system. We then extend our studies\nto infinite-valued sentential calculus and to intuitionistic logic and\ngeneralize the notion of being double-negation free. The double-negation proofs\nof interest rely exclusively on the inference rule condensed detachment, a rule\nthat combines modus ponens with an appropriately general rule of substitution.\nThe automated reasoning program OTTER played an indispensable role in this\nstudy."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0301026v1", 
    "other_authors": [
        "Michael Beeson", 
        "Robert Veroff", 
        "Larry Wos"
    ], 
    "lead_author": "Larry Wos", 
    "arxiv-id": "cs/0301026v1", 
    "title": "Double-Negation Elimination in Some Propositional Logics", 
    "publish": "2003-01-24T20:25:50Z", 
    "summary": "This article answers two questions (posed in the literature), each concerning\nthe guaranteed existence of proofs free of double negation. A proof is free of\ndouble negation if none of its deduced steps contains a term of the form\nn(n(t)) for some term t, where n denotes negation. The first question asks for\nconditions on the hypotheses that, if satisfied, guarantee the existence of a\ndouble-negation-free proof when the conclusion is free of double negation. The\nsecond question asks about the existence of an axiom system for classical\npropositional calculus whose use, for theorems with a conclusion free of double\nnegation, guarantees the existence of a double-negation-free proof. After\ngiving conditions that answer the first question, we answer the second question\nby focusing on the Lukasiewicz three-axiom system. We then extend our studies\nto infinite-valued sentential calculus and to intuitionistic logic and\ngeneralize the notion of being double-negation free. The double-negation proofs\nof interest rely exclusively on the inference rule condensed detachment, a rule\nthat combines modus ponens with an appropriately general rule of substitution.\nThe automated reasoning program OTTER played an indispensable role in this\nstudy."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0301026v1", 
    "other_authors": [
        "Michael Beeson", 
        "Robert Veroff", 
        "Larry Wos"
    ], 
    "lead_author": "Larry Wos", 
    "arxiv-id": "cs/0301026v1", 
    "title": "Double-Negation Elimination in Some Propositional Logics", 
    "publish": "2003-01-24T20:25:50Z", 
    "summary": "This article answers two questions (posed in the literature), each concerning\nthe guaranteed existence of proofs free of double negation. A proof is free of\ndouble negation if none of its deduced steps contains a term of the form\nn(n(t)) for some term t, where n denotes negation. The first question asks for\nconditions on the hypotheses that, if satisfied, guarantee the existence of a\ndouble-negation-free proof when the conclusion is free of double negation. The\nsecond question asks about the existence of an axiom system for classical\npropositional calculus whose use, for theorems with a conclusion free of double\nnegation, guarantees the existence of a double-negation-free proof. After\ngiving conditions that answer the first question, we answer the second question\nby focusing on the Lukasiewicz three-axiom system. We then extend our studies\nto infinite-valued sentential calculus and to intuitionistic logic and\ngeneralize the notion of being double-negation free. The double-negation proofs\nof interest rely exclusively on the inference rule condensed detachment, a rule\nthat combines modus ponens with an appropriately general rule of substitution.\nThe automated reasoning program OTTER played an indispensable role in this\nstudy."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0301026v1", 
    "other_authors": [
        "Michael Beeson", 
        "Robert Veroff", 
        "Larry Wos"
    ], 
    "lead_author": "Larry Wos", 
    "arxiv-id": "cs/0301026v1", 
    "title": "Double-Negation Elimination in Some Propositional Logics", 
    "publish": "2003-01-24T20:25:50Z", 
    "summary": "This article answers two questions (posed in the literature), each concerning\nthe guaranteed existence of proofs free of double negation. A proof is free of\ndouble negation if none of its deduced steps contains a term of the form\nn(n(t)) for some term t, where n denotes negation. The first question asks for\nconditions on the hypotheses that, if satisfied, guarantee the existence of a\ndouble-negation-free proof when the conclusion is free of double negation. The\nsecond question asks about the existence of an axiom system for classical\npropositional calculus whose use, for theorems with a conclusion free of double\nnegation, guarantees the existence of a double-negation-free proof. After\ngiving conditions that answer the first question, we answer the second question\nby focusing on the Lukasiewicz three-axiom system. We then extend our studies\nto infinite-valued sentential calculus and to intuitionistic logic and\ngeneralize the notion of being double-negation free. The double-negation proofs\nof interest rely exclusively on the inference rule condensed detachment, a rule\nthat combines modus ponens with an appropriately general rule of substitution.\nThe automated reasoning program OTTER played an indispensable role in this\nstudy."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0301026v1", 
    "other_authors": [
        "Michael Beeson", 
        "Robert Veroff", 
        "Larry Wos"
    ], 
    "lead_author": "Larry Wos", 
    "arxiv-id": "cs/0301026v1", 
    "title": "Double-Negation Elimination in Some Propositional Logics", 
    "publish": "2003-01-24T20:25:50Z", 
    "summary": "This article answers two questions (posed in the literature), each concerning\nthe guaranteed existence of proofs free of double negation. A proof is free of\ndouble negation if none of its deduced steps contains a term of the form\nn(n(t)) for some term t, where n denotes negation. The first question asks for\nconditions on the hypotheses that, if satisfied, guarantee the existence of a\ndouble-negation-free proof when the conclusion is free of double negation. The\nsecond question asks about the existence of an axiom system for classical\npropositional calculus whose use, for theorems with a conclusion free of double\nnegation, guarantees the existence of a double-negation-free proof. After\ngiving conditions that answer the first question, we answer the second question\nby focusing on the Lukasiewicz three-axiom system. We then extend our studies\nto infinite-valued sentential calculus and to intuitionistic logic and\ngeneralize the notion of being double-negation free. The double-negation proofs\nof interest rely exclusively on the inference rule condensed detachment, a rule\nthat combines modus ponens with an appropriately general rule of substitution.\nThe automated reasoning program OTTER played an indispensable role in this\nstudy."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0301026v1", 
    "other_authors": [
        "Michael Beeson", 
        "Robert Veroff", 
        "Larry Wos"
    ], 
    "lead_author": "Larry Wos", 
    "arxiv-id": "cs/0301026v1", 
    "title": "Double-Negation Elimination in Some Propositional Logics", 
    "publish": "2003-01-24T20:25:50Z", 
    "summary": "This article answers two questions (posed in the literature), each concerning\nthe guaranteed existence of proofs free of double negation. A proof is free of\ndouble negation if none of its deduced steps contains a term of the form\nn(n(t)) for some term t, where n denotes negation. The first question asks for\nconditions on the hypotheses that, if satisfied, guarantee the existence of a\ndouble-negation-free proof when the conclusion is free of double negation. The\nsecond question asks about the existence of an axiom system for classical\npropositional calculus whose use, for theorems with a conclusion free of double\nnegation, guarantees the existence of a double-negation-free proof. After\ngiving conditions that answer the first question, we answer the second question\nby focusing on the Lukasiewicz three-axiom system. We then extend our studies\nto infinite-valued sentential calculus and to intuitionistic logic and\ngeneralize the notion of being double-negation free. The double-negation proofs\nof interest rely exclusively on the inference rule condensed detachment, a rule\nthat combines modus ponens with an appropriately general rule of substitution.\nThe automated reasoning program OTTER played an indispensable role in this\nstudy."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0303019v1", 
    "other_authors": [
        "Bernard Boigelot", 
        "Sebastien Jodogne", 
        "Pierre Wolper"
    ], 
    "lead_author": "Bernard Boigelot", 
    "arxiv-id": "cs/0303019v1", 
    "title": "An Effective Decision Procedure for Linear Arithmetic with Integer and   Real Variables", 
    "publish": "2003-03-20T17:05:24Z", 
    "summary": "This paper considers finite-automata based algorithms for handling linear\narithmetic with both real and integer variables. Previous work has shown that\nthis theory can be dealt with by using finite automata on infinite words, but\nthis involves some difficult and delicate to implement algorithms. The\ncontribution of this paper is to show, using topological arguments, that only a\nrestricted class of automata on infinite words are necessary for handling real\nand integer linear arithmetic. This allows the use of substantially simpler\nalgorithms, which have been successfully implemented."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0303019v1", 
    "other_authors": [
        "Bernard Boigelot", 
        "Sebastien Jodogne", 
        "Pierre Wolper"
    ], 
    "lead_author": "Bernard Boigelot", 
    "arxiv-id": "cs/0303019v1", 
    "title": "An Effective Decision Procedure for Linear Arithmetic with Integer and   Real Variables", 
    "publish": "2003-03-20T17:05:24Z", 
    "summary": "This paper considers finite-automata based algorithms for handling linear\narithmetic with both real and integer variables. Previous work has shown that\nthis theory can be dealt with by using finite automata on infinite words, but\nthis involves some difficult and delicate to implement algorithms. The\ncontribution of this paper is to show, using topological arguments, that only a\nrestricted class of automata on infinite words are necessary for handling real\nand integer linear arithmetic. This allows the use of substantially simpler\nalgorithms, which have been successfully implemented."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0303019v1", 
    "other_authors": [
        "Bernard Boigelot", 
        "Sebastien Jodogne", 
        "Pierre Wolper"
    ], 
    "lead_author": "Bernard Boigelot", 
    "arxiv-id": "cs/0303019v1", 
    "title": "An Effective Decision Procedure for Linear Arithmetic with Integer and   Real Variables", 
    "publish": "2003-03-20T17:05:24Z", 
    "summary": "This paper considers finite-automata based algorithms for handling linear\narithmetic with both real and integer variables. Previous work has shown that\nthis theory can be dealt with by using finite automata on infinite words, but\nthis involves some difficult and delicate to implement algorithms. The\ncontribution of this paper is to show, using topological arguments, that only a\nrestricted class of automata on infinite words are necessary for handling real\nand integer linear arithmetic. This allows the use of substantially simpler\nalgorithms, which have been successfully implemented."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0303019v1", 
    "other_authors": [
        "Bernard Boigelot", 
        "Sebastien Jodogne", 
        "Pierre Wolper"
    ], 
    "lead_author": "Bernard Boigelot", 
    "arxiv-id": "cs/0303019v1", 
    "title": "An Effective Decision Procedure for Linear Arithmetic with Integer and   Real Variables", 
    "publish": "2003-03-20T17:05:24Z", 
    "summary": "This paper considers finite-automata based algorithms for handling linear\narithmetic with both real and integer variables. Previous work has shown that\nthis theory can be dealt with by using finite automata on infinite words, but\nthis involves some difficult and delicate to implement algorithms. The\ncontribution of this paper is to show, using topological arguments, that only a\nrestricted class of automata on infinite words are necessary for handling real\nand integer linear arithmetic. This allows the use of substantially simpler\nalgorithms, which have been successfully implemented."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0303019v1", 
    "other_authors": [
        "Bernard Boigelot", 
        "Sebastien Jodogne", 
        "Pierre Wolper"
    ], 
    "lead_author": "Bernard Boigelot", 
    "arxiv-id": "cs/0303019v1", 
    "title": "An Effective Decision Procedure for Linear Arithmetic with Integer and   Real Variables", 
    "publish": "2003-03-20T17:05:24Z", 
    "summary": "This paper considers finite-automata based algorithms for handling linear\narithmetic with both real and integer variables. Previous work has shown that\nthis theory can be dealt with by using finite automata on infinite words, but\nthis involves some difficult and delicate to implement algorithms. The\ncontribution of this paper is to show, using topological arguments, that only a\nrestricted class of automata on infinite words are necessary for handling real\nand integer linear arithmetic. This allows the use of substantially simpler\nalgorithms, which have been successfully implemented."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0303019v1", 
    "other_authors": [
        "Bernard Boigelot", 
        "Sebastien Jodogne", 
        "Pierre Wolper"
    ], 
    "lead_author": "Bernard Boigelot", 
    "arxiv-id": "cs/0303019v1", 
    "title": "An Effective Decision Procedure for Linear Arithmetic with Integer and   Real Variables", 
    "publish": "2003-03-20T17:05:24Z", 
    "summary": "This paper considers finite-automata based algorithms for handling linear\narithmetic with both real and integer variables. Previous work has shown that\nthis theory can be dealt with by using finite automata on infinite words, but\nthis involves some difficult and delicate to implement algorithms. The\ncontribution of this paper is to show, using topological arguments, that only a\nrestricted class of automata on infinite words are necessary for handling real\nand integer linear arithmetic. This allows the use of substantially simpler\nalgorithms, which have been successfully implemented."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0303019v1", 
    "other_authors": [
        "Bernard Boigelot", 
        "Sebastien Jodogne", 
        "Pierre Wolper"
    ], 
    "lead_author": "Bernard Boigelot", 
    "arxiv-id": "cs/0303019v1", 
    "title": "An Effective Decision Procedure for Linear Arithmetic with Integer and   Real Variables", 
    "publish": "2003-03-20T17:05:24Z", 
    "summary": "This paper considers finite-automata based algorithms for handling linear\narithmetic with both real and integer variables. Previous work has shown that\nthis theory can be dealt with by using finite automata on infinite words, but\nthis involves some difficult and delicate to implement algorithms. The\ncontribution of this paper is to show, using topological arguments, that only a\nrestricted class of automata on infinite words are necessary for handling real\nand integer linear arithmetic. This allows the use of substantially simpler\nalgorithms, which have been successfully implemented."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0303019v1", 
    "other_authors": [
        "Bernard Boigelot", 
        "Sebastien Jodogne", 
        "Pierre Wolper"
    ], 
    "lead_author": "Sebastien Jodogne", 
    "arxiv-id": "cs/0303019v1", 
    "title": "An Effective Decision Procedure for Linear Arithmetic with Integer and   Real Variables", 
    "publish": "2003-03-20T17:05:24Z", 
    "summary": "This paper considers finite-automata based algorithms for handling linear\narithmetic with both real and integer variables. Previous work has shown that\nthis theory can be dealt with by using finite automata on infinite words, but\nthis involves some difficult and delicate to implement algorithms. The\ncontribution of this paper is to show, using topological arguments, that only a\nrestricted class of automata on infinite words are necessary for handling real\nand integer linear arithmetic. This allows the use of substantially simpler\nalgorithms, which have been successfully implemented."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0303019v1", 
    "other_authors": [
        "Bernard Boigelot", 
        "Sebastien Jodogne", 
        "Pierre Wolper"
    ], 
    "lead_author": "Sebastien Jodogne", 
    "arxiv-id": "cs/0303019v1", 
    "title": "An Effective Decision Procedure for Linear Arithmetic with Integer and   Real Variables", 
    "publish": "2003-03-20T17:05:24Z", 
    "summary": "This paper considers finite-automata based algorithms for handling linear\narithmetic with both real and integer variables. Previous work has shown that\nthis theory can be dealt with by using finite automata on infinite words, but\nthis involves some difficult and delicate to implement algorithms. The\ncontribution of this paper is to show, using topological arguments, that only a\nrestricted class of automata on infinite words are necessary for handling real\nand integer linear arithmetic. This allows the use of substantially simpler\nalgorithms, which have been successfully implemented."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0303019v1", 
    "other_authors": [
        "Bernard Boigelot", 
        "Sebastien Jodogne", 
        "Pierre Wolper"
    ], 
    "lead_author": "Pierre Wolper", 
    "arxiv-id": "cs/0303019v1", 
    "title": "An Effective Decision Procedure for Linear Arithmetic with Integer and   Real Variables", 
    "publish": "2003-03-20T17:05:24Z", 
    "summary": "This paper considers finite-automata based algorithms for handling linear\narithmetic with both real and integer variables. Previous work has shown that\nthis theory can be dealt with by using finite automata on infinite words, but\nthis involves some difficult and delicate to implement algorithms. The\ncontribution of this paper is to show, using topological arguments, that only a\nrestricted class of automata on infinite words are necessary for handling real\nand integer linear arithmetic. This allows the use of substantially simpler\nalgorithms, which have been successfully implemented."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0303019v1", 
    "other_authors": [
        "Bernard Boigelot", 
        "Sebastien Jodogne", 
        "Pierre Wolper"
    ], 
    "lead_author": "Pierre Wolper", 
    "arxiv-id": "cs/0303019v1", 
    "title": "An Effective Decision Procedure for Linear Arithmetic with Integer and   Real Variables", 
    "publish": "2003-03-20T17:05:24Z", 
    "summary": "This paper considers finite-automata based algorithms for handling linear\narithmetic with both real and integer variables. Previous work has shown that\nthis theory can be dealt with by using finite automata on infinite words, but\nthis involves some difficult and delicate to implement algorithms. The\ncontribution of this paper is to show, using topological arguments, that only a\nrestricted class of automata on infinite words are necessary for handling real\nand integer linear arithmetic. This allows the use of substantially simpler\nalgorithms, which have been successfully implemented."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0303019v1", 
    "other_authors": [
        "Bernard Boigelot", 
        "Sebastien Jodogne", 
        "Pierre Wolper"
    ], 
    "lead_author": "Pierre Wolper", 
    "arxiv-id": "cs/0303019v1", 
    "title": "An Effective Decision Procedure for Linear Arithmetic with Integer and   Real Variables", 
    "publish": "2003-03-20T17:05:24Z", 
    "summary": "This paper considers finite-automata based algorithms for handling linear\narithmetic with both real and integer variables. Previous work has shown that\nthis theory can be dealt with by using finite automata on infinite words, but\nthis involves some difficult and delicate to implement algorithms. The\ncontribution of this paper is to show, using topological arguments, that only a\nrestricted class of automata on infinite words are necessary for handling real\nand integer linear arithmetic. This allows the use of substantially simpler\nalgorithms, which have been successfully implemented."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0303019v1", 
    "other_authors": [
        "Bernard Boigelot", 
        "Sebastien Jodogne", 
        "Pierre Wolper"
    ], 
    "lead_author": "Pierre Wolper", 
    "arxiv-id": "cs/0303019v1", 
    "title": "An Effective Decision Procedure for Linear Arithmetic with Integer and   Real Variables", 
    "publish": "2003-03-20T17:05:24Z", 
    "summary": "This paper considers finite-automata based algorithms for handling linear\narithmetic with both real and integer variables. Previous work has shown that\nthis theory can be dealt with by using finite automata on infinite words, but\nthis involves some difficult and delicate to implement algorithms. The\ncontribution of this paper is to show, using topological arguments, that only a\nrestricted class of automata on infinite words are necessary for handling real\nand integer linear arithmetic. This allows the use of substantially simpler\nalgorithms, which have been successfully implemented."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304017v1", 
    "other_authors": [
        "Nachum Dershowitz"
    ], 
    "lead_author": "Nachum Dershowitz", 
    "arxiv-id": "cs/0304017v1", 
    "title": "Ground Canonicity", 
    "publish": "2003-04-10T20:08:18Z", 
    "summary": "We explore how different proof orderings induce different notions of\nsaturation. We relate completion, paramodulation, saturation, redundancy\nelimination, and rewrite system reduction to proof orderings."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304017v1", 
    "other_authors": [
        "Nachum Dershowitz"
    ], 
    "lead_author": "Nachum Dershowitz", 
    "arxiv-id": "cs/0304017v1", 
    "title": "Ground Canonicity", 
    "publish": "2003-04-10T20:08:18Z", 
    "summary": "We explore how different proof orderings induce different notions of\nsaturation. We relate completion, paramodulation, saturation, redundancy\nelimination, and rewrite system reduction to proof orderings."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304017v1", 
    "other_authors": [
        "Nachum Dershowitz"
    ], 
    "lead_author": "Nachum Dershowitz", 
    "arxiv-id": "cs/0304017v1", 
    "title": "Ground Canonicity", 
    "publish": "2003-04-10T20:08:18Z", 
    "summary": "We explore how different proof orderings induce different notions of\nsaturation. We relate completion, paramodulation, saturation, redundancy\nelimination, and rewrite system reduction to proof orderings."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304017v1", 
    "other_authors": [
        "Nachum Dershowitz"
    ], 
    "lead_author": "Nachum Dershowitz", 
    "arxiv-id": "cs/0304017v1", 
    "title": "Ground Canonicity", 
    "publish": "2003-04-10T20:08:18Z", 
    "summary": "We explore how different proof orderings induce different notions of\nsaturation. We relate completion, paramodulation, saturation, redundancy\nelimination, and rewrite system reduction to proof orderings."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304017v1", 
    "other_authors": [
        "Nachum Dershowitz"
    ], 
    "lead_author": "Nachum Dershowitz", 
    "arxiv-id": "cs/0304017v1", 
    "title": "Ground Canonicity", 
    "publish": "2003-04-10T20:08:18Z", 
    "summary": "We explore how different proof orderings induce different notions of\nsaturation. We relate completion, paramodulation, saturation, redundancy\nelimination, and rewrite system reduction to proof orderings."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304017v1", 
    "other_authors": [
        "Nachum Dershowitz"
    ], 
    "lead_author": "Nachum Dershowitz", 
    "arxiv-id": "cs/0304017v1", 
    "title": "Ground Canonicity", 
    "publish": "2003-04-10T20:08:18Z", 
    "summary": "We explore how different proof orderings induce different notions of\nsaturation. We relate completion, paramodulation, saturation, redundancy\nelimination, and rewrite system reduction to proof orderings."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304017v1", 
    "other_authors": [
        "Nachum Dershowitz"
    ], 
    "lead_author": "Nachum Dershowitz", 
    "arxiv-id": "cs/0304017v1", 
    "title": "Ground Canonicity", 
    "publish": "2003-04-10T20:08:18Z", 
    "summary": "We explore how different proof orderings induce different notions of\nsaturation. We relate completion, paramodulation, saturation, redundancy\nelimination, and rewrite system reduction to proof orderings."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304017v1", 
    "other_authors": [
        "Nachum Dershowitz"
    ], 
    "lead_author": "Nachum Dershowitz", 
    "arxiv-id": "cs/0304017v1", 
    "title": "Ground Canonicity", 
    "publish": "2003-04-10T20:08:18Z", 
    "summary": "We explore how different proof orderings induce different notions of\nsaturation. We relate completion, paramodulation, saturation, redundancy\nelimination, and rewrite system reduction to proof orderings."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304017v1", 
    "other_authors": [
        "Nachum Dershowitz"
    ], 
    "lead_author": "Nachum Dershowitz", 
    "arxiv-id": "cs/0304017v1", 
    "title": "Ground Canonicity", 
    "publish": "2003-04-10T20:08:18Z", 
    "summary": "We explore how different proof orderings induce different notions of\nsaturation. We relate completion, paramodulation, saturation, redundancy\nelimination, and rewrite system reduction to proof orderings."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304017v1", 
    "other_authors": [
        "Nachum Dershowitz"
    ], 
    "lead_author": "Nachum Dershowitz", 
    "arxiv-id": "cs/0304017v1", 
    "title": "Ground Canonicity", 
    "publish": "2003-04-10T20:08:18Z", 
    "summary": "We explore how different proof orderings induce different notions of\nsaturation. We relate completion, paramodulation, saturation, redundancy\nelimination, and rewrite system reduction to proof orderings."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304017v1", 
    "other_authors": [
        "Nachum Dershowitz"
    ], 
    "lead_author": "Nachum Dershowitz", 
    "arxiv-id": "cs/0304017v1", 
    "title": "Ground Canonicity", 
    "publish": "2003-04-10T20:08:18Z", 
    "summary": "We explore how different proof orderings induce different notions of\nsaturation. We relate completion, paramodulation, saturation, redundancy\nelimination, and rewrite system reduction to proof orderings."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304017v1", 
    "other_authors": [
        "Nachum Dershowitz"
    ], 
    "lead_author": "Nachum Dershowitz", 
    "arxiv-id": "cs/0304017v1", 
    "title": "Ground Canonicity", 
    "publish": "2003-04-10T20:08:18Z", 
    "summary": "We explore how different proof orderings induce different notions of\nsaturation. We relate completion, paramodulation, saturation, redundancy\nelimination, and rewrite system reduction to proof orderings."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304017v1", 
    "other_authors": [
        "Nachum Dershowitz"
    ], 
    "lead_author": "Nachum Dershowitz", 
    "arxiv-id": "cs/0304017v1", 
    "title": "Ground Canonicity", 
    "publish": "2003-04-10T20:08:18Z", 
    "summary": "We explore how different proof orderings induce different notions of\nsaturation. We relate completion, paramodulation, saturation, redundancy\nelimination, and rewrite system reduction to proof orderings."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304017v1", 
    "other_authors": [
        "Nachum Dershowitz"
    ], 
    "lead_author": "Nachum Dershowitz", 
    "arxiv-id": "cs/0304017v1", 
    "title": "Ground Canonicity", 
    "publish": "2003-04-10T20:08:18Z", 
    "summary": "We explore how different proof orderings induce different notions of\nsaturation. We relate completion, paramodulation, saturation, redundancy\nelimination, and rewrite system reduction to proof orderings."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304017v1", 
    "other_authors": [
        "Nachum Dershowitz"
    ], 
    "lead_author": "Nachum Dershowitz", 
    "arxiv-id": "cs/0304017v1", 
    "title": "Ground Canonicity", 
    "publish": "2003-04-10T20:08:18Z", 
    "summary": "We explore how different proof orderings induce different notions of\nsaturation. We relate completion, paramodulation, saturation, redundancy\nelimination, and rewrite system reduction to proof orderings."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304017v1", 
    "other_authors": [
        "Nachum Dershowitz"
    ], 
    "lead_author": "Nachum Dershowitz", 
    "arxiv-id": "cs/0304017v1", 
    "title": "Ground Canonicity", 
    "publish": "2003-04-10T20:08:18Z", 
    "summary": "We explore how different proof orderings induce different notions of\nsaturation. We relate completion, paramodulation, saturation, redundancy\nelimination, and rewrite system reduction to proof orderings."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304017v1", 
    "other_authors": [
        "Nachum Dershowitz"
    ], 
    "lead_author": "Nachum Dershowitz", 
    "arxiv-id": "cs/0304017v1", 
    "title": "Ground Canonicity", 
    "publish": "2003-04-10T20:08:18Z", 
    "summary": "We explore how different proof orderings induce different notions of\nsaturation. We relate completion, paramodulation, saturation, redundancy\nelimination, and rewrite system reduction to proof orderings."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304017v1", 
    "other_authors": [
        "Nachum Dershowitz"
    ], 
    "lead_author": "Nachum Dershowitz", 
    "arxiv-id": "cs/0304017v1", 
    "title": "Ground Canonicity", 
    "publish": "2003-04-10T20:08:18Z", 
    "summary": "We explore how different proof orderings induce different notions of\nsaturation. We relate completion, paramodulation, saturation, redundancy\nelimination, and rewrite system reduction to proof orderings."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304017v1", 
    "other_authors": [
        "Nachum Dershowitz"
    ], 
    "lead_author": "Nachum Dershowitz", 
    "arxiv-id": "cs/0304017v1", 
    "title": "Ground Canonicity", 
    "publish": "2003-04-10T20:08:18Z", 
    "summary": "We explore how different proof orderings induce different notions of\nsaturation. We relate completion, paramodulation, saturation, redundancy\nelimination, and rewrite system reduction to proof orderings."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304017v1", 
    "other_authors": [
        "Nachum Dershowitz"
    ], 
    "lead_author": "Nachum Dershowitz", 
    "arxiv-id": "cs/0304017v1", 
    "title": "Ground Canonicity", 
    "publish": "2003-04-10T20:08:18Z", 
    "summary": "We explore how different proof orderings induce different notions of\nsaturation. We relate completion, paramodulation, saturation, redundancy\nelimination, and rewrite system reduction to proof orderings."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304021v1", 
    "other_authors": [
        "Peter Buchholz", 
        "Peter Kemper"
    ], 
    "lead_author": "Peter Buchholz", 
    "arxiv-id": "cs/0304021v1", 
    "title": "Model Checking for a Class of Weighted Automata", 
    "publish": "2003-04-15T19:08:00Z", 
    "summary": "A large number of different model checking approaches has been proposed\nduring the last decade. The different approaches are applicable to different\nmodel types including untimed, timed, probabilistic and stochastic models. This\npaper presents a new framework for model checking techniques which includes\nsome of the known approaches, but enlarges the class of models for which model\nchecking can be applied to the general class of weighted automata. The approach\nallows an easy adaption of model checking to models which have not been\nconsidered yet for this purpose. Examples for those new model types for which\nmodel checking can be applied are max/plus or min/plus automata which are well\nestablished models to describe different forms of dynamic systems and\noptimization problems. In this context, model checking can be used to verify\ntemporal or quantitative properties of a system. The paper first presents\nbriefly our class of weighted automata, as a very general model type. Then\nValued Computational Tree Logic (CTL$) is introduced as a natural extension of\nthe well known branching time logic CTL. Afterwards, algorithms to check a\nweighted automaton according to a CTL$ formula are presented. As a last result,\na bisimulation is presented for weighted automata and for CTL$."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304021v1", 
    "other_authors": [
        "Peter Buchholz", 
        "Peter Kemper"
    ], 
    "lead_author": "Peter Buchholz", 
    "arxiv-id": "cs/0304021v1", 
    "title": "Model Checking for a Class of Weighted Automata", 
    "publish": "2003-04-15T19:08:00Z", 
    "summary": "A large number of different model checking approaches has been proposed\nduring the last decade. The different approaches are applicable to different\nmodel types including untimed, timed, probabilistic and stochastic models. This\npaper presents a new framework for model checking techniques which includes\nsome of the known approaches, but enlarges the class of models for which model\nchecking can be applied to the general class of weighted automata. The approach\nallows an easy adaption of model checking to models which have not been\nconsidered yet for this purpose. Examples for those new model types for which\nmodel checking can be applied are max/plus or min/plus automata which are well\nestablished models to describe different forms of dynamic systems and\noptimization problems. In this context, model checking can be used to verify\ntemporal or quantitative properties of a system. The paper first presents\nbriefly our class of weighted automata, as a very general model type. Then\nValued Computational Tree Logic (CTL$) is introduced as a natural extension of\nthe well known branching time logic CTL. Afterwards, algorithms to check a\nweighted automaton according to a CTL$ formula are presented. As a last result,\na bisimulation is presented for weighted automata and for CTL$."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304021v1", 
    "other_authors": [
        "Peter Buchholz", 
        "Peter Kemper"
    ], 
    "lead_author": "Peter Buchholz", 
    "arxiv-id": "cs/0304021v1", 
    "title": "Model Checking for a Class of Weighted Automata", 
    "publish": "2003-04-15T19:08:00Z", 
    "summary": "A large number of different model checking approaches has been proposed\nduring the last decade. The different approaches are applicable to different\nmodel types including untimed, timed, probabilistic and stochastic models. This\npaper presents a new framework for model checking techniques which includes\nsome of the known approaches, but enlarges the class of models for which model\nchecking can be applied to the general class of weighted automata. The approach\nallows an easy adaption of model checking to models which have not been\nconsidered yet for this purpose. Examples for those new model types for which\nmodel checking can be applied are max/plus or min/plus automata which are well\nestablished models to describe different forms of dynamic systems and\noptimization problems. In this context, model checking can be used to verify\ntemporal or quantitative properties of a system. The paper first presents\nbriefly our class of weighted automata, as a very general model type. Then\nValued Computational Tree Logic (CTL$) is introduced as a natural extension of\nthe well known branching time logic CTL. Afterwards, algorithms to check a\nweighted automaton according to a CTL$ formula are presented. As a last result,\na bisimulation is presented for weighted automata and for CTL$."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304021v1", 
    "other_authors": [
        "Peter Buchholz", 
        "Peter Kemper"
    ], 
    "lead_author": "Peter Buchholz", 
    "arxiv-id": "cs/0304021v1", 
    "title": "Model Checking for a Class of Weighted Automata", 
    "publish": "2003-04-15T19:08:00Z", 
    "summary": "A large number of different model checking approaches has been proposed\nduring the last decade. The different approaches are applicable to different\nmodel types including untimed, timed, probabilistic and stochastic models. This\npaper presents a new framework for model checking techniques which includes\nsome of the known approaches, but enlarges the class of models for which model\nchecking can be applied to the general class of weighted automata. The approach\nallows an easy adaption of model checking to models which have not been\nconsidered yet for this purpose. Examples for those new model types for which\nmodel checking can be applied are max/plus or min/plus automata which are well\nestablished models to describe different forms of dynamic systems and\noptimization problems. In this context, model checking can be used to verify\ntemporal or quantitative properties of a system. The paper first presents\nbriefly our class of weighted automata, as a very general model type. Then\nValued Computational Tree Logic (CTL$) is introduced as a natural extension of\nthe well known branching time logic CTL. Afterwards, algorithms to check a\nweighted automaton according to a CTL$ formula are presented. As a last result,\na bisimulation is presented for weighted automata and for CTL$."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304021v1", 
    "other_authors": [
        "Peter Buchholz", 
        "Peter Kemper"
    ], 
    "lead_author": "Peter Buchholz", 
    "arxiv-id": "cs/0304021v1", 
    "title": "Model Checking for a Class of Weighted Automata", 
    "publish": "2003-04-15T19:08:00Z", 
    "summary": "A large number of different model checking approaches has been proposed\nduring the last decade. The different approaches are applicable to different\nmodel types including untimed, timed, probabilistic and stochastic models. This\npaper presents a new framework for model checking techniques which includes\nsome of the known approaches, but enlarges the class of models for which model\nchecking can be applied to the general class of weighted automata. The approach\nallows an easy adaption of model checking to models which have not been\nconsidered yet for this purpose. Examples for those new model types for which\nmodel checking can be applied are max/plus or min/plus automata which are well\nestablished models to describe different forms of dynamic systems and\noptimization problems. In this context, model checking can be used to verify\ntemporal or quantitative properties of a system. The paper first presents\nbriefly our class of weighted automata, as a very general model type. Then\nValued Computational Tree Logic (CTL$) is introduced as a natural extension of\nthe well known branching time logic CTL. Afterwards, algorithms to check a\nweighted automaton according to a CTL$ formula are presented. As a last result,\na bisimulation is presented for weighted automata and for CTL$."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304021v1", 
    "other_authors": [
        "Peter Buchholz", 
        "Peter Kemper"
    ], 
    "lead_author": "Peter Buchholz", 
    "arxiv-id": "cs/0304021v1", 
    "title": "Model Checking for a Class of Weighted Automata", 
    "publish": "2003-04-15T19:08:00Z", 
    "summary": "A large number of different model checking approaches has been proposed\nduring the last decade. The different approaches are applicable to different\nmodel types including untimed, timed, probabilistic and stochastic models. This\npaper presents a new framework for model checking techniques which includes\nsome of the known approaches, but enlarges the class of models for which model\nchecking can be applied to the general class of weighted automata. The approach\nallows an easy adaption of model checking to models which have not been\nconsidered yet for this purpose. Examples for those new model types for which\nmodel checking can be applied are max/plus or min/plus automata which are well\nestablished models to describe different forms of dynamic systems and\noptimization problems. In this context, model checking can be used to verify\ntemporal or quantitative properties of a system. The paper first presents\nbriefly our class of weighted automata, as a very general model type. Then\nValued Computational Tree Logic (CTL$) is introduced as a natural extension of\nthe well known branching time logic CTL. Afterwards, algorithms to check a\nweighted automaton according to a CTL$ formula are presented. As a last result,\na bisimulation is presented for weighted automata and for CTL$."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304021v1", 
    "other_authors": [
        "Peter Buchholz", 
        "Peter Kemper"
    ], 
    "lead_author": "Peter Buchholz", 
    "arxiv-id": "cs/0304021v1", 
    "title": "Model Checking for a Class of Weighted Automata", 
    "publish": "2003-04-15T19:08:00Z", 
    "summary": "A large number of different model checking approaches has been proposed\nduring the last decade. The different approaches are applicable to different\nmodel types including untimed, timed, probabilistic and stochastic models. This\npaper presents a new framework for model checking techniques which includes\nsome of the known approaches, but enlarges the class of models for which model\nchecking can be applied to the general class of weighted automata. The approach\nallows an easy adaption of model checking to models which have not been\nconsidered yet for this purpose. Examples for those new model types for which\nmodel checking can be applied are max/plus or min/plus automata which are well\nestablished models to describe different forms of dynamic systems and\noptimization problems. In this context, model checking can be used to verify\ntemporal or quantitative properties of a system. The paper first presents\nbriefly our class of weighted automata, as a very general model type. Then\nValued Computational Tree Logic (CTL$) is introduced as a natural extension of\nthe well known branching time logic CTL. Afterwards, algorithms to check a\nweighted automaton according to a CTL$ formula are presented. As a last result,\na bisimulation is presented for weighted automata and for CTL$."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304021v1", 
    "other_authors": [
        "Peter Buchholz", 
        "Peter Kemper"
    ], 
    "lead_author": "Peter Buchholz", 
    "arxiv-id": "cs/0304021v1", 
    "title": "Model Checking for a Class of Weighted Automata", 
    "publish": "2003-04-15T19:08:00Z", 
    "summary": "A large number of different model checking approaches has been proposed\nduring the last decade. The different approaches are applicable to different\nmodel types including untimed, timed, probabilistic and stochastic models. This\npaper presents a new framework for model checking techniques which includes\nsome of the known approaches, but enlarges the class of models for which model\nchecking can be applied to the general class of weighted automata. The approach\nallows an easy adaption of model checking to models which have not been\nconsidered yet for this purpose. Examples for those new model types for which\nmodel checking can be applied are max/plus or min/plus automata which are well\nestablished models to describe different forms of dynamic systems and\noptimization problems. In this context, model checking can be used to verify\ntemporal or quantitative properties of a system. The paper first presents\nbriefly our class of weighted automata, as a very general model type. Then\nValued Computational Tree Logic (CTL$) is introduced as a natural extension of\nthe well known branching time logic CTL. Afterwards, algorithms to check a\nweighted automaton according to a CTL$ formula are presented. As a last result,\na bisimulation is presented for weighted automata and for CTL$."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304021v1", 
    "other_authors": [
        "Peter Buchholz", 
        "Peter Kemper"
    ], 
    "lead_author": "Peter Buchholz", 
    "arxiv-id": "cs/0304021v1", 
    "title": "Model Checking for a Class of Weighted Automata", 
    "publish": "2003-04-15T19:08:00Z", 
    "summary": "A large number of different model checking approaches has been proposed\nduring the last decade. The different approaches are applicable to different\nmodel types including untimed, timed, probabilistic and stochastic models. This\npaper presents a new framework for model checking techniques which includes\nsome of the known approaches, but enlarges the class of models for which model\nchecking can be applied to the general class of weighted automata. The approach\nallows an easy adaption of model checking to models which have not been\nconsidered yet for this purpose. Examples for those new model types for which\nmodel checking can be applied are max/plus or min/plus automata which are well\nestablished models to describe different forms of dynamic systems and\noptimization problems. In this context, model checking can be used to verify\ntemporal or quantitative properties of a system. The paper first presents\nbriefly our class of weighted automata, as a very general model type. Then\nValued Computational Tree Logic (CTL$) is introduced as a natural extension of\nthe well known branching time logic CTL. Afterwards, algorithms to check a\nweighted automaton according to a CTL$ formula are presented. As a last result,\na bisimulation is presented for weighted automata and for CTL$."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304021v1", 
    "other_authors": [
        "Peter Buchholz", 
        "Peter Kemper"
    ], 
    "lead_author": "Peter Buchholz", 
    "arxiv-id": "cs/0304021v1", 
    "title": "Model Checking for a Class of Weighted Automata", 
    "publish": "2003-04-15T19:08:00Z", 
    "summary": "A large number of different model checking approaches has been proposed\nduring the last decade. The different approaches are applicable to different\nmodel types including untimed, timed, probabilistic and stochastic models. This\npaper presents a new framework for model checking techniques which includes\nsome of the known approaches, but enlarges the class of models for which model\nchecking can be applied to the general class of weighted automata. The approach\nallows an easy adaption of model checking to models which have not been\nconsidered yet for this purpose. Examples for those new model types for which\nmodel checking can be applied are max/plus or min/plus automata which are well\nestablished models to describe different forms of dynamic systems and\noptimization problems. In this context, model checking can be used to verify\ntemporal or quantitative properties of a system. The paper first presents\nbriefly our class of weighted automata, as a very general model type. Then\nValued Computational Tree Logic (CTL$) is introduced as a natural extension of\nthe well known branching time logic CTL. Afterwards, algorithms to check a\nweighted automaton according to a CTL$ formula are presented. As a last result,\na bisimulation is presented for weighted automata and for CTL$."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304021v1", 
    "other_authors": [
        "Peter Buchholz", 
        "Peter Kemper"
    ], 
    "lead_author": "Peter Buchholz", 
    "arxiv-id": "cs/0304021v1", 
    "title": "Model Checking for a Class of Weighted Automata", 
    "publish": "2003-04-15T19:08:00Z", 
    "summary": "A large number of different model checking approaches has been proposed\nduring the last decade. The different approaches are applicable to different\nmodel types including untimed, timed, probabilistic and stochastic models. This\npaper presents a new framework for model checking techniques which includes\nsome of the known approaches, but enlarges the class of models for which model\nchecking can be applied to the general class of weighted automata. The approach\nallows an easy adaption of model checking to models which have not been\nconsidered yet for this purpose. Examples for those new model types for which\nmodel checking can be applied are max/plus or min/plus automata which are well\nestablished models to describe different forms of dynamic systems and\noptimization problems. In this context, model checking can be used to verify\ntemporal or quantitative properties of a system. The paper first presents\nbriefly our class of weighted automata, as a very general model type. Then\nValued Computational Tree Logic (CTL$) is introduced as a natural extension of\nthe well known branching time logic CTL. Afterwards, algorithms to check a\nweighted automaton according to a CTL$ formula are presented. As a last result,\na bisimulation is presented for weighted automata and for CTL$."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304021v1", 
    "other_authors": [
        "Peter Buchholz", 
        "Peter Kemper"
    ], 
    "lead_author": "Peter Buchholz", 
    "arxiv-id": "cs/0304021v1", 
    "title": "Model Checking for a Class of Weighted Automata", 
    "publish": "2003-04-15T19:08:00Z", 
    "summary": "A large number of different model checking approaches has been proposed\nduring the last decade. The different approaches are applicable to different\nmodel types including untimed, timed, probabilistic and stochastic models. This\npaper presents a new framework for model checking techniques which includes\nsome of the known approaches, but enlarges the class of models for which model\nchecking can be applied to the general class of weighted automata. The approach\nallows an easy adaption of model checking to models which have not been\nconsidered yet for this purpose. Examples for those new model types for which\nmodel checking can be applied are max/plus or min/plus automata which are well\nestablished models to describe different forms of dynamic systems and\noptimization problems. In this context, model checking can be used to verify\ntemporal or quantitative properties of a system. The paper first presents\nbriefly our class of weighted automata, as a very general model type. Then\nValued Computational Tree Logic (CTL$) is introduced as a natural extension of\nthe well known branching time logic CTL. Afterwards, algorithms to check a\nweighted automaton according to a CTL$ formula are presented. As a last result,\na bisimulation is presented for weighted automata and for CTL$."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304021v1", 
    "other_authors": [
        "Peter Buchholz", 
        "Peter Kemper"
    ], 
    "lead_author": "Peter Buchholz", 
    "arxiv-id": "cs/0304021v1", 
    "title": "Model Checking for a Class of Weighted Automata", 
    "publish": "2003-04-15T19:08:00Z", 
    "summary": "A large number of different model checking approaches has been proposed\nduring the last decade. The different approaches are applicable to different\nmodel types including untimed, timed, probabilistic and stochastic models. This\npaper presents a new framework for model checking techniques which includes\nsome of the known approaches, but enlarges the class of models for which model\nchecking can be applied to the general class of weighted automata. The approach\nallows an easy adaption of model checking to models which have not been\nconsidered yet for this purpose. Examples for those new model types for which\nmodel checking can be applied are max/plus or min/plus automata which are well\nestablished models to describe different forms of dynamic systems and\noptimization problems. In this context, model checking can be used to verify\ntemporal or quantitative properties of a system. The paper first presents\nbriefly our class of weighted automata, as a very general model type. Then\nValued Computational Tree Logic (CTL$) is introduced as a natural extension of\nthe well known branching time logic CTL. Afterwards, algorithms to check a\nweighted automaton according to a CTL$ formula are presented. As a last result,\na bisimulation is presented for weighted automata and for CTL$."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304021v1", 
    "other_authors": [
        "Peter Buchholz", 
        "Peter Kemper"
    ], 
    "lead_author": "Peter Buchholz", 
    "arxiv-id": "cs/0304021v1", 
    "title": "Model Checking for a Class of Weighted Automata", 
    "publish": "2003-04-15T19:08:00Z", 
    "summary": "A large number of different model checking approaches has been proposed\nduring the last decade. The different approaches are applicable to different\nmodel types including untimed, timed, probabilistic and stochastic models. This\npaper presents a new framework for model checking techniques which includes\nsome of the known approaches, but enlarges the class of models for which model\nchecking can be applied to the general class of weighted automata. The approach\nallows an easy adaption of model checking to models which have not been\nconsidered yet for this purpose. Examples for those new model types for which\nmodel checking can be applied are max/plus or min/plus automata which are well\nestablished models to describe different forms of dynamic systems and\noptimization problems. In this context, model checking can be used to verify\ntemporal or quantitative properties of a system. The paper first presents\nbriefly our class of weighted automata, as a very general model type. Then\nValued Computational Tree Logic (CTL$) is introduced as a natural extension of\nthe well known branching time logic CTL. Afterwards, algorithms to check a\nweighted automaton according to a CTL$ formula are presented. As a last result,\na bisimulation is presented for weighted automata and for CTL$."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304021v1", 
    "other_authors": [
        "Peter Buchholz", 
        "Peter Kemper"
    ], 
    "lead_author": "Peter Buchholz", 
    "arxiv-id": "cs/0304021v1", 
    "title": "Model Checking for a Class of Weighted Automata", 
    "publish": "2003-04-15T19:08:00Z", 
    "summary": "A large number of different model checking approaches has been proposed\nduring the last decade. The different approaches are applicable to different\nmodel types including untimed, timed, probabilistic and stochastic models. This\npaper presents a new framework for model checking techniques which includes\nsome of the known approaches, but enlarges the class of models for which model\nchecking can be applied to the general class of weighted automata. The approach\nallows an easy adaption of model checking to models which have not been\nconsidered yet for this purpose. Examples for those new model types for which\nmodel checking can be applied are max/plus or min/plus automata which are well\nestablished models to describe different forms of dynamic systems and\noptimization problems. In this context, model checking can be used to verify\ntemporal or quantitative properties of a system. The paper first presents\nbriefly our class of weighted automata, as a very general model type. Then\nValued Computational Tree Logic (CTL$) is introduced as a natural extension of\nthe well known branching time logic CTL. Afterwards, algorithms to check a\nweighted automaton according to a CTL$ formula are presented. As a last result,\na bisimulation is presented for weighted automata and for CTL$."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304021v1", 
    "other_authors": [
        "Peter Buchholz", 
        "Peter Kemper"
    ], 
    "lead_author": "Peter Buchholz", 
    "arxiv-id": "cs/0304021v1", 
    "title": "Model Checking for a Class of Weighted Automata", 
    "publish": "2003-04-15T19:08:00Z", 
    "summary": "A large number of different model checking approaches has been proposed\nduring the last decade. The different approaches are applicable to different\nmodel types including untimed, timed, probabilistic and stochastic models. This\npaper presents a new framework for model checking techniques which includes\nsome of the known approaches, but enlarges the class of models for which model\nchecking can be applied to the general class of weighted automata. The approach\nallows an easy adaption of model checking to models which have not been\nconsidered yet for this purpose. Examples for those new model types for which\nmodel checking can be applied are max/plus or min/plus automata which are well\nestablished models to describe different forms of dynamic systems and\noptimization problems. In this context, model checking can be used to verify\ntemporal or quantitative properties of a system. The paper first presents\nbriefly our class of weighted automata, as a very general model type. Then\nValued Computational Tree Logic (CTL$) is introduced as a natural extension of\nthe well known branching time logic CTL. Afterwards, algorithms to check a\nweighted automaton according to a CTL$ formula are presented. As a last result,\na bisimulation is presented for weighted automata and for CTL$."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304021v1", 
    "other_authors": [
        "Peter Buchholz", 
        "Peter Kemper"
    ], 
    "lead_author": "Peter Buchholz", 
    "arxiv-id": "cs/0304021v1", 
    "title": "Model Checking for a Class of Weighted Automata", 
    "publish": "2003-04-15T19:08:00Z", 
    "summary": "A large number of different model checking approaches has been proposed\nduring the last decade. The different approaches are applicable to different\nmodel types including untimed, timed, probabilistic and stochastic models. This\npaper presents a new framework for model checking techniques which includes\nsome of the known approaches, but enlarges the class of models for which model\nchecking can be applied to the general class of weighted automata. The approach\nallows an easy adaption of model checking to models which have not been\nconsidered yet for this purpose. Examples for those new model types for which\nmodel checking can be applied are max/plus or min/plus automata which are well\nestablished models to describe different forms of dynamic systems and\noptimization problems. In this context, model checking can be used to verify\ntemporal or quantitative properties of a system. The paper first presents\nbriefly our class of weighted automata, as a very general model type. Then\nValued Computational Tree Logic (CTL$) is introduced as a natural extension of\nthe well known branching time logic CTL. Afterwards, algorithms to check a\nweighted automaton according to a CTL$ formula are presented. As a last result,\na bisimulation is presented for weighted automata and for CTL$."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304021v1", 
    "other_authors": [
        "Peter Buchholz", 
        "Peter Kemper"
    ], 
    "lead_author": "Peter Buchholz", 
    "arxiv-id": "cs/0304021v1", 
    "title": "Model Checking for a Class of Weighted Automata", 
    "publish": "2003-04-15T19:08:00Z", 
    "summary": "A large number of different model checking approaches has been proposed\nduring the last decade. The different approaches are applicable to different\nmodel types including untimed, timed, probabilistic and stochastic models. This\npaper presents a new framework for model checking techniques which includes\nsome of the known approaches, but enlarges the class of models for which model\nchecking can be applied to the general class of weighted automata. The approach\nallows an easy adaption of model checking to models which have not been\nconsidered yet for this purpose. Examples for those new model types for which\nmodel checking can be applied are max/plus or min/plus automata which are well\nestablished models to describe different forms of dynamic systems and\noptimization problems. In this context, model checking can be used to verify\ntemporal or quantitative properties of a system. The paper first presents\nbriefly our class of weighted automata, as a very general model type. Then\nValued Computational Tree Logic (CTL$) is introduced as a natural extension of\nthe well known branching time logic CTL. Afterwards, algorithms to check a\nweighted automaton according to a CTL$ formula are presented. As a last result,\na bisimulation is presented for weighted automata and for CTL$."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304021v1", 
    "other_authors": [
        "Peter Buchholz", 
        "Peter Kemper"
    ], 
    "lead_author": "Peter Buchholz", 
    "arxiv-id": "cs/0304021v1", 
    "title": "Model Checking for a Class of Weighted Automata", 
    "publish": "2003-04-15T19:08:00Z", 
    "summary": "A large number of different model checking approaches has been proposed\nduring the last decade. The different approaches are applicable to different\nmodel types including untimed, timed, probabilistic and stochastic models. This\npaper presents a new framework for model checking techniques which includes\nsome of the known approaches, but enlarges the class of models for which model\nchecking can be applied to the general class of weighted automata. The approach\nallows an easy adaption of model checking to models which have not been\nconsidered yet for this purpose. Examples for those new model types for which\nmodel checking can be applied are max/plus or min/plus automata which are well\nestablished models to describe different forms of dynamic systems and\noptimization problems. In this context, model checking can be used to verify\ntemporal or quantitative properties of a system. The paper first presents\nbriefly our class of weighted automata, as a very general model type. Then\nValued Computational Tree Logic (CTL$) is introduced as a natural extension of\nthe well known branching time logic CTL. Afterwards, algorithms to check a\nweighted automaton according to a CTL$ formula are presented. As a last result,\na bisimulation is presented for weighted automata and for CTL$."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304021v1", 
    "other_authors": [
        "Peter Buchholz", 
        "Peter Kemper"
    ], 
    "lead_author": "Peter Buchholz", 
    "arxiv-id": "cs/0304021v1", 
    "title": "Model Checking for a Class of Weighted Automata", 
    "publish": "2003-04-15T19:08:00Z", 
    "summary": "A large number of different model checking approaches has been proposed\nduring the last decade. The different approaches are applicable to different\nmodel types including untimed, timed, probabilistic and stochastic models. This\npaper presents a new framework for model checking techniques which includes\nsome of the known approaches, but enlarges the class of models for which model\nchecking can be applied to the general class of weighted automata. The approach\nallows an easy adaption of model checking to models which have not been\nconsidered yet for this purpose. Examples for those new model types for which\nmodel checking can be applied are max/plus or min/plus automata which are well\nestablished models to describe different forms of dynamic systems and\noptimization problems. In this context, model checking can be used to verify\ntemporal or quantitative properties of a system. The paper first presents\nbriefly our class of weighted automata, as a very general model type. Then\nValued Computational Tree Logic (CTL$) is introduced as a natural extension of\nthe well known branching time logic CTL. Afterwards, algorithms to check a\nweighted automaton according to a CTL$ formula are presented. As a last result,\na bisimulation is presented for weighted automata and for CTL$."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304021v1", 
    "other_authors": [
        "Peter Buchholz", 
        "Peter Kemper"
    ], 
    "lead_author": "Peter Buchholz", 
    "arxiv-id": "cs/0304021v1", 
    "title": "Model Checking for a Class of Weighted Automata", 
    "publish": "2003-04-15T19:08:00Z", 
    "summary": "A large number of different model checking approaches has been proposed\nduring the last decade. The different approaches are applicable to different\nmodel types including untimed, timed, probabilistic and stochastic models. This\npaper presents a new framework for model checking techniques which includes\nsome of the known approaches, but enlarges the class of models for which model\nchecking can be applied to the general class of weighted automata. The approach\nallows an easy adaption of model checking to models which have not been\nconsidered yet for this purpose. Examples for those new model types for which\nmodel checking can be applied are max/plus or min/plus automata which are well\nestablished models to describe different forms of dynamic systems and\noptimization problems. In this context, model checking can be used to verify\ntemporal or quantitative properties of a system. The paper first presents\nbriefly our class of weighted automata, as a very general model type. Then\nValued Computational Tree Logic (CTL$) is introduced as a natural extension of\nthe well known branching time logic CTL. Afterwards, algorithms to check a\nweighted automaton according to a CTL$ formula are presented. As a last result,\na bisimulation is presented for weighted automata and for CTL$."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304021v1", 
    "other_authors": [
        "Peter Buchholz", 
        "Peter Kemper"
    ], 
    "lead_author": "Peter Buchholz", 
    "arxiv-id": "cs/0304021v1", 
    "title": "Model Checking for a Class of Weighted Automata", 
    "publish": "2003-04-15T19:08:00Z", 
    "summary": "A large number of different model checking approaches has been proposed\nduring the last decade. The different approaches are applicable to different\nmodel types including untimed, timed, probabilistic and stochastic models. This\npaper presents a new framework for model checking techniques which includes\nsome of the known approaches, but enlarges the class of models for which model\nchecking can be applied to the general class of weighted automata. The approach\nallows an easy adaption of model checking to models which have not been\nconsidered yet for this purpose. Examples for those new model types for which\nmodel checking can be applied are max/plus or min/plus automata which are well\nestablished models to describe different forms of dynamic systems and\noptimization problems. In this context, model checking can be used to verify\ntemporal or quantitative properties of a system. The paper first presents\nbriefly our class of weighted automata, as a very general model type. Then\nValued Computational Tree Logic (CTL$) is introduced as a natural extension of\nthe well known branching time logic CTL. Afterwards, algorithms to check a\nweighted automaton according to a CTL$ formula are presented. As a last result,\na bisimulation is presented for weighted automata and for CTL$."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304021v1", 
    "other_authors": [
        "Peter Buchholz", 
        "Peter Kemper"
    ], 
    "lead_author": "Peter Buchholz", 
    "arxiv-id": "cs/0304021v1", 
    "title": "Model Checking for a Class of Weighted Automata", 
    "publish": "2003-04-15T19:08:00Z", 
    "summary": "A large number of different model checking approaches has been proposed\nduring the last decade. The different approaches are applicable to different\nmodel types including untimed, timed, probabilistic and stochastic models. This\npaper presents a new framework for model checking techniques which includes\nsome of the known approaches, but enlarges the class of models for which model\nchecking can be applied to the general class of weighted automata. The approach\nallows an easy adaption of model checking to models which have not been\nconsidered yet for this purpose. Examples for those new model types for which\nmodel checking can be applied are max/plus or min/plus automata which are well\nestablished models to describe different forms of dynamic systems and\noptimization problems. In this context, model checking can be used to verify\ntemporal or quantitative properties of a system. The paper first presents\nbriefly our class of weighted automata, as a very general model type. Then\nValued Computational Tree Logic (CTL$) is introduced as a natural extension of\nthe well known branching time logic CTL. Afterwards, algorithms to check a\nweighted automaton according to a CTL$ formula are presented. As a last result,\na bisimulation is presented for weighted automata and for CTL$."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304021v1", 
    "other_authors": [
        "Peter Buchholz", 
        "Peter Kemper"
    ], 
    "lead_author": "Peter Buchholz", 
    "arxiv-id": "cs/0304021v1", 
    "title": "Model Checking for a Class of Weighted Automata", 
    "publish": "2003-04-15T19:08:00Z", 
    "summary": "A large number of different model checking approaches has been proposed\nduring the last decade. The different approaches are applicable to different\nmodel types including untimed, timed, probabilistic and stochastic models. This\npaper presents a new framework for model checking techniques which includes\nsome of the known approaches, but enlarges the class of models for which model\nchecking can be applied to the general class of weighted automata. The approach\nallows an easy adaption of model checking to models which have not been\nconsidered yet for this purpose. Examples for those new model types for which\nmodel checking can be applied are max/plus or min/plus automata which are well\nestablished models to describe different forms of dynamic systems and\noptimization problems. In this context, model checking can be used to verify\ntemporal or quantitative properties of a system. The paper first presents\nbriefly our class of weighted automata, as a very general model type. Then\nValued Computational Tree Logic (CTL$) is introduced as a natural extension of\nthe well known branching time logic CTL. Afterwards, algorithms to check a\nweighted automaton according to a CTL$ formula are presented. As a last result,\na bisimulation is presented for weighted automata and for CTL$."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304021v1", 
    "other_authors": [
        "Peter Buchholz", 
        "Peter Kemper"
    ], 
    "lead_author": "Peter Buchholz", 
    "arxiv-id": "cs/0304021v1", 
    "title": "Model Checking for a Class of Weighted Automata", 
    "publish": "2003-04-15T19:08:00Z", 
    "summary": "A large number of different model checking approaches has been proposed\nduring the last decade. The different approaches are applicable to different\nmodel types including untimed, timed, probabilistic and stochastic models. This\npaper presents a new framework for model checking techniques which includes\nsome of the known approaches, but enlarges the class of models for which model\nchecking can be applied to the general class of weighted automata. The approach\nallows an easy adaption of model checking to models which have not been\nconsidered yet for this purpose. Examples for those new model types for which\nmodel checking can be applied are max/plus or min/plus automata which are well\nestablished models to describe different forms of dynamic systems and\noptimization problems. In this context, model checking can be used to verify\ntemporal or quantitative properties of a system. The paper first presents\nbriefly our class of weighted automata, as a very general model type. Then\nValued Computational Tree Logic (CTL$) is introduced as a natural extension of\nthe well known branching time logic CTL. Afterwards, algorithms to check a\nweighted automaton according to a CTL$ formula are presented. As a last result,\na bisimulation is presented for weighted automata and for CTL$."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304021v1", 
    "other_authors": [
        "Peter Buchholz", 
        "Peter Kemper"
    ], 
    "lead_author": "Peter Buchholz", 
    "arxiv-id": "cs/0304021v1", 
    "title": "Model Checking for a Class of Weighted Automata", 
    "publish": "2003-04-15T19:08:00Z", 
    "summary": "A large number of different model checking approaches has been proposed\nduring the last decade. The different approaches are applicable to different\nmodel types including untimed, timed, probabilistic and stochastic models. This\npaper presents a new framework for model checking techniques which includes\nsome of the known approaches, but enlarges the class of models for which model\nchecking can be applied to the general class of weighted automata. The approach\nallows an easy adaption of model checking to models which have not been\nconsidered yet for this purpose. Examples for those new model types for which\nmodel checking can be applied are max/plus or min/plus automata which are well\nestablished models to describe different forms of dynamic systems and\noptimization problems. In this context, model checking can be used to verify\ntemporal or quantitative properties of a system. The paper first presents\nbriefly our class of weighted automata, as a very general model type. Then\nValued Computational Tree Logic (CTL$) is introduced as a natural extension of\nthe well known branching time logic CTL. Afterwards, algorithms to check a\nweighted automaton according to a CTL$ formula are presented. As a last result,\na bisimulation is presented for weighted automata and for CTL$."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304021v1", 
    "other_authors": [
        "Peter Buchholz", 
        "Peter Kemper"
    ], 
    "lead_author": "Peter Buchholz", 
    "arxiv-id": "cs/0304021v1", 
    "title": "Model Checking for a Class of Weighted Automata", 
    "publish": "2003-04-15T19:08:00Z", 
    "summary": "A large number of different model checking approaches has been proposed\nduring the last decade. The different approaches are applicable to different\nmodel types including untimed, timed, probabilistic and stochastic models. This\npaper presents a new framework for model checking techniques which includes\nsome of the known approaches, but enlarges the class of models for which model\nchecking can be applied to the general class of weighted automata. The approach\nallows an easy adaption of model checking to models which have not been\nconsidered yet for this purpose. Examples for those new model types for which\nmodel checking can be applied are max/plus or min/plus automata which are well\nestablished models to describe different forms of dynamic systems and\noptimization problems. In this context, model checking can be used to verify\ntemporal or quantitative properties of a system. The paper first presents\nbriefly our class of weighted automata, as a very general model type. Then\nValued Computational Tree Logic (CTL$) is introduced as a natural extension of\nthe well known branching time logic CTL. Afterwards, algorithms to check a\nweighted automaton according to a CTL$ formula are presented. As a last result,\na bisimulation is presented for weighted automata and for CTL$."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304021v1", 
    "other_authors": [
        "Peter Buchholz", 
        "Peter Kemper"
    ], 
    "lead_author": "Peter Buchholz", 
    "arxiv-id": "cs/0304021v1", 
    "title": "Model Checking for a Class of Weighted Automata", 
    "publish": "2003-04-15T19:08:00Z", 
    "summary": "A large number of different model checking approaches has been proposed\nduring the last decade. The different approaches are applicable to different\nmodel types including untimed, timed, probabilistic and stochastic models. This\npaper presents a new framework for model checking techniques which includes\nsome of the known approaches, but enlarges the class of models for which model\nchecking can be applied to the general class of weighted automata. The approach\nallows an easy adaption of model checking to models which have not been\nconsidered yet for this purpose. Examples for those new model types for which\nmodel checking can be applied are max/plus or min/plus automata which are well\nestablished models to describe different forms of dynamic systems and\noptimization problems. In this context, model checking can be used to verify\ntemporal or quantitative properties of a system. The paper first presents\nbriefly our class of weighted automata, as a very general model type. Then\nValued Computational Tree Logic (CTL$) is introduced as a natural extension of\nthe well known branching time logic CTL. Afterwards, algorithms to check a\nweighted automaton according to a CTL$ formula are presented. As a last result,\na bisimulation is presented for weighted automata and for CTL$."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304021v1", 
    "other_authors": [
        "Peter Buchholz", 
        "Peter Kemper"
    ], 
    "lead_author": "Peter Buchholz", 
    "arxiv-id": "cs/0304021v1", 
    "title": "Model Checking for a Class of Weighted Automata", 
    "publish": "2003-04-15T19:08:00Z", 
    "summary": "A large number of different model checking approaches has been proposed\nduring the last decade. The different approaches are applicable to different\nmodel types including untimed, timed, probabilistic and stochastic models. This\npaper presents a new framework for model checking techniques which includes\nsome of the known approaches, but enlarges the class of models for which model\nchecking can be applied to the general class of weighted automata. The approach\nallows an easy adaption of model checking to models which have not been\nconsidered yet for this purpose. Examples for those new model types for which\nmodel checking can be applied are max/plus or min/plus automata which are well\nestablished models to describe different forms of dynamic systems and\noptimization problems. In this context, model checking can be used to verify\ntemporal or quantitative properties of a system. The paper first presents\nbriefly our class of weighted automata, as a very general model type. Then\nValued Computational Tree Logic (CTL$) is introduced as a natural extension of\nthe well known branching time logic CTL. Afterwards, algorithms to check a\nweighted automaton according to a CTL$ formula are presented. As a last result,\na bisimulation is presented for weighted automata and for CTL$."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304021v1", 
    "other_authors": [
        "Peter Buchholz", 
        "Peter Kemper"
    ], 
    "lead_author": "Peter Buchholz", 
    "arxiv-id": "cs/0304021v1", 
    "title": "Model Checking for a Class of Weighted Automata", 
    "publish": "2003-04-15T19:08:00Z", 
    "summary": "A large number of different model checking approaches has been proposed\nduring the last decade. The different approaches are applicable to different\nmodel types including untimed, timed, probabilistic and stochastic models. This\npaper presents a new framework for model checking techniques which includes\nsome of the known approaches, but enlarges the class of models for which model\nchecking can be applied to the general class of weighted automata. The approach\nallows an easy adaption of model checking to models which have not been\nconsidered yet for this purpose. Examples for those new model types for which\nmodel checking can be applied are max/plus or min/plus automata which are well\nestablished models to describe different forms of dynamic systems and\noptimization problems. In this context, model checking can be used to verify\ntemporal or quantitative properties of a system. The paper first presents\nbriefly our class of weighted automata, as a very general model type. Then\nValued Computational Tree Logic (CTL$) is introduced as a natural extension of\nthe well known branching time logic CTL. Afterwards, algorithms to check a\nweighted automaton according to a CTL$ formula are presented. As a last result,\na bisimulation is presented for weighted automata and for CTL$."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304021v1", 
    "other_authors": [
        "Peter Buchholz", 
        "Peter Kemper"
    ], 
    "lead_author": "Peter Buchholz", 
    "arxiv-id": "cs/0304021v1", 
    "title": "Model Checking for a Class of Weighted Automata", 
    "publish": "2003-04-15T19:08:00Z", 
    "summary": "A large number of different model checking approaches has been proposed\nduring the last decade. The different approaches are applicable to different\nmodel types including untimed, timed, probabilistic and stochastic models. This\npaper presents a new framework for model checking techniques which includes\nsome of the known approaches, but enlarges the class of models for which model\nchecking can be applied to the general class of weighted automata. The approach\nallows an easy adaption of model checking to models which have not been\nconsidered yet for this purpose. Examples for those new model types for which\nmodel checking can be applied are max/plus or min/plus automata which are well\nestablished models to describe different forms of dynamic systems and\noptimization problems. In this context, model checking can be used to verify\ntemporal or quantitative properties of a system. The paper first presents\nbriefly our class of weighted automata, as a very general model type. Then\nValued Computational Tree Logic (CTL$) is introduced as a natural extension of\nthe well known branching time logic CTL. Afterwards, algorithms to check a\nweighted automaton according to a CTL$ formula are presented. As a last result,\na bisimulation is presented for weighted automata and for CTL$."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304021v1", 
    "other_authors": [
        "Peter Buchholz", 
        "Peter Kemper"
    ], 
    "lead_author": "Peter Buchholz", 
    "arxiv-id": "cs/0304021v1", 
    "title": "Model Checking for a Class of Weighted Automata", 
    "publish": "2003-04-15T19:08:00Z", 
    "summary": "A large number of different model checking approaches has been proposed\nduring the last decade. The different approaches are applicable to different\nmodel types including untimed, timed, probabilistic and stochastic models. This\npaper presents a new framework for model checking techniques which includes\nsome of the known approaches, but enlarges the class of models for which model\nchecking can be applied to the general class of weighted automata. The approach\nallows an easy adaption of model checking to models which have not been\nconsidered yet for this purpose. Examples for those new model types for which\nmodel checking can be applied are max/plus or min/plus automata which are well\nestablished models to describe different forms of dynamic systems and\noptimization problems. In this context, model checking can be used to verify\ntemporal or quantitative properties of a system. The paper first presents\nbriefly our class of weighted automata, as a very general model type. Then\nValued Computational Tree Logic (CTL$) is introduced as a natural extension of\nthe well known branching time logic CTL. Afterwards, algorithms to check a\nweighted automaton according to a CTL$ formula are presented. As a last result,\na bisimulation is presented for weighted automata and for CTL$."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304021v1", 
    "other_authors": [
        "Peter Buchholz", 
        "Peter Kemper"
    ], 
    "lead_author": "Peter Buchholz", 
    "arxiv-id": "cs/0304021v1", 
    "title": "Model Checking for a Class of Weighted Automata", 
    "publish": "2003-04-15T19:08:00Z", 
    "summary": "A large number of different model checking approaches has been proposed\nduring the last decade. The different approaches are applicable to different\nmodel types including untimed, timed, probabilistic and stochastic models. This\npaper presents a new framework for model checking techniques which includes\nsome of the known approaches, but enlarges the class of models for which model\nchecking can be applied to the general class of weighted automata. The approach\nallows an easy adaption of model checking to models which have not been\nconsidered yet for this purpose. Examples for those new model types for which\nmodel checking can be applied are max/plus or min/plus automata which are well\nestablished models to describe different forms of dynamic systems and\noptimization problems. In this context, model checking can be used to verify\ntemporal or quantitative properties of a system. The paper first presents\nbriefly our class of weighted automata, as a very general model type. Then\nValued Computational Tree Logic (CTL$) is introduced as a natural extension of\nthe well known branching time logic CTL. Afterwards, algorithms to check a\nweighted automaton according to a CTL$ formula are presented. As a last result,\na bisimulation is presented for weighted automata and for CTL$."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304021v1", 
    "other_authors": [
        "Peter Buchholz", 
        "Peter Kemper"
    ], 
    "lead_author": "Peter Buchholz", 
    "arxiv-id": "cs/0304021v1", 
    "title": "Model Checking for a Class of Weighted Automata", 
    "publish": "2003-04-15T19:08:00Z", 
    "summary": "A large number of different model checking approaches has been proposed\nduring the last decade. The different approaches are applicable to different\nmodel types including untimed, timed, probabilistic and stochastic models. This\npaper presents a new framework for model checking techniques which includes\nsome of the known approaches, but enlarges the class of models for which model\nchecking can be applied to the general class of weighted automata. The approach\nallows an easy adaption of model checking to models which have not been\nconsidered yet for this purpose. Examples for those new model types for which\nmodel checking can be applied are max/plus or min/plus automata which are well\nestablished models to describe different forms of dynamic systems and\noptimization problems. In this context, model checking can be used to verify\ntemporal or quantitative properties of a system. The paper first presents\nbriefly our class of weighted automata, as a very general model type. Then\nValued Computational Tree Logic (CTL$) is introduced as a natural extension of\nthe well known branching time logic CTL. Afterwards, algorithms to check a\nweighted automaton according to a CTL$ formula are presented. As a last result,\na bisimulation is presented for weighted automata and for CTL$."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304021v1", 
    "other_authors": [
        "Peter Buchholz", 
        "Peter Kemper"
    ], 
    "lead_author": "Peter Buchholz", 
    "arxiv-id": "cs/0304021v1", 
    "title": "Model Checking for a Class of Weighted Automata", 
    "publish": "2003-04-15T19:08:00Z", 
    "summary": "A large number of different model checking approaches has been proposed\nduring the last decade. The different approaches are applicable to different\nmodel types including untimed, timed, probabilistic and stochastic models. This\npaper presents a new framework for model checking techniques which includes\nsome of the known approaches, but enlarges the class of models for which model\nchecking can be applied to the general class of weighted automata. The approach\nallows an easy adaption of model checking to models which have not been\nconsidered yet for this purpose. Examples for those new model types for which\nmodel checking can be applied are max/plus or min/plus automata which are well\nestablished models to describe different forms of dynamic systems and\noptimization problems. In this context, model checking can be used to verify\ntemporal or quantitative properties of a system. The paper first presents\nbriefly our class of weighted automata, as a very general model type. Then\nValued Computational Tree Logic (CTL$) is introduced as a natural extension of\nthe well known branching time logic CTL. Afterwards, algorithms to check a\nweighted automaton according to a CTL$ formula are presented. As a last result,\na bisimulation is presented for weighted automata and for CTL$."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304021v1", 
    "other_authors": [
        "Peter Buchholz", 
        "Peter Kemper"
    ], 
    "lead_author": "Peter Buchholz", 
    "arxiv-id": "cs/0304021v1", 
    "title": "Model Checking for a Class of Weighted Automata", 
    "publish": "2003-04-15T19:08:00Z", 
    "summary": "A large number of different model checking approaches has been proposed\nduring the last decade. The different approaches are applicable to different\nmodel types including untimed, timed, probabilistic and stochastic models. This\npaper presents a new framework for model checking techniques which includes\nsome of the known approaches, but enlarges the class of models for which model\nchecking can be applied to the general class of weighted automata. The approach\nallows an easy adaption of model checking to models which have not been\nconsidered yet for this purpose. Examples for those new model types for which\nmodel checking can be applied are max/plus or min/plus automata which are well\nestablished models to describe different forms of dynamic systems and\noptimization problems. In this context, model checking can be used to verify\ntemporal or quantitative properties of a system. The paper first presents\nbriefly our class of weighted automata, as a very general model type. Then\nValued Computational Tree Logic (CTL$) is introduced as a natural extension of\nthe well known branching time logic CTL. Afterwards, algorithms to check a\nweighted automaton according to a CTL$ formula are presented. As a last result,\na bisimulation is presented for weighted automata and for CTL$."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304021v1", 
    "other_authors": [
        "Peter Buchholz", 
        "Peter Kemper"
    ], 
    "lead_author": "Peter Buchholz", 
    "arxiv-id": "cs/0304021v1", 
    "title": "Model Checking for a Class of Weighted Automata", 
    "publish": "2003-04-15T19:08:00Z", 
    "summary": "A large number of different model checking approaches has been proposed\nduring the last decade. The different approaches are applicable to different\nmodel types including untimed, timed, probabilistic and stochastic models. This\npaper presents a new framework for model checking techniques which includes\nsome of the known approaches, but enlarges the class of models for which model\nchecking can be applied to the general class of weighted automata. The approach\nallows an easy adaption of model checking to models which have not been\nconsidered yet for this purpose. Examples for those new model types for which\nmodel checking can be applied are max/plus or min/plus automata which are well\nestablished models to describe different forms of dynamic systems and\noptimization problems. In this context, model checking can be used to verify\ntemporal or quantitative properties of a system. The paper first presents\nbriefly our class of weighted automata, as a very general model type. Then\nValued Computational Tree Logic (CTL$) is introduced as a natural extension of\nthe well known branching time logic CTL. Afterwards, algorithms to check a\nweighted automaton according to a CTL$ formula are presented. As a last result,\na bisimulation is presented for weighted automata and for CTL$."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304021v1", 
    "other_authors": [
        "Peter Buchholz", 
        "Peter Kemper"
    ], 
    "lead_author": "Peter Buchholz", 
    "arxiv-id": "cs/0304021v1", 
    "title": "Model Checking for a Class of Weighted Automata", 
    "publish": "2003-04-15T19:08:00Z", 
    "summary": "A large number of different model checking approaches has been proposed\nduring the last decade. The different approaches are applicable to different\nmodel types including untimed, timed, probabilistic and stochastic models. This\npaper presents a new framework for model checking techniques which includes\nsome of the known approaches, but enlarges the class of models for which model\nchecking can be applied to the general class of weighted automata. The approach\nallows an easy adaption of model checking to models which have not been\nconsidered yet for this purpose. Examples for those new model types for which\nmodel checking can be applied are max/plus or min/plus automata which are well\nestablished models to describe different forms of dynamic systems and\noptimization problems. In this context, model checking can be used to verify\ntemporal or quantitative properties of a system. The paper first presents\nbriefly our class of weighted automata, as a very general model type. Then\nValued Computational Tree Logic (CTL$) is introduced as a natural extension of\nthe well known branching time logic CTL. Afterwards, algorithms to check a\nweighted automaton according to a CTL$ formula are presented. As a last result,\na bisimulation is presented for weighted automata and for CTL$."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304021v1", 
    "other_authors": [
        "Peter Buchholz", 
        "Peter Kemper"
    ], 
    "lead_author": "Peter Buchholz", 
    "arxiv-id": "cs/0304021v1", 
    "title": "Model Checking for a Class of Weighted Automata", 
    "publish": "2003-04-15T19:08:00Z", 
    "summary": "A large number of different model checking approaches has been proposed\nduring the last decade. The different approaches are applicable to different\nmodel types including untimed, timed, probabilistic and stochastic models. This\npaper presents a new framework for model checking techniques which includes\nsome of the known approaches, but enlarges the class of models for which model\nchecking can be applied to the general class of weighted automata. The approach\nallows an easy adaption of model checking to models which have not been\nconsidered yet for this purpose. Examples for those new model types for which\nmodel checking can be applied are max/plus or min/plus automata which are well\nestablished models to describe different forms of dynamic systems and\noptimization problems. In this context, model checking can be used to verify\ntemporal or quantitative properties of a system. The paper first presents\nbriefly our class of weighted automata, as a very general model type. Then\nValued Computational Tree Logic (CTL$) is introduced as a natural extension of\nthe well known branching time logic CTL. Afterwards, algorithms to check a\nweighted automaton according to a CTL$ formula are presented. As a last result,\na bisimulation is presented for weighted automata and for CTL$."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304021v1", 
    "other_authors": [
        "Peter Buchholz", 
        "Peter Kemper"
    ], 
    "lead_author": "Peter Buchholz", 
    "arxiv-id": "cs/0304021v1", 
    "title": "Model Checking for a Class of Weighted Automata", 
    "publish": "2003-04-15T19:08:00Z", 
    "summary": "A large number of different model checking approaches has been proposed\nduring the last decade. The different approaches are applicable to different\nmodel types including untimed, timed, probabilistic and stochastic models. This\npaper presents a new framework for model checking techniques which includes\nsome of the known approaches, but enlarges the class of models for which model\nchecking can be applied to the general class of weighted automata. The approach\nallows an easy adaption of model checking to models which have not been\nconsidered yet for this purpose. Examples for those new model types for which\nmodel checking can be applied are max/plus or min/plus automata which are well\nestablished models to describe different forms of dynamic systems and\noptimization problems. In this context, model checking can be used to verify\ntemporal or quantitative properties of a system. The paper first presents\nbriefly our class of weighted automata, as a very general model type. Then\nValued Computational Tree Logic (CTL$) is introduced as a natural extension of\nthe well known branching time logic CTL. Afterwards, algorithms to check a\nweighted automaton according to a CTL$ formula are presented. As a last result,\na bisimulation is presented for weighted automata and for CTL$."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304021v1", 
    "other_authors": [
        "Peter Buchholz", 
        "Peter Kemper"
    ], 
    "lead_author": "Peter Buchholz", 
    "arxiv-id": "cs/0304021v1", 
    "title": "Model Checking for a Class of Weighted Automata", 
    "publish": "2003-04-15T19:08:00Z", 
    "summary": "A large number of different model checking approaches has been proposed\nduring the last decade. The different approaches are applicable to different\nmodel types including untimed, timed, probabilistic and stochastic models. This\npaper presents a new framework for model checking techniques which includes\nsome of the known approaches, but enlarges the class of models for which model\nchecking can be applied to the general class of weighted automata. The approach\nallows an easy adaption of model checking to models which have not been\nconsidered yet for this purpose. Examples for those new model types for which\nmodel checking can be applied are max/plus or min/plus automata which are well\nestablished models to describe different forms of dynamic systems and\noptimization problems. In this context, model checking can be used to verify\ntemporal or quantitative properties of a system. The paper first presents\nbriefly our class of weighted automata, as a very general model type. Then\nValued Computational Tree Logic (CTL$) is introduced as a natural extension of\nthe well known branching time logic CTL. Afterwards, algorithms to check a\nweighted automaton according to a CTL$ formula are presented. As a last result,\na bisimulation is presented for weighted automata and for CTL$."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304021v1", 
    "other_authors": [
        "Peter Buchholz", 
        "Peter Kemper"
    ], 
    "lead_author": "Peter Buchholz", 
    "arxiv-id": "cs/0304021v1", 
    "title": "Model Checking for a Class of Weighted Automata", 
    "publish": "2003-04-15T19:08:00Z", 
    "summary": "A large number of different model checking approaches has been proposed\nduring the last decade. The different approaches are applicable to different\nmodel types including untimed, timed, probabilistic and stochastic models. This\npaper presents a new framework for model checking techniques which includes\nsome of the known approaches, but enlarges the class of models for which model\nchecking can be applied to the general class of weighted automata. The approach\nallows an easy adaption of model checking to models which have not been\nconsidered yet for this purpose. Examples for those new model types for which\nmodel checking can be applied are max/plus or min/plus automata which are well\nestablished models to describe different forms of dynamic systems and\noptimization problems. In this context, model checking can be used to verify\ntemporal or quantitative properties of a system. The paper first presents\nbriefly our class of weighted automata, as a very general model type. Then\nValued Computational Tree Logic (CTL$) is introduced as a natural extension of\nthe well known branching time logic CTL. Afterwards, algorithms to check a\nweighted automaton according to a CTL$ formula are presented. As a last result,\na bisimulation is presented for weighted automata and for CTL$."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304021v1", 
    "other_authors": [
        "Peter Buchholz", 
        "Peter Kemper"
    ], 
    "lead_author": "Peter Buchholz", 
    "arxiv-id": "cs/0304021v1", 
    "title": "Model Checking for a Class of Weighted Automata", 
    "publish": "2003-04-15T19:08:00Z", 
    "summary": "A large number of different model checking approaches has been proposed\nduring the last decade. The different approaches are applicable to different\nmodel types including untimed, timed, probabilistic and stochastic models. This\npaper presents a new framework for model checking techniques which includes\nsome of the known approaches, but enlarges the class of models for which model\nchecking can be applied to the general class of weighted automata. The approach\nallows an easy adaption of model checking to models which have not been\nconsidered yet for this purpose. Examples for those new model types for which\nmodel checking can be applied are max/plus or min/plus automata which are well\nestablished models to describe different forms of dynamic systems and\noptimization problems. In this context, model checking can be used to verify\ntemporal or quantitative properties of a system. The paper first presents\nbriefly our class of weighted automata, as a very general model type. Then\nValued Computational Tree Logic (CTL$) is introduced as a natural extension of\nthe well known branching time logic CTL. Afterwards, algorithms to check a\nweighted automaton according to a CTL$ formula are presented. As a last result,\na bisimulation is presented for weighted automata and for CTL$."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304021v1", 
    "other_authors": [
        "Peter Buchholz", 
        "Peter Kemper"
    ], 
    "lead_author": "Peter Buchholz", 
    "arxiv-id": "cs/0304021v1", 
    "title": "Model Checking for a Class of Weighted Automata", 
    "publish": "2003-04-15T19:08:00Z", 
    "summary": "A large number of different model checking approaches has been proposed\nduring the last decade. The different approaches are applicable to different\nmodel types including untimed, timed, probabilistic and stochastic models. This\npaper presents a new framework for model checking techniques which includes\nsome of the known approaches, but enlarges the class of models for which model\nchecking can be applied to the general class of weighted automata. The approach\nallows an easy adaption of model checking to models which have not been\nconsidered yet for this purpose. Examples for those new model types for which\nmodel checking can be applied are max/plus or min/plus automata which are well\nestablished models to describe different forms of dynamic systems and\noptimization problems. In this context, model checking can be used to verify\ntemporal or quantitative properties of a system. The paper first presents\nbriefly our class of weighted automata, as a very general model type. Then\nValued Computational Tree Logic (CTL$) is introduced as a natural extension of\nthe well known branching time logic CTL. Afterwards, algorithms to check a\nweighted automaton according to a CTL$ formula are presented. As a last result,\na bisimulation is presented for weighted automata and for CTL$."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304021v1", 
    "other_authors": [
        "Peter Buchholz", 
        "Peter Kemper"
    ], 
    "lead_author": "Peter Buchholz", 
    "arxiv-id": "cs/0304021v1", 
    "title": "Model Checking for a Class of Weighted Automata", 
    "publish": "2003-04-15T19:08:00Z", 
    "summary": "A large number of different model checking approaches has been proposed\nduring the last decade. The different approaches are applicable to different\nmodel types including untimed, timed, probabilistic and stochastic models. This\npaper presents a new framework for model checking techniques which includes\nsome of the known approaches, but enlarges the class of models for which model\nchecking can be applied to the general class of weighted automata. The approach\nallows an easy adaption of model checking to models which have not been\nconsidered yet for this purpose. Examples for those new model types for which\nmodel checking can be applied are max/plus or min/plus automata which are well\nestablished models to describe different forms of dynamic systems and\noptimization problems. In this context, model checking can be used to verify\ntemporal or quantitative properties of a system. The paper first presents\nbriefly our class of weighted automata, as a very general model type. Then\nValued Computational Tree Logic (CTL$) is introduced as a natural extension of\nthe well known branching time logic CTL. Afterwards, algorithms to check a\nweighted automaton according to a CTL$ formula are presented. As a last result,\na bisimulation is presented for weighted automata and for CTL$."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304021v1", 
    "other_authors": [
        "Peter Buchholz", 
        "Peter Kemper"
    ], 
    "lead_author": "Peter Buchholz", 
    "arxiv-id": "cs/0304021v1", 
    "title": "Model Checking for a Class of Weighted Automata", 
    "publish": "2003-04-15T19:08:00Z", 
    "summary": "A large number of different model checking approaches has been proposed\nduring the last decade. The different approaches are applicable to different\nmodel types including untimed, timed, probabilistic and stochastic models. This\npaper presents a new framework for model checking techniques which includes\nsome of the known approaches, but enlarges the class of models for which model\nchecking can be applied to the general class of weighted automata. The approach\nallows an easy adaption of model checking to models which have not been\nconsidered yet for this purpose. Examples for those new model types for which\nmodel checking can be applied are max/plus or min/plus automata which are well\nestablished models to describe different forms of dynamic systems and\noptimization problems. In this context, model checking can be used to verify\ntemporal or quantitative properties of a system. The paper first presents\nbriefly our class of weighted automata, as a very general model type. Then\nValued Computational Tree Logic (CTL$) is introduced as a natural extension of\nthe well known branching time logic CTL. Afterwards, algorithms to check a\nweighted automaton according to a CTL$ formula are presented. As a last result,\na bisimulation is presented for weighted automata and for CTL$."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304021v1", 
    "other_authors": [
        "Peter Buchholz", 
        "Peter Kemper"
    ], 
    "lead_author": "Peter Buchholz", 
    "arxiv-id": "cs/0304021v1", 
    "title": "Model Checking for a Class of Weighted Automata", 
    "publish": "2003-04-15T19:08:00Z", 
    "summary": "A large number of different model checking approaches has been proposed\nduring the last decade. The different approaches are applicable to different\nmodel types including untimed, timed, probabilistic and stochastic models. This\npaper presents a new framework for model checking techniques which includes\nsome of the known approaches, but enlarges the class of models for which model\nchecking can be applied to the general class of weighted automata. The approach\nallows an easy adaption of model checking to models which have not been\nconsidered yet for this purpose. Examples for those new model types for which\nmodel checking can be applied are max/plus or min/plus automata which are well\nestablished models to describe different forms of dynamic systems and\noptimization problems. In this context, model checking can be used to verify\ntemporal or quantitative properties of a system. The paper first presents\nbriefly our class of weighted automata, as a very general model type. Then\nValued Computational Tree Logic (CTL$) is introduced as a natural extension of\nthe well known branching time logic CTL. Afterwards, algorithms to check a\nweighted automaton according to a CTL$ formula are presented. As a last result,\na bisimulation is presented for weighted automata and for CTL$."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304021v1", 
    "other_authors": [
        "Peter Buchholz", 
        "Peter Kemper"
    ], 
    "lead_author": "Peter Buchholz", 
    "arxiv-id": "cs/0304021v1", 
    "title": "Model Checking for a Class of Weighted Automata", 
    "publish": "2003-04-15T19:08:00Z", 
    "summary": "A large number of different model checking approaches has been proposed\nduring the last decade. The different approaches are applicable to different\nmodel types including untimed, timed, probabilistic and stochastic models. This\npaper presents a new framework for model checking techniques which includes\nsome of the known approaches, but enlarges the class of models for which model\nchecking can be applied to the general class of weighted automata. The approach\nallows an easy adaption of model checking to models which have not been\nconsidered yet for this purpose. Examples for those new model types for which\nmodel checking can be applied are max/plus or min/plus automata which are well\nestablished models to describe different forms of dynamic systems and\noptimization problems. In this context, model checking can be used to verify\ntemporal or quantitative properties of a system. The paper first presents\nbriefly our class of weighted automata, as a very general model type. Then\nValued Computational Tree Logic (CTL$) is introduced as a natural extension of\nthe well known branching time logic CTL. Afterwards, algorithms to check a\nweighted automaton according to a CTL$ formula are presented. As a last result,\na bisimulation is presented for weighted automata and for CTL$."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304021v1", 
    "other_authors": [
        "Peter Buchholz", 
        "Peter Kemper"
    ], 
    "lead_author": "Peter Buchholz", 
    "arxiv-id": "cs/0304021v1", 
    "title": "Model Checking for a Class of Weighted Automata", 
    "publish": "2003-04-15T19:08:00Z", 
    "summary": "A large number of different model checking approaches has been proposed\nduring the last decade. The different approaches are applicable to different\nmodel types including untimed, timed, probabilistic and stochastic models. This\npaper presents a new framework for model checking techniques which includes\nsome of the known approaches, but enlarges the class of models for which model\nchecking can be applied to the general class of weighted automata. The approach\nallows an easy adaption of model checking to models which have not been\nconsidered yet for this purpose. Examples for those new model types for which\nmodel checking can be applied are max/plus or min/plus automata which are well\nestablished models to describe different forms of dynamic systems and\noptimization problems. In this context, model checking can be used to verify\ntemporal or quantitative properties of a system. The paper first presents\nbriefly our class of weighted automata, as a very general model type. Then\nValued Computational Tree Logic (CTL$) is introduced as a natural extension of\nthe well known branching time logic CTL. Afterwards, algorithms to check a\nweighted automaton according to a CTL$ formula are presented. As a last result,\na bisimulation is presented for weighted automata and for CTL$."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304021v1", 
    "other_authors": [
        "Peter Buchholz", 
        "Peter Kemper"
    ], 
    "lead_author": "Peter Buchholz", 
    "arxiv-id": "cs/0304021v1", 
    "title": "Model Checking for a Class of Weighted Automata", 
    "publish": "2003-04-15T19:08:00Z", 
    "summary": "A large number of different model checking approaches has been proposed\nduring the last decade. The different approaches are applicable to different\nmodel types including untimed, timed, probabilistic and stochastic models. This\npaper presents a new framework for model checking techniques which includes\nsome of the known approaches, but enlarges the class of models for which model\nchecking can be applied to the general class of weighted automata. The approach\nallows an easy adaption of model checking to models which have not been\nconsidered yet for this purpose. Examples for those new model types for which\nmodel checking can be applied are max/plus or min/plus automata which are well\nestablished models to describe different forms of dynamic systems and\noptimization problems. In this context, model checking can be used to verify\ntemporal or quantitative properties of a system. The paper first presents\nbriefly our class of weighted automata, as a very general model type. Then\nValued Computational Tree Logic (CTL$) is introduced as a natural extension of\nthe well known branching time logic CTL. Afterwards, algorithms to check a\nweighted automaton according to a CTL$ formula are presented. As a last result,\na bisimulation is presented for weighted automata and for CTL$."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304021v1", 
    "other_authors": [
        "Peter Buchholz", 
        "Peter Kemper"
    ], 
    "lead_author": "Peter Buchholz", 
    "arxiv-id": "cs/0304021v1", 
    "title": "Model Checking for a Class of Weighted Automata", 
    "publish": "2003-04-15T19:08:00Z", 
    "summary": "A large number of different model checking approaches has been proposed\nduring the last decade. The different approaches are applicable to different\nmodel types including untimed, timed, probabilistic and stochastic models. This\npaper presents a new framework for model checking techniques which includes\nsome of the known approaches, but enlarges the class of models for which model\nchecking can be applied to the general class of weighted automata. The approach\nallows an easy adaption of model checking to models which have not been\nconsidered yet for this purpose. Examples for those new model types for which\nmodel checking can be applied are max/plus or min/plus automata which are well\nestablished models to describe different forms of dynamic systems and\noptimization problems. In this context, model checking can be used to verify\ntemporal or quantitative properties of a system. The paper first presents\nbriefly our class of weighted automata, as a very general model type. Then\nValued Computational Tree Logic (CTL$) is introduced as a natural extension of\nthe well known branching time logic CTL. Afterwards, algorithms to check a\nweighted automaton according to a CTL$ formula are presented. As a last result,\na bisimulation is presented for weighted automata and for CTL$."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304021v1", 
    "other_authors": [
        "Peter Buchholz", 
        "Peter Kemper"
    ], 
    "lead_author": "Peter Buchholz", 
    "arxiv-id": "cs/0304021v1", 
    "title": "Model Checking for a Class of Weighted Automata", 
    "publish": "2003-04-15T19:08:00Z", 
    "summary": "A large number of different model checking approaches has been proposed\nduring the last decade. The different approaches are applicable to different\nmodel types including untimed, timed, probabilistic and stochastic models. This\npaper presents a new framework for model checking techniques which includes\nsome of the known approaches, but enlarges the class of models for which model\nchecking can be applied to the general class of weighted automata. The approach\nallows an easy adaption of model checking to models which have not been\nconsidered yet for this purpose. Examples for those new model types for which\nmodel checking can be applied are max/plus or min/plus automata which are well\nestablished models to describe different forms of dynamic systems and\noptimization problems. In this context, model checking can be used to verify\ntemporal or quantitative properties of a system. The paper first presents\nbriefly our class of weighted automata, as a very general model type. Then\nValued Computational Tree Logic (CTL$) is introduced as a natural extension of\nthe well known branching time logic CTL. Afterwards, algorithms to check a\nweighted automaton according to a CTL$ formula are presented. As a last result,\na bisimulation is presented for weighted automata and for CTL$."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304021v1", 
    "other_authors": [
        "Peter Buchholz", 
        "Peter Kemper"
    ], 
    "lead_author": "Peter Buchholz", 
    "arxiv-id": "cs/0304021v1", 
    "title": "Model Checking for a Class of Weighted Automata", 
    "publish": "2003-04-15T19:08:00Z", 
    "summary": "A large number of different model checking approaches has been proposed\nduring the last decade. The different approaches are applicable to different\nmodel types including untimed, timed, probabilistic and stochastic models. This\npaper presents a new framework for model checking techniques which includes\nsome of the known approaches, but enlarges the class of models for which model\nchecking can be applied to the general class of weighted automata. The approach\nallows an easy adaption of model checking to models which have not been\nconsidered yet for this purpose. Examples for those new model types for which\nmodel checking can be applied are max/plus or min/plus automata which are well\nestablished models to describe different forms of dynamic systems and\noptimization problems. In this context, model checking can be used to verify\ntemporal or quantitative properties of a system. The paper first presents\nbriefly our class of weighted automata, as a very general model type. Then\nValued Computational Tree Logic (CTL$) is introduced as a natural extension of\nthe well known branching time logic CTL. Afterwards, algorithms to check a\nweighted automaton according to a CTL$ formula are presented. As a last result,\na bisimulation is presented for weighted automata and for CTL$."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304021v1", 
    "other_authors": [
        "Peter Buchholz", 
        "Peter Kemper"
    ], 
    "lead_author": "Peter Buchholz", 
    "arxiv-id": "cs/0304021v1", 
    "title": "Model Checking for a Class of Weighted Automata", 
    "publish": "2003-04-15T19:08:00Z", 
    "summary": "A large number of different model checking approaches has been proposed\nduring the last decade. The different approaches are applicable to different\nmodel types including untimed, timed, probabilistic and stochastic models. This\npaper presents a new framework for model checking techniques which includes\nsome of the known approaches, but enlarges the class of models for which model\nchecking can be applied to the general class of weighted automata. The approach\nallows an easy adaption of model checking to models which have not been\nconsidered yet for this purpose. Examples for those new model types for which\nmodel checking can be applied are max/plus or min/plus automata which are well\nestablished models to describe different forms of dynamic systems and\noptimization problems. In this context, model checking can be used to verify\ntemporal or quantitative properties of a system. The paper first presents\nbriefly our class of weighted automata, as a very general model type. Then\nValued Computational Tree Logic (CTL$) is introduced as a natural extension of\nthe well known branching time logic CTL. Afterwards, algorithms to check a\nweighted automaton according to a CTL$ formula are presented. As a last result,\na bisimulation is presented for weighted automata and for CTL$."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304021v1", 
    "other_authors": [
        "Peter Buchholz", 
        "Peter Kemper"
    ], 
    "lead_author": "Peter Buchholz", 
    "arxiv-id": "cs/0304021v1", 
    "title": "Model Checking for a Class of Weighted Automata", 
    "publish": "2003-04-15T19:08:00Z", 
    "summary": "A large number of different model checking approaches has been proposed\nduring the last decade. The different approaches are applicable to different\nmodel types including untimed, timed, probabilistic and stochastic models. This\npaper presents a new framework for model checking techniques which includes\nsome of the known approaches, but enlarges the class of models for which model\nchecking can be applied to the general class of weighted automata. The approach\nallows an easy adaption of model checking to models which have not been\nconsidered yet for this purpose. Examples for those new model types for which\nmodel checking can be applied are max/plus or min/plus automata which are well\nestablished models to describe different forms of dynamic systems and\noptimization problems. In this context, model checking can be used to verify\ntemporal or quantitative properties of a system. The paper first presents\nbriefly our class of weighted automata, as a very general model type. Then\nValued Computational Tree Logic (CTL$) is introduced as a natural extension of\nthe well known branching time logic CTL. Afterwards, algorithms to check a\nweighted automaton according to a CTL$ formula are presented. As a last result,\na bisimulation is presented for weighted automata and for CTL$."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304021v1", 
    "other_authors": [
        "Peter Buchholz", 
        "Peter Kemper"
    ], 
    "lead_author": "Peter Buchholz", 
    "arxiv-id": "cs/0304021v1", 
    "title": "Model Checking for a Class of Weighted Automata", 
    "publish": "2003-04-15T19:08:00Z", 
    "summary": "A large number of different model checking approaches has been proposed\nduring the last decade. The different approaches are applicable to different\nmodel types including untimed, timed, probabilistic and stochastic models. This\npaper presents a new framework for model checking techniques which includes\nsome of the known approaches, but enlarges the class of models for which model\nchecking can be applied to the general class of weighted automata. The approach\nallows an easy adaption of model checking to models which have not been\nconsidered yet for this purpose. Examples for those new model types for which\nmodel checking can be applied are max/plus or min/plus automata which are well\nestablished models to describe different forms of dynamic systems and\noptimization problems. In this context, model checking can be used to verify\ntemporal or quantitative properties of a system. The paper first presents\nbriefly our class of weighted automata, as a very general model type. Then\nValued Computational Tree Logic (CTL$) is introduced as a natural extension of\nthe well known branching time logic CTL. Afterwards, algorithms to check a\nweighted automaton according to a CTL$ formula are presented. As a last result,\na bisimulation is presented for weighted automata and for CTL$."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304021v1", 
    "other_authors": [
        "Peter Buchholz", 
        "Peter Kemper"
    ], 
    "lead_author": "Peter Buchholz", 
    "arxiv-id": "cs/0304021v1", 
    "title": "Model Checking for a Class of Weighted Automata", 
    "publish": "2003-04-15T19:08:00Z", 
    "summary": "A large number of different model checking approaches has been proposed\nduring the last decade. The different approaches are applicable to different\nmodel types including untimed, timed, probabilistic and stochastic models. This\npaper presents a new framework for model checking techniques which includes\nsome of the known approaches, but enlarges the class of models for which model\nchecking can be applied to the general class of weighted automata. The approach\nallows an easy adaption of model checking to models which have not been\nconsidered yet for this purpose. Examples for those new model types for which\nmodel checking can be applied are max/plus or min/plus automata which are well\nestablished models to describe different forms of dynamic systems and\noptimization problems. In this context, model checking can be used to verify\ntemporal or quantitative properties of a system. The paper first presents\nbriefly our class of weighted automata, as a very general model type. Then\nValued Computational Tree Logic (CTL$) is introduced as a natural extension of\nthe well known branching time logic CTL. Afterwards, algorithms to check a\nweighted automaton according to a CTL$ formula are presented. As a last result,\na bisimulation is presented for weighted automata and for CTL$."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304021v1", 
    "other_authors": [
        "Peter Buchholz", 
        "Peter Kemper"
    ], 
    "lead_author": "Peter Buchholz", 
    "arxiv-id": "cs/0304021v1", 
    "title": "Model Checking for a Class of Weighted Automata", 
    "publish": "2003-04-15T19:08:00Z", 
    "summary": "A large number of different model checking approaches has been proposed\nduring the last decade. The different approaches are applicable to different\nmodel types including untimed, timed, probabilistic and stochastic models. This\npaper presents a new framework for model checking techniques which includes\nsome of the known approaches, but enlarges the class of models for which model\nchecking can be applied to the general class of weighted automata. The approach\nallows an easy adaption of model checking to models which have not been\nconsidered yet for this purpose. Examples for those new model types for which\nmodel checking can be applied are max/plus or min/plus automata which are well\nestablished models to describe different forms of dynamic systems and\noptimization problems. In this context, model checking can be used to verify\ntemporal or quantitative properties of a system. The paper first presents\nbriefly our class of weighted automata, as a very general model type. Then\nValued Computational Tree Logic (CTL$) is introduced as a natural extension of\nthe well known branching time logic CTL. Afterwards, algorithms to check a\nweighted automaton according to a CTL$ formula are presented. As a last result,\na bisimulation is presented for weighted automata and for CTL$."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304021v1", 
    "other_authors": [
        "Peter Buchholz", 
        "Peter Kemper"
    ], 
    "lead_author": "Peter Buchholz", 
    "arxiv-id": "cs/0304021v1", 
    "title": "Model Checking for a Class of Weighted Automata", 
    "publish": "2003-04-15T19:08:00Z", 
    "summary": "A large number of different model checking approaches has been proposed\nduring the last decade. The different approaches are applicable to different\nmodel types including untimed, timed, probabilistic and stochastic models. This\npaper presents a new framework for model checking techniques which includes\nsome of the known approaches, but enlarges the class of models for which model\nchecking can be applied to the general class of weighted automata. The approach\nallows an easy adaption of model checking to models which have not been\nconsidered yet for this purpose. Examples for those new model types for which\nmodel checking can be applied are max/plus or min/plus automata which are well\nestablished models to describe different forms of dynamic systems and\noptimization problems. In this context, model checking can be used to verify\ntemporal or quantitative properties of a system. The paper first presents\nbriefly our class of weighted automata, as a very general model type. Then\nValued Computational Tree Logic (CTL$) is introduced as a natural extension of\nthe well known branching time logic CTL. Afterwards, algorithms to check a\nweighted automaton according to a CTL$ formula are presented. As a last result,\na bisimulation is presented for weighted automata and for CTL$."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304021v1", 
    "other_authors": [
        "Peter Buchholz", 
        "Peter Kemper"
    ], 
    "lead_author": "Peter Buchholz", 
    "arxiv-id": "cs/0304021v1", 
    "title": "Model Checking for a Class of Weighted Automata", 
    "publish": "2003-04-15T19:08:00Z", 
    "summary": "A large number of different model checking approaches has been proposed\nduring the last decade. The different approaches are applicable to different\nmodel types including untimed, timed, probabilistic and stochastic models. This\npaper presents a new framework for model checking techniques which includes\nsome of the known approaches, but enlarges the class of models for which model\nchecking can be applied to the general class of weighted automata. The approach\nallows an easy adaption of model checking to models which have not been\nconsidered yet for this purpose. Examples for those new model types for which\nmodel checking can be applied are max/plus or min/plus automata which are well\nestablished models to describe different forms of dynamic systems and\noptimization problems. In this context, model checking can be used to verify\ntemporal or quantitative properties of a system. The paper first presents\nbriefly our class of weighted automata, as a very general model type. Then\nValued Computational Tree Logic (CTL$) is introduced as a natural extension of\nthe well known branching time logic CTL. Afterwards, algorithms to check a\nweighted automaton according to a CTL$ formula are presented. As a last result,\na bisimulation is presented for weighted automata and for CTL$."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304021v1", 
    "other_authors": [
        "Peter Buchholz", 
        "Peter Kemper"
    ], 
    "lead_author": "Peter Buchholz", 
    "arxiv-id": "cs/0304021v1", 
    "title": "Model Checking for a Class of Weighted Automata", 
    "publish": "2003-04-15T19:08:00Z", 
    "summary": "A large number of different model checking approaches has been proposed\nduring the last decade. The different approaches are applicable to different\nmodel types including untimed, timed, probabilistic and stochastic models. This\npaper presents a new framework for model checking techniques which includes\nsome of the known approaches, but enlarges the class of models for which model\nchecking can be applied to the general class of weighted automata. The approach\nallows an easy adaption of model checking to models which have not been\nconsidered yet for this purpose. Examples for those new model types for which\nmodel checking can be applied are max/plus or min/plus automata which are well\nestablished models to describe different forms of dynamic systems and\noptimization problems. In this context, model checking can be used to verify\ntemporal or quantitative properties of a system. The paper first presents\nbriefly our class of weighted automata, as a very general model type. Then\nValued Computational Tree Logic (CTL$) is introduced as a natural extension of\nthe well known branching time logic CTL. Afterwards, algorithms to check a\nweighted automaton according to a CTL$ formula are presented. As a last result,\na bisimulation is presented for weighted automata and for CTL$."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304021v1", 
    "other_authors": [
        "Peter Buchholz", 
        "Peter Kemper"
    ], 
    "lead_author": "Peter Buchholz", 
    "arxiv-id": "cs/0304021v1", 
    "title": "Model Checking for a Class of Weighted Automata", 
    "publish": "2003-04-15T19:08:00Z", 
    "summary": "A large number of different model checking approaches has been proposed\nduring the last decade. The different approaches are applicable to different\nmodel types including untimed, timed, probabilistic and stochastic models. This\npaper presents a new framework for model checking techniques which includes\nsome of the known approaches, but enlarges the class of models for which model\nchecking can be applied to the general class of weighted automata. The approach\nallows an easy adaption of model checking to models which have not been\nconsidered yet for this purpose. Examples for those new model types for which\nmodel checking can be applied are max/plus or min/plus automata which are well\nestablished models to describe different forms of dynamic systems and\noptimization problems. In this context, model checking can be used to verify\ntemporal or quantitative properties of a system. The paper first presents\nbriefly our class of weighted automata, as a very general model type. Then\nValued Computational Tree Logic (CTL$) is introduced as a natural extension of\nthe well known branching time logic CTL. Afterwards, algorithms to check a\nweighted automaton according to a CTL$ formula are presented. As a last result,\na bisimulation is presented for weighted automata and for CTL$."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304021v1", 
    "other_authors": [
        "Peter Buchholz", 
        "Peter Kemper"
    ], 
    "lead_author": "Peter Buchholz", 
    "arxiv-id": "cs/0304021v1", 
    "title": "Model Checking for a Class of Weighted Automata", 
    "publish": "2003-04-15T19:08:00Z", 
    "summary": "A large number of different model checking approaches has been proposed\nduring the last decade. The different approaches are applicable to different\nmodel types including untimed, timed, probabilistic and stochastic models. This\npaper presents a new framework for model checking techniques which includes\nsome of the known approaches, but enlarges the class of models for which model\nchecking can be applied to the general class of weighted automata. The approach\nallows an easy adaption of model checking to models which have not been\nconsidered yet for this purpose. Examples for those new model types for which\nmodel checking can be applied are max/plus or min/plus automata which are well\nestablished models to describe different forms of dynamic systems and\noptimization problems. In this context, model checking can be used to verify\ntemporal or quantitative properties of a system. The paper first presents\nbriefly our class of weighted automata, as a very general model type. Then\nValued Computational Tree Logic (CTL$) is introduced as a natural extension of\nthe well known branching time logic CTL. Afterwards, algorithms to check a\nweighted automaton according to a CTL$ formula are presented. As a last result,\na bisimulation is presented for weighted automata and for CTL$."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304021v1", 
    "other_authors": [
        "Peter Buchholz", 
        "Peter Kemper"
    ], 
    "lead_author": "Peter Buchholz", 
    "arxiv-id": "cs/0304021v1", 
    "title": "Model Checking for a Class of Weighted Automata", 
    "publish": "2003-04-15T19:08:00Z", 
    "summary": "A large number of different model checking approaches has been proposed\nduring the last decade. The different approaches are applicable to different\nmodel types including untimed, timed, probabilistic and stochastic models. This\npaper presents a new framework for model checking techniques which includes\nsome of the known approaches, but enlarges the class of models for which model\nchecking can be applied to the general class of weighted automata. The approach\nallows an easy adaption of model checking to models which have not been\nconsidered yet for this purpose. Examples for those new model types for which\nmodel checking can be applied are max/plus or min/plus automata which are well\nestablished models to describe different forms of dynamic systems and\noptimization problems. In this context, model checking can be used to verify\ntemporal or quantitative properties of a system. The paper first presents\nbriefly our class of weighted automata, as a very general model type. Then\nValued Computational Tree Logic (CTL$) is introduced as a natural extension of\nthe well known branching time logic CTL. Afterwards, algorithms to check a\nweighted automaton according to a CTL$ formula are presented. As a last result,\na bisimulation is presented for weighted automata and for CTL$."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304021v1", 
    "other_authors": [
        "Peter Buchholz", 
        "Peter Kemper"
    ], 
    "lead_author": "Peter Buchholz", 
    "arxiv-id": "cs/0304021v1", 
    "title": "Model Checking for a Class of Weighted Automata", 
    "publish": "2003-04-15T19:08:00Z", 
    "summary": "A large number of different model checking approaches has been proposed\nduring the last decade. The different approaches are applicable to different\nmodel types including untimed, timed, probabilistic and stochastic models. This\npaper presents a new framework for model checking techniques which includes\nsome of the known approaches, but enlarges the class of models for which model\nchecking can be applied to the general class of weighted automata. The approach\nallows an easy adaption of model checking to models which have not been\nconsidered yet for this purpose. Examples for those new model types for which\nmodel checking can be applied are max/plus or min/plus automata which are well\nestablished models to describe different forms of dynamic systems and\noptimization problems. In this context, model checking can be used to verify\ntemporal or quantitative properties of a system. The paper first presents\nbriefly our class of weighted automata, as a very general model type. Then\nValued Computational Tree Logic (CTL$) is introduced as a natural extension of\nthe well known branching time logic CTL. Afterwards, algorithms to check a\nweighted automaton according to a CTL$ formula are presented. As a last result,\na bisimulation is presented for weighted automata and for CTL$."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304021v1", 
    "other_authors": [
        "Peter Buchholz", 
        "Peter Kemper"
    ], 
    "lead_author": "Peter Buchholz", 
    "arxiv-id": "cs/0304021v1", 
    "title": "Model Checking for a Class of Weighted Automata", 
    "publish": "2003-04-15T19:08:00Z", 
    "summary": "A large number of different model checking approaches has been proposed\nduring the last decade. The different approaches are applicable to different\nmodel types including untimed, timed, probabilistic and stochastic models. This\npaper presents a new framework for model checking techniques which includes\nsome of the known approaches, but enlarges the class of models for which model\nchecking can be applied to the general class of weighted automata. The approach\nallows an easy adaption of model checking to models which have not been\nconsidered yet for this purpose. Examples for those new model types for which\nmodel checking can be applied are max/plus or min/plus automata which are well\nestablished models to describe different forms of dynamic systems and\noptimization problems. In this context, model checking can be used to verify\ntemporal or quantitative properties of a system. The paper first presents\nbriefly our class of weighted automata, as a very general model type. Then\nValued Computational Tree Logic (CTL$) is introduced as a natural extension of\nthe well known branching time logic CTL. Afterwards, algorithms to check a\nweighted automaton according to a CTL$ formula are presented. As a last result,\na bisimulation is presented for weighted automata and for CTL$."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304021v1", 
    "other_authors": [
        "Peter Buchholz", 
        "Peter Kemper"
    ], 
    "lead_author": "Peter Buchholz", 
    "arxiv-id": "cs/0304021v1", 
    "title": "Model Checking for a Class of Weighted Automata", 
    "publish": "2003-04-15T19:08:00Z", 
    "summary": "A large number of different model checking approaches has been proposed\nduring the last decade. The different approaches are applicable to different\nmodel types including untimed, timed, probabilistic and stochastic models. This\npaper presents a new framework for model checking techniques which includes\nsome of the known approaches, but enlarges the class of models for which model\nchecking can be applied to the general class of weighted automata. The approach\nallows an easy adaption of model checking to models which have not been\nconsidered yet for this purpose. Examples for those new model types for which\nmodel checking can be applied are max/plus or min/plus automata which are well\nestablished models to describe different forms of dynamic systems and\noptimization problems. In this context, model checking can be used to verify\ntemporal or quantitative properties of a system. The paper first presents\nbriefly our class of weighted automata, as a very general model type. Then\nValued Computational Tree Logic (CTL$) is introduced as a natural extension of\nthe well known branching time logic CTL. Afterwards, algorithms to check a\nweighted automaton according to a CTL$ formula are presented. As a last result,\na bisimulation is presented for weighted automata and for CTL$."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304021v1", 
    "other_authors": [
        "Peter Buchholz", 
        "Peter Kemper"
    ], 
    "lead_author": "Peter Buchholz", 
    "arxiv-id": "cs/0304021v1", 
    "title": "Model Checking for a Class of Weighted Automata", 
    "publish": "2003-04-15T19:08:00Z", 
    "summary": "A large number of different model checking approaches has been proposed\nduring the last decade. The different approaches are applicable to different\nmodel types including untimed, timed, probabilistic and stochastic models. This\npaper presents a new framework for model checking techniques which includes\nsome of the known approaches, but enlarges the class of models for which model\nchecking can be applied to the general class of weighted automata. The approach\nallows an easy adaption of model checking to models which have not been\nconsidered yet for this purpose. Examples for those new model types for which\nmodel checking can be applied are max/plus or min/plus automata which are well\nestablished models to describe different forms of dynamic systems and\noptimization problems. In this context, model checking can be used to verify\ntemporal or quantitative properties of a system. The paper first presents\nbriefly our class of weighted automata, as a very general model type. Then\nValued Computational Tree Logic (CTL$) is introduced as a natural extension of\nthe well known branching time logic CTL. Afterwards, algorithms to check a\nweighted automaton according to a CTL$ formula are presented. As a last result,\na bisimulation is presented for weighted automata and for CTL$."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304021v1", 
    "other_authors": [
        "Peter Buchholz", 
        "Peter Kemper"
    ], 
    "lead_author": "Peter Buchholz", 
    "arxiv-id": "cs/0304021v1", 
    "title": "Model Checking for a Class of Weighted Automata", 
    "publish": "2003-04-15T19:08:00Z", 
    "summary": "A large number of different model checking approaches has been proposed\nduring the last decade. The different approaches are applicable to different\nmodel types including untimed, timed, probabilistic and stochastic models. This\npaper presents a new framework for model checking techniques which includes\nsome of the known approaches, but enlarges the class of models for which model\nchecking can be applied to the general class of weighted automata. The approach\nallows an easy adaption of model checking to models which have not been\nconsidered yet for this purpose. Examples for those new model types for which\nmodel checking can be applied are max/plus or min/plus automata which are well\nestablished models to describe different forms of dynamic systems and\noptimization problems. In this context, model checking can be used to verify\ntemporal or quantitative properties of a system. The paper first presents\nbriefly our class of weighted automata, as a very general model type. Then\nValued Computational Tree Logic (CTL$) is introduced as a natural extension of\nthe well known branching time logic CTL. Afterwards, algorithms to check a\nweighted automaton according to a CTL$ formula are presented. As a last result,\na bisimulation is presented for weighted automata and for CTL$."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304021v1", 
    "other_authors": [
        "Peter Buchholz", 
        "Peter Kemper"
    ], 
    "lead_author": "Peter Buchholz", 
    "arxiv-id": "cs/0304021v1", 
    "title": "Model Checking for a Class of Weighted Automata", 
    "publish": "2003-04-15T19:08:00Z", 
    "summary": "A large number of different model checking approaches has been proposed\nduring the last decade. The different approaches are applicable to different\nmodel types including untimed, timed, probabilistic and stochastic models. This\npaper presents a new framework for model checking techniques which includes\nsome of the known approaches, but enlarges the class of models for which model\nchecking can be applied to the general class of weighted automata. The approach\nallows an easy adaption of model checking to models which have not been\nconsidered yet for this purpose. Examples for those new model types for which\nmodel checking can be applied are max/plus or min/plus automata which are well\nestablished models to describe different forms of dynamic systems and\noptimization problems. In this context, model checking can be used to verify\ntemporal or quantitative properties of a system. The paper first presents\nbriefly our class of weighted automata, as a very general model type. Then\nValued Computational Tree Logic (CTL$) is introduced as a natural extension of\nthe well known branching time logic CTL. Afterwards, algorithms to check a\nweighted automaton according to a CTL$ formula are presented. As a last result,\na bisimulation is presented for weighted automata and for CTL$."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304021v1", 
    "other_authors": [
        "Peter Buchholz", 
        "Peter Kemper"
    ], 
    "lead_author": "Peter Buchholz", 
    "arxiv-id": "cs/0304021v1", 
    "title": "Model Checking for a Class of Weighted Automata", 
    "publish": "2003-04-15T19:08:00Z", 
    "summary": "A large number of different model checking approaches has been proposed\nduring the last decade. The different approaches are applicable to different\nmodel types including untimed, timed, probabilistic and stochastic models. This\npaper presents a new framework for model checking techniques which includes\nsome of the known approaches, but enlarges the class of models for which model\nchecking can be applied to the general class of weighted automata. The approach\nallows an easy adaption of model checking to models which have not been\nconsidered yet for this purpose. Examples for those new model types for which\nmodel checking can be applied are max/plus or min/plus automata which are well\nestablished models to describe different forms of dynamic systems and\noptimization problems. In this context, model checking can be used to verify\ntemporal or quantitative properties of a system. The paper first presents\nbriefly our class of weighted automata, as a very general model type. Then\nValued Computational Tree Logic (CTL$) is introduced as a natural extension of\nthe well known branching time logic CTL. Afterwards, algorithms to check a\nweighted automaton according to a CTL$ formula are presented. As a last result,\na bisimulation is presented for weighted automata and for CTL$."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304021v1", 
    "other_authors": [
        "Peter Buchholz", 
        "Peter Kemper"
    ], 
    "lead_author": "Peter Kemper", 
    "arxiv-id": "cs/0304021v1", 
    "title": "Model Checking for a Class of Weighted Automata", 
    "publish": "2003-04-15T19:08:00Z", 
    "summary": "A large number of different model checking approaches has been proposed\nduring the last decade. The different approaches are applicable to different\nmodel types including untimed, timed, probabilistic and stochastic models. This\npaper presents a new framework for model checking techniques which includes\nsome of the known approaches, but enlarges the class of models for which model\nchecking can be applied to the general class of weighted automata. The approach\nallows an easy adaption of model checking to models which have not been\nconsidered yet for this purpose. Examples for those new model types for which\nmodel checking can be applied are max/plus or min/plus automata which are well\nestablished models to describe different forms of dynamic systems and\noptimization problems. In this context, model checking can be used to verify\ntemporal or quantitative properties of a system. The paper first presents\nbriefly our class of weighted automata, as a very general model type. Then\nValued Computational Tree Logic (CTL$) is introduced as a natural extension of\nthe well known branching time logic CTL. Afterwards, algorithms to check a\nweighted automaton according to a CTL$ formula are presented. As a last result,\na bisimulation is presented for weighted automata and for CTL$."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304046v1", 
    "other_authors": [
        "Carlo Montangero", 
        "Laura Semini"
    ], 
    "lead_author": "Carlo Montangero", 
    "arxiv-id": "cs/0304046v1", 
    "title": "Distributed States Temporal Logic", 
    "publish": "2003-04-30T18:54:59Z", 
    "summary": "We introduce a temporal logic to reason on global applications in an\nasynchronous setting. First, we define the Distributed States Logic (DSL), a\nmodal logic for localities that embeds the local theories of each component\ninto a theory of the distributed states of the system. We provide the logic\nwith a sound and complete axiomatization. The contribution is that it is\npossible to reason about properties that involve several components, even in\nthe absence of a global clock. Then, we define the Distributed States Temporal\nLogic (DSTL) by introducing temporal operators a' la Unity. We support our\nproposal by working out a pair of examples: a simple secure communication\nsystem, and an algorithm for distributed leader election.\n  The motivation for this work is that the existing logics for distributed\nsystems do not have the right expressive power to reason on the systems\nbehaviour, when the communication is based on asynchronous message passing. On\nthe other side, asynchronous communication is the most used abstraction when\nmodelling global applications."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304046v1", 
    "other_authors": [
        "Carlo Montangero", 
        "Laura Semini"
    ], 
    "lead_author": "Laura Semini", 
    "arxiv-id": "cs/0304046v1", 
    "title": "Distributed States Temporal Logic", 
    "publish": "2003-04-30T18:54:59Z", 
    "summary": "We introduce a temporal logic to reason on global applications in an\nasynchronous setting. First, we define the Distributed States Logic (DSL), a\nmodal logic for localities that embeds the local theories of each component\ninto a theory of the distributed states of the system. We provide the logic\nwith a sound and complete axiomatization. The contribution is that it is\npossible to reason about properties that involve several components, even in\nthe absence of a global clock. Then, we define the Distributed States Temporal\nLogic (DSTL) by introducing temporal operators a' la Unity. We support our\nproposal by working out a pair of examples: a simple secure communication\nsystem, and an algorithm for distributed leader election.\n  The motivation for this work is that the existing logics for distributed\nsystems do not have the right expressive power to reason on the systems\nbehaviour, when the communication is based on asynchronous message passing. On\nthe other side, asynchronous communication is the most used abstraction when\nmodelling global applications."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0304046v1", 
    "other_authors": [
        "Carlo Montangero", 
        "Laura Semini"
    ], 
    "lead_author": "Laura Semini", 
    "arxiv-id": "cs/0304046v1", 
    "title": "Distributed States Temporal Logic", 
    "publish": "2003-04-30T18:54:59Z", 
    "summary": "We introduce a temporal logic to reason on global applications in an\nasynchronous setting. First, we define the Distributed States Logic (DSL), a\nmodal logic for localities that embeds the local theories of each component\ninto a theory of the distributed states of the system. We provide the logic\nwith a sound and complete axiomatization. The contribution is that it is\npossible to reason about properties that involve several components, even in\nthe absence of a global clock. Then, we define the Distributed States Temporal\nLogic (DSTL) by introducing temporal operators a' la Unity. We support our\nproposal by working out a pair of examples: a simple secure communication\nsystem, and an algorithm for distributed leader election.\n  The motivation for this work is that the existing logics for distributed\nsystems do not have the right expressive power to reason on the systems\nbehaviour, when the communication is based on asynchronous message passing. On\nthe other side, asynchronous communication is the most used abstraction when\nmodelling global applications."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305007v1", 
    "other_authors": [
        "C. A. Johnson"
    ], 
    "lead_author": "C. A. Johnson", 
    "arxiv-id": "cs/0305007v1", 
    "title": "Computing only minimal answers in disjunctive deductive databases", 
    "publish": "2003-05-13T08:27:45Z", 
    "summary": "A method is presented for computing minimal answers in disjunctive deductive\ndatabases under the disjunctive stable model semantics. Such answers are\nconstructed by repeatedly extending partial answers. Our method is complete (in\nthat every minimal answer can be computed) and does not admit redundancy (in\nthe sense that every partial answer generated can be extended to a minimal\nanswer), whence no non-minimal answer is generated. For stratified databases,\nthe method does not (necessarily) require the computation of models of the\ndatabase in their entirety. Compilation is proposed as a tool by which problems\nrelating to computational efficiency and the non-existence of disjunctive\nstable models can be overcome. The extension of our method to other semantics\nis also considered."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305011v1", 
    "other_authors": [
        "Paolo Coppola", 
        "Simone Martini"
    ], 
    "lead_author": "Paolo Coppola", 
    "arxiv-id": "cs/0305011v1", 
    "title": "Optimizing Optimal Reduction: A Type Inference Algorithm for Elementary   Affine Logic", 
    "publish": "2003-05-15T10:46:00Z", 
    "summary": "We present a type inference algorithm for lambda-terms in Elementary Affine\nLogic using linear constraints. We prove that the algorithm is correct and\ncomplete."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305011v1", 
    "other_authors": [
        "Paolo Coppola", 
        "Simone Martini"
    ], 
    "lead_author": "Paolo Coppola", 
    "arxiv-id": "cs/0305011v1", 
    "title": "Optimizing Optimal Reduction: A Type Inference Algorithm for Elementary   Affine Logic", 
    "publish": "2003-05-15T10:46:00Z", 
    "summary": "We present a type inference algorithm for lambda-terms in Elementary Affine\nLogic using linear constraints. We prove that the algorithm is correct and\ncomplete."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305011v1", 
    "other_authors": [
        "Paolo Coppola", 
        "Simone Martini"
    ], 
    "lead_author": "Paolo Coppola", 
    "arxiv-id": "cs/0305011v1", 
    "title": "Optimizing Optimal Reduction: A Type Inference Algorithm for Elementary   Affine Logic", 
    "publish": "2003-05-15T10:46:00Z", 
    "summary": "We present a type inference algorithm for lambda-terms in Elementary Affine\nLogic using linear constraints. We prove that the algorithm is correct and\ncomplete."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305011v1", 
    "other_authors": [
        "Paolo Coppola", 
        "Simone Martini"
    ], 
    "lead_author": "Simone Martini", 
    "arxiv-id": "cs/0305011v1", 
    "title": "Optimizing Optimal Reduction: A Type Inference Algorithm for Elementary   Affine Logic", 
    "publish": "2003-05-15T10:46:00Z", 
    "summary": "We present a type inference algorithm for lambda-terms in Elementary Affine\nLogic using linear constraints. We prove that the algorithm is correct and\ncomplete."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305011v1", 
    "other_authors": [
        "Paolo Coppola", 
        "Simone Martini"
    ], 
    "lead_author": "Simone Martini", 
    "arxiv-id": "cs/0305011v1", 
    "title": "Optimizing Optimal Reduction: A Type Inference Algorithm for Elementary   Affine Logic", 
    "publish": "2003-05-15T10:46:00Z", 
    "summary": "We present a type inference algorithm for lambda-terms in Elementary Affine\nLogic using linear constraints. We prove that the algorithm is correct and\ncomplete."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305011v1", 
    "other_authors": [
        "Paolo Coppola", 
        "Simone Martini"
    ], 
    "lead_author": "Simone Martini", 
    "arxiv-id": "cs/0305011v1", 
    "title": "Optimizing Optimal Reduction: A Type Inference Algorithm for Elementary   Affine Logic", 
    "publish": "2003-05-15T10:46:00Z", 
    "summary": "We present a type inference algorithm for lambda-terms in Elementary Affine\nLogic using linear constraints. We prove that the algorithm is correct and\ncomplete."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305011v1", 
    "other_authors": [
        "Paolo Coppola", 
        "Simone Martini"
    ], 
    "lead_author": "Simone Martini", 
    "arxiv-id": "cs/0305011v1", 
    "title": "Optimizing Optimal Reduction: A Type Inference Algorithm for Elementary   Affine Logic", 
    "publish": "2003-05-15T10:46:00Z", 
    "summary": "We present a type inference algorithm for lambda-terms in Elementary Affine\nLogic using linear constraints. We prove that the algorithm is correct and\ncomplete."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305011v1", 
    "other_authors": [
        "Paolo Coppola", 
        "Simone Martini"
    ], 
    "lead_author": "Simone Martini", 
    "arxiv-id": "cs/0305011v1", 
    "title": "Optimizing Optimal Reduction: A Type Inference Algorithm for Elementary   Affine Logic", 
    "publish": "2003-05-15T10:46:00Z", 
    "summary": "We present a type inference algorithm for lambda-terms in Elementary Affine\nLogic using linear constraints. We prove that the algorithm is correct and\ncomplete."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305011v1", 
    "other_authors": [
        "Paolo Coppola", 
        "Simone Martini"
    ], 
    "lead_author": "Simone Martini", 
    "arxiv-id": "cs/0305011v1", 
    "title": "Optimizing Optimal Reduction: A Type Inference Algorithm for Elementary   Affine Logic", 
    "publish": "2003-05-15T10:46:00Z", 
    "summary": "We present a type inference algorithm for lambda-terms in Elementary Affine\nLogic using linear constraints. We prove that the algorithm is correct and\ncomplete."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305011v1", 
    "other_authors": [
        "Paolo Coppola", 
        "Simone Martini"
    ], 
    "lead_author": "Simone Martini", 
    "arxiv-id": "cs/0305011v1", 
    "title": "Optimizing Optimal Reduction: A Type Inference Algorithm for Elementary   Affine Logic", 
    "publish": "2003-05-15T10:46:00Z", 
    "summary": "We present a type inference algorithm for lambda-terms in Elementary Affine\nLogic using linear constraints. We prove that the algorithm is correct and\ncomplete."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305011v1", 
    "other_authors": [
        "Paolo Coppola", 
        "Simone Martini"
    ], 
    "lead_author": "Simone Martini", 
    "arxiv-id": "cs/0305011v1", 
    "title": "Optimizing Optimal Reduction: A Type Inference Algorithm for Elementary   Affine Logic", 
    "publish": "2003-05-15T10:46:00Z", 
    "summary": "We present a type inference algorithm for lambda-terms in Elementary Affine\nLogic using linear constraints. We prove that the algorithm is correct and\ncomplete."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305011v1", 
    "other_authors": [
        "Paolo Coppola", 
        "Simone Martini"
    ], 
    "lead_author": "Simone Martini", 
    "arxiv-id": "cs/0305011v1", 
    "title": "Optimizing Optimal Reduction: A Type Inference Algorithm for Elementary   Affine Logic", 
    "publish": "2003-05-15T10:46:00Z", 
    "summary": "We present a type inference algorithm for lambda-terms in Elementary Affine\nLogic using linear constraints. We prove that the algorithm is correct and\ncomplete."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305011v1", 
    "other_authors": [
        "Paolo Coppola", 
        "Simone Martini"
    ], 
    "lead_author": "Simone Martini", 
    "arxiv-id": "cs/0305011v1", 
    "title": "Optimizing Optimal Reduction: A Type Inference Algorithm for Elementary   Affine Logic", 
    "publish": "2003-05-15T10:46:00Z", 
    "summary": "We present a type inference algorithm for lambda-terms in Elementary Affine\nLogic using linear constraints. We prove that the algorithm is correct and\ncomplete."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305011v1", 
    "other_authors": [
        "Paolo Coppola", 
        "Simone Martini"
    ], 
    "lead_author": "Simone Martini", 
    "arxiv-id": "cs/0305011v1", 
    "title": "Optimizing Optimal Reduction: A Type Inference Algorithm for Elementary   Affine Logic", 
    "publish": "2003-05-15T10:46:00Z", 
    "summary": "We present a type inference algorithm for lambda-terms in Elementary Affine\nLogic using linear constraints. We prove that the algorithm is correct and\ncomplete."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305011v1", 
    "other_authors": [
        "Paolo Coppola", 
        "Simone Martini"
    ], 
    "lead_author": "Simone Martini", 
    "arxiv-id": "cs/0305011v1", 
    "title": "Optimizing Optimal Reduction: A Type Inference Algorithm for Elementary   Affine Logic", 
    "publish": "2003-05-15T10:46:00Z", 
    "summary": "We present a type inference algorithm for lambda-terms in Elementary Affine\nLogic using linear constraints. We prove that the algorithm is correct and\ncomplete."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305011v1", 
    "other_authors": [
        "Paolo Coppola", 
        "Simone Martini"
    ], 
    "lead_author": "Simone Martini", 
    "arxiv-id": "cs/0305011v1", 
    "title": "Optimizing Optimal Reduction: A Type Inference Algorithm for Elementary   Affine Logic", 
    "publish": "2003-05-15T10:46:00Z", 
    "summary": "We present a type inference algorithm for lambda-terms in Elementary Affine\nLogic using linear constraints. We prove that the algorithm is correct and\ncomplete."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305011v1", 
    "other_authors": [
        "Paolo Coppola", 
        "Simone Martini"
    ], 
    "lead_author": "Simone Martini", 
    "arxiv-id": "cs/0305011v1", 
    "title": "Optimizing Optimal Reduction: A Type Inference Algorithm for Elementary   Affine Logic", 
    "publish": "2003-05-15T10:46:00Z", 
    "summary": "We present a type inference algorithm for lambda-terms in Elementary Affine\nLogic using linear constraints. We prove that the algorithm is correct and\ncomplete."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305011v1", 
    "other_authors": [
        "Paolo Coppola", 
        "Simone Martini"
    ], 
    "lead_author": "Simone Martini", 
    "arxiv-id": "cs/0305011v1", 
    "title": "Optimizing Optimal Reduction: A Type Inference Algorithm for Elementary   Affine Logic", 
    "publish": "2003-05-15T10:46:00Z", 
    "summary": "We present a type inference algorithm for lambda-terms in Elementary Affine\nLogic using linear constraints. We prove that the algorithm is correct and\ncomplete."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305011v1", 
    "other_authors": [
        "Paolo Coppola", 
        "Simone Martini"
    ], 
    "lead_author": "Simone Martini", 
    "arxiv-id": "cs/0305011v1", 
    "title": "Optimizing Optimal Reduction: A Type Inference Algorithm for Elementary   Affine Logic", 
    "publish": "2003-05-15T10:46:00Z", 
    "summary": "We present a type inference algorithm for lambda-terms in Elementary Affine\nLogic using linear constraints. We prove that the algorithm is correct and\ncomplete."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305011v1", 
    "other_authors": [
        "Paolo Coppola", 
        "Simone Martini"
    ], 
    "lead_author": "Simone Martini", 
    "arxiv-id": "cs/0305011v1", 
    "title": "Optimizing Optimal Reduction: A Type Inference Algorithm for Elementary   Affine Logic", 
    "publish": "2003-05-15T10:46:00Z", 
    "summary": "We present a type inference algorithm for lambda-terms in Elementary Affine\nLogic using linear constraints. We prove that the algorithm is correct and\ncomplete."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305011v1", 
    "other_authors": [
        "Paolo Coppola", 
        "Simone Martini"
    ], 
    "lead_author": "Simone Martini", 
    "arxiv-id": "cs/0305011v1", 
    "title": "Optimizing Optimal Reduction: A Type Inference Algorithm for Elementary   Affine Logic", 
    "publish": "2003-05-15T10:46:00Z", 
    "summary": "We present a type inference algorithm for lambda-terms in Elementary Affine\nLogic using linear constraints. We prove that the algorithm is correct and\ncomplete."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305011v1", 
    "other_authors": [
        "Paolo Coppola", 
        "Simone Martini"
    ], 
    "lead_author": "Simone Martini", 
    "arxiv-id": "cs/0305011v1", 
    "title": "Optimizing Optimal Reduction: A Type Inference Algorithm for Elementary   Affine Logic", 
    "publish": "2003-05-15T10:46:00Z", 
    "summary": "We present a type inference algorithm for lambda-terms in Elementary Affine\nLogic using linear constraints. We prove that the algorithm is correct and\ncomplete."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305011v1", 
    "other_authors": [
        "Paolo Coppola", 
        "Simone Martini"
    ], 
    "lead_author": "Simone Martini", 
    "arxiv-id": "cs/0305011v1", 
    "title": "Optimizing Optimal Reduction: A Type Inference Algorithm for Elementary   Affine Logic", 
    "publish": "2003-05-15T10:46:00Z", 
    "summary": "We present a type inference algorithm for lambda-terms in Elementary Affine\nLogic using linear constraints. We prove that the algorithm is correct and\ncomplete."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305011v1", 
    "other_authors": [
        "Paolo Coppola", 
        "Simone Martini"
    ], 
    "lead_author": "Simone Martini", 
    "arxiv-id": "cs/0305011v1", 
    "title": "Optimizing Optimal Reduction: A Type Inference Algorithm for Elementary   Affine Logic", 
    "publish": "2003-05-15T10:46:00Z", 
    "summary": "We present a type inference algorithm for lambda-terms in Elementary Affine\nLogic using linear constraints. We prove that the algorithm is correct and\ncomplete."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Mauricio Osorio", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Juan Antonio Navarro", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Jose Arrazola", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Jose Arrazola", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Jose Arrazola", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Jose Arrazola", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Jose Arrazola", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Jose Arrazola", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Jose Arrazola", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Jose Arrazola", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Jose Arrazola", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Jose Arrazola", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Jose Arrazola", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0305046v1", 
    "other_authors": [
        "Mauricio Osorio", 
        "Juan Antonio Navarro", 
        "Jose Arrazola"
    ], 
    "lead_author": "Jose Arrazola", 
    "arxiv-id": "cs/0305046v1", 
    "title": "Applications of Intuitionistic Logic in Answer Set Programming", 
    "publish": "2003-05-27T16:40:30Z", 
    "summary": "We present some applications of intermediate logics in the field of Answer\nSet Programming (ASP). A brief, but comprehensive introduction to the answer\nset semantics, intuitionistic and other intermediate logics is given. Some\nequivalence notions and their applications are discussed. Some results on\nintermediate logics are shown, and applied later to prove properties of answer\nsets. A characterization of answer sets for logic programs with nested\nexpressions is provided in terms of intuitionistic provability, generalizing a\nrecent result given by Pearce.\n  It is known that the answer set semantics for logic programs with nested\nexpressions may select non-minimal models. Minimal models can be very important\nin some applications, therefore we studied them; in particular we obtain a\ncharacterization, in terms of intuitionistic logic, of answer sets which are\nalso minimal models. We show that the logic G3 characterizes the notion of\nstrong equivalence between programs under the semantic induced by these models.\nFinally we discuss possible applications and consequences of our results. They\nclearly state interesting links between ASP and intermediate logics, which\nmight bring research in these two areas together."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Anatoly Degtyarev", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Anatoly Degtyarev", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Anatoly Degtyarev", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Anatoly Degtyarev", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Anatoly Degtyarev", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Anatoly Degtyarev", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Anatoly Degtyarev", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Anatoly Degtyarev", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Anatoly Degtyarev", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Anatoly Degtyarev", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Anatoly Degtyarev", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Anatoly Degtyarev", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Anatoly Degtyarev", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Anatoly Degtyarev", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Anatoly Degtyarev", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Anatoly Degtyarev", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Anatoly Degtyarev", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Anatoly Degtyarev", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Anatoly Degtyarev", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Anatoly Degtyarev", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Anatoly Degtyarev", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Anatoly Degtyarev", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Anatoly Degtyarev", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Anatoly Degtyarev", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Anatoly Degtyarev", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Anatoly Degtyarev", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Anatoly Degtyarev", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Anatoly Degtyarev", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Anatoly Degtyarev", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Anatoly Degtyarev", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Anatoly Degtyarev", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Anatoly Degtyarev", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Anatoly Degtyarev", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Anatoly Degtyarev", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Anatoly Degtyarev", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Anatoly Degtyarev", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Anatoly Degtyarev", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Anatoly Degtyarev", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Anatoly Degtyarev", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Anatoly Degtyarev", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Anatoly Degtyarev", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Anatoly Degtyarev", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Anatoly Degtyarev", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Anatoly Degtyarev", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Anatoly Degtyarev", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Anatoly Degtyarev", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Anatoly Degtyarev", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Anatoly Degtyarev", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Michael Fisher", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Boris Konev", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Boris Konev", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Boris Konev", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Boris Konev", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306041v1", 
    "other_authors": [
        "Anatoly Degtyarev", 
        "Michael Fisher", 
        "Boris Konev"
    ], 
    "lead_author": "Boris Konev", 
    "arxiv-id": "cs/0306041v1", 
    "title": "Monodic temporal resolution", 
    "publish": "2003-06-10T10:02:03Z", 
    "summary": "Until recently, First-Order Temporal Logic (FOTL) has been little understood.\nWhile it is well known that the full logic has no finite axiomatisation, a more\ndetailed analysis of fragments of the logic was not previously available.\nHowever, a breakthrough by Hodkinson et.al., identifying a finitely\naxiomatisable fragment, termed the monodic fragment, has led to improved\nunderstanding of FOTL. Yet, in order to utilise these theoretical advances, it\nis important to have appropriate proof techniques for the monodic fragment.\n  In this paper, we modify and extend the clausal temporal resolution\ntechnique, originally developed for propositional temporal logics, to enable\nits use in such monodic fragments. We develop a specific normal form for\nformulae in FOTL, and provide a complete resolution calculus for formulae in\nthis form. Not only is this clausal resolution technique useful as a practical\nproof technique for certain monodic classes, but the use of this approach\nprovides us with increased understanding of the monodic fragment. In\nparticular, we here show how several features of monodic FOTL are established\nas corollaries of the completeness result for the clausal temporal resolution\nmethod. These include definitions of new decidable monodic classes,\nsimplification of existing monodic classes by reductions, and completeness of\nclausal temporal resolution in the case of monodic logics with expanding\ndomains, a case with much significance in both theory and practice."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306117v2", 
    "other_authors": [
        "Stephane Demri", 
        "Hans de Nivelle"
    ], 
    "lead_author": "Stephane Demri", 
    "arxiv-id": "cs/0306117v2", 
    "title": "Deciding regular grammar logics with converse through first-order logic", 
    "publish": "2003-06-20T08:26:57Z", 
    "summary": "We provide a simple translation of the satisfiability problem for regular\ngrammar logics with converse into GF2, which is the intersection of the guarded\nfragment and the 2-variable fragment of first-order logic. This translation is\ntheoretically interesting because it translates modal logics with certain frame\nconditions into first-order logic, without explicitly expressing the frame\nconditions.\n  A consequence of the translation is that the general satisfiability problem\nfor regular grammar logics with converse is in EXPTIME. This extends a previous\nresult of the first author for grammar logics without converse. Using the same\nmethod, we show how some other modal logics can be naturally translated into\nGF2, including nominal tense logics and intuitionistic logic.\n  In our view, the results in this paper show that the natural first-order\nfragment corresponding to regular grammar logics is simply GF2 without extra\nmachinery such as fixed point-operators."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306117v2", 
    "other_authors": [
        "Stephane Demri", 
        "Hans de Nivelle"
    ], 
    "lead_author": "Stephane Demri", 
    "arxiv-id": "cs/0306117v2", 
    "title": "Deciding regular grammar logics with converse through first-order logic", 
    "publish": "2003-06-20T08:26:57Z", 
    "summary": "We provide a simple translation of the satisfiability problem for regular\ngrammar logics with converse into GF2, which is the intersection of the guarded\nfragment and the 2-variable fragment of first-order logic. This translation is\ntheoretically interesting because it translates modal logics with certain frame\nconditions into first-order logic, without explicitly expressing the frame\nconditions.\n  A consequence of the translation is that the general satisfiability problem\nfor regular grammar logics with converse is in EXPTIME. This extends a previous\nresult of the first author for grammar logics without converse. Using the same\nmethod, we show how some other modal logics can be naturally translated into\nGF2, including nominal tense logics and intuitionistic logic.\n  In our view, the results in this paper show that the natural first-order\nfragment corresponding to regular grammar logics is simply GF2 without extra\nmachinery such as fixed point-operators."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306117v2", 
    "other_authors": [
        "Stephane Demri", 
        "Hans de Nivelle"
    ], 
    "lead_author": "Stephane Demri", 
    "arxiv-id": "cs/0306117v2", 
    "title": "Deciding regular grammar logics with converse through first-order logic", 
    "publish": "2003-06-20T08:26:57Z", 
    "summary": "We provide a simple translation of the satisfiability problem for regular\ngrammar logics with converse into GF2, which is the intersection of the guarded\nfragment and the 2-variable fragment of first-order logic. This translation is\ntheoretically interesting because it translates modal logics with certain frame\nconditions into first-order logic, without explicitly expressing the frame\nconditions.\n  A consequence of the translation is that the general satisfiability problem\nfor regular grammar logics with converse is in EXPTIME. This extends a previous\nresult of the first author for grammar logics without converse. Using the same\nmethod, we show how some other modal logics can be naturally translated into\nGF2, including nominal tense logics and intuitionistic logic.\n  In our view, the results in this paper show that the natural first-order\nfragment corresponding to regular grammar logics is simply GF2 without extra\nmachinery such as fixed point-operators."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306117v2", 
    "other_authors": [
        "Stephane Demri", 
        "Hans de Nivelle"
    ], 
    "lead_author": "Stephane Demri", 
    "arxiv-id": "cs/0306117v2", 
    "title": "Deciding regular grammar logics with converse through first-order logic", 
    "publish": "2003-06-20T08:26:57Z", 
    "summary": "We provide a simple translation of the satisfiability problem for regular\ngrammar logics with converse into GF2, which is the intersection of the guarded\nfragment and the 2-variable fragment of first-order logic. This translation is\ntheoretically interesting because it translates modal logics with certain frame\nconditions into first-order logic, without explicitly expressing the frame\nconditions.\n  A consequence of the translation is that the general satisfiability problem\nfor regular grammar logics with converse is in EXPTIME. This extends a previous\nresult of the first author for grammar logics without converse. Using the same\nmethod, we show how some other modal logics can be naturally translated into\nGF2, including nominal tense logics and intuitionistic logic.\n  In our view, the results in this paper show that the natural first-order\nfragment corresponding to regular grammar logics is simply GF2 without extra\nmachinery such as fixed point-operators."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306117v2", 
    "other_authors": [
        "Stephane Demri", 
        "Hans de Nivelle"
    ], 
    "lead_author": "Stephane Demri", 
    "arxiv-id": "cs/0306117v2", 
    "title": "Deciding regular grammar logics with converse through first-order logic", 
    "publish": "2003-06-20T08:26:57Z", 
    "summary": "We provide a simple translation of the satisfiability problem for regular\ngrammar logics with converse into GF2, which is the intersection of the guarded\nfragment and the 2-variable fragment of first-order logic. This translation is\ntheoretically interesting because it translates modal logics with certain frame\nconditions into first-order logic, without explicitly expressing the frame\nconditions.\n  A consequence of the translation is that the general satisfiability problem\nfor regular grammar logics with converse is in EXPTIME. This extends a previous\nresult of the first author for grammar logics without converse. Using the same\nmethod, we show how some other modal logics can be naturally translated into\nGF2, including nominal tense logics and intuitionistic logic.\n  In our view, the results in this paper show that the natural first-order\nfragment corresponding to regular grammar logics is simply GF2 without extra\nmachinery such as fixed point-operators."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306117v2", 
    "other_authors": [
        "Stephane Demri", 
        "Hans de Nivelle"
    ], 
    "lead_author": "Stephane Demri", 
    "arxiv-id": "cs/0306117v2", 
    "title": "Deciding regular grammar logics with converse through first-order logic", 
    "publish": "2003-06-20T08:26:57Z", 
    "summary": "We provide a simple translation of the satisfiability problem for regular\ngrammar logics with converse into GF2, which is the intersection of the guarded\nfragment and the 2-variable fragment of first-order logic. This translation is\ntheoretically interesting because it translates modal logics with certain frame\nconditions into first-order logic, without explicitly expressing the frame\nconditions.\n  A consequence of the translation is that the general satisfiability problem\nfor regular grammar logics with converse is in EXPTIME. This extends a previous\nresult of the first author for grammar logics without converse. Using the same\nmethod, we show how some other modal logics can be naturally translated into\nGF2, including nominal tense logics and intuitionistic logic.\n  In our view, the results in this paper show that the natural first-order\nfragment corresponding to regular grammar logics is simply GF2 without extra\nmachinery such as fixed point-operators."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306117v2", 
    "other_authors": [
        "Stephane Demri", 
        "Hans de Nivelle"
    ], 
    "lead_author": "Stephane Demri", 
    "arxiv-id": "cs/0306117v2", 
    "title": "Deciding regular grammar logics with converse through first-order logic", 
    "publish": "2003-06-20T08:26:57Z", 
    "summary": "We provide a simple translation of the satisfiability problem for regular\ngrammar logics with converse into GF2, which is the intersection of the guarded\nfragment and the 2-variable fragment of first-order logic. This translation is\ntheoretically interesting because it translates modal logics with certain frame\nconditions into first-order logic, without explicitly expressing the frame\nconditions.\n  A consequence of the translation is that the general satisfiability problem\nfor regular grammar logics with converse is in EXPTIME. This extends a previous\nresult of the first author for grammar logics without converse. Using the same\nmethod, we show how some other modal logics can be naturally translated into\nGF2, including nominal tense logics and intuitionistic logic.\n  In our view, the results in this paper show that the natural first-order\nfragment corresponding to regular grammar logics is simply GF2 without extra\nmachinery such as fixed point-operators."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306117v2", 
    "other_authors": [
        "Stephane Demri", 
        "Hans de Nivelle"
    ], 
    "lead_author": "Stephane Demri", 
    "arxiv-id": "cs/0306117v2", 
    "title": "Deciding regular grammar logics with converse through first-order logic", 
    "publish": "2003-06-20T08:26:57Z", 
    "summary": "We provide a simple translation of the satisfiability problem for regular\ngrammar logics with converse into GF2, which is the intersection of the guarded\nfragment and the 2-variable fragment of first-order logic. This translation is\ntheoretically interesting because it translates modal logics with certain frame\nconditions into first-order logic, without explicitly expressing the frame\nconditions.\n  A consequence of the translation is that the general satisfiability problem\nfor regular grammar logics with converse is in EXPTIME. This extends a previous\nresult of the first author for grammar logics without converse. Using the same\nmethod, we show how some other modal logics can be naturally translated into\nGF2, including nominal tense logics and intuitionistic logic.\n  In our view, the results in this paper show that the natural first-order\nfragment corresponding to regular grammar logics is simply GF2 without extra\nmachinery such as fixed point-operators."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306117v2", 
    "other_authors": [
        "Stephane Demri", 
        "Hans de Nivelle"
    ], 
    "lead_author": "Stephane Demri", 
    "arxiv-id": "cs/0306117v2", 
    "title": "Deciding regular grammar logics with converse through first-order logic", 
    "publish": "2003-06-20T08:26:57Z", 
    "summary": "We provide a simple translation of the satisfiability problem for regular\ngrammar logics with converse into GF2, which is the intersection of the guarded\nfragment and the 2-variable fragment of first-order logic. This translation is\ntheoretically interesting because it translates modal logics with certain frame\nconditions into first-order logic, without explicitly expressing the frame\nconditions.\n  A consequence of the translation is that the general satisfiability problem\nfor regular grammar logics with converse is in EXPTIME. This extends a previous\nresult of the first author for grammar logics without converse. Using the same\nmethod, we show how some other modal logics can be naturally translated into\nGF2, including nominal tense logics and intuitionistic logic.\n  In our view, the results in this paper show that the natural first-order\nfragment corresponding to regular grammar logics is simply GF2 without extra\nmachinery such as fixed point-operators."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306117v2", 
    "other_authors": [
        "Stephane Demri", 
        "Hans de Nivelle"
    ], 
    "lead_author": "Stephane Demri", 
    "arxiv-id": "cs/0306117v2", 
    "title": "Deciding regular grammar logics with converse through first-order logic", 
    "publish": "2003-06-20T08:26:57Z", 
    "summary": "We provide a simple translation of the satisfiability problem for regular\ngrammar logics with converse into GF2, which is the intersection of the guarded\nfragment and the 2-variable fragment of first-order logic. This translation is\ntheoretically interesting because it translates modal logics with certain frame\nconditions into first-order logic, without explicitly expressing the frame\nconditions.\n  A consequence of the translation is that the general satisfiability problem\nfor regular grammar logics with converse is in EXPTIME. This extends a previous\nresult of the first author for grammar logics without converse. Using the same\nmethod, we show how some other modal logics can be naturally translated into\nGF2, including nominal tense logics and intuitionistic logic.\n  In our view, the results in this paper show that the natural first-order\nfragment corresponding to regular grammar logics is simply GF2 without extra\nmachinery such as fixed point-operators."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306117v2", 
    "other_authors": [
        "Stephane Demri", 
        "Hans de Nivelle"
    ], 
    "lead_author": "Stephane Demri", 
    "arxiv-id": "cs/0306117v2", 
    "title": "Deciding regular grammar logics with converse through first-order logic", 
    "publish": "2003-06-20T08:26:57Z", 
    "summary": "We provide a simple translation of the satisfiability problem for regular\ngrammar logics with converse into GF2, which is the intersection of the guarded\nfragment and the 2-variable fragment of first-order logic. This translation is\ntheoretically interesting because it translates modal logics with certain frame\nconditions into first-order logic, without explicitly expressing the frame\nconditions.\n  A consequence of the translation is that the general satisfiability problem\nfor regular grammar logics with converse is in EXPTIME. This extends a previous\nresult of the first author for grammar logics without converse. Using the same\nmethod, we show how some other modal logics can be naturally translated into\nGF2, including nominal tense logics and intuitionistic logic.\n  In our view, the results in this paper show that the natural first-order\nfragment corresponding to regular grammar logics is simply GF2 without extra\nmachinery such as fixed point-operators."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306117v2", 
    "other_authors": [
        "Stephane Demri", 
        "Hans de Nivelle"
    ], 
    "lead_author": "Stephane Demri", 
    "arxiv-id": "cs/0306117v2", 
    "title": "Deciding regular grammar logics with converse through first-order logic", 
    "publish": "2003-06-20T08:26:57Z", 
    "summary": "We provide a simple translation of the satisfiability problem for regular\ngrammar logics with converse into GF2, which is the intersection of the guarded\nfragment and the 2-variable fragment of first-order logic. This translation is\ntheoretically interesting because it translates modal logics with certain frame\nconditions into first-order logic, without explicitly expressing the frame\nconditions.\n  A consequence of the translation is that the general satisfiability problem\nfor regular grammar logics with converse is in EXPTIME. This extends a previous\nresult of the first author for grammar logics without converse. Using the same\nmethod, we show how some other modal logics can be naturally translated into\nGF2, including nominal tense logics and intuitionistic logic.\n  In our view, the results in this paper show that the natural first-order\nfragment corresponding to regular grammar logics is simply GF2 without extra\nmachinery such as fixed point-operators."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "J. Adamek", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "J. Adamek", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "J. Adamek", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "J. Adamek", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "J. Adamek", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "J. Adamek", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "J. Adamek", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "J. Adamek", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "J. Adamek", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "J. Adamek", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "J. Adamek", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "J. Adamek", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "J. Adamek", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "J. Adamek", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "J. Adamek", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "J. Adamek", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "J. Adamek", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "J. Adamek", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "J. Adamek", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "J. Adamek", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "J. Adamek", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "J. Adamek", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "J. Adamek", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "J. Adamek", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "J. Adamek", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "J. Adamek", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "J. Adamek", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "J. Adamek", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "J. Adamek", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "J. Adamek", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "J. Adamek", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "J. Adamek", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "J. Adamek", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "J. Adamek", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "J. Adamek", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "J. Adamek", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "J. Adamek", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "J. Adamek", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "J. Adamek", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "J. Adamek", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "S. Milius", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "S. Milius", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "S. Milius", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "S. Milius", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "S. Milius", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "S. Milius", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "S. Milius", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "S. Milius", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "S. Milius", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "S. Milius", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "S. Milius", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "S. Milius", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "S. Milius", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "S. Milius", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "S. Milius", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "S. Milius", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "S. Milius", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "S. Milius", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "S. Milius", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "S. Milius", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "S. Milius", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "S. Milius", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "S. Milius", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "S. Milius", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "S. Milius", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "J. Velebil", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "J. Velebil", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "J. Velebil", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "J. Velebil", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "J. Velebil", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "J. Velebil", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "J. Velebil", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "J. Velebil", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "J. Velebil", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0306118v1", 
    "other_authors": [
        "J. Adamek", 
        "S. Milius", 
        "J. Velebil"
    ], 
    "lead_author": "J. Velebil", 
    "arxiv-id": "cs/0306118v1", 
    "title": "On coalgebra based on classes", 
    "publish": "2003-06-20T09:43:58Z", 
    "summary": "Every endofunctor of the category of classes is proved to be set-based in the\nsense of Aczel and Mendler, therefore, it has a final coalgebra. Other basic\nproperties of these endofunctors are proved, e.g. the existence of a free\ncompletely iterative theory."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0307067v1", 
    "other_authors": [
        "C. F. M. Vermeulen"
    ], 
    "lead_author": "C. F. M. Vermeulen", 
    "arxiv-id": "cs/0307067v1", 
    "title": "Sound search in a denotational semantics for first order logic", 
    "publish": "2003-07-30T13:57:55Z", 
    "summary": "In this paper we adapt the definitions and results from Apt and Vermeulen on\n`First order logic as a constraint programming language' (in: Proceedings of\nLPAR2001, Baaz and Voronkov (eds.), Springer LNAI 2514) to include important\nideas about search and choice into the system. We give motivating examples.\nThen we set up denotational semantics for first order logic as follows: the\nsemantic universe includes states that consist of two components: a\nsubstitution, which can be seen as the computed answer; and a constraint\nsatisfaction problem, which can be seen as the residue of the original problem,\nyet to be handled by constraint programming. The interaction between these\ncomponents is regulated by an operator called: infer. In this paper we regard\ninfer as an operator on sets of states to enable us to analyze ideas about\nsearch among states and choice between states.\n  The precise adaptations of definitions and results are able to deal with the\nexamples and we show that, given several reasonable conditions, the new\ndefinitions ensure soundness of the system with respect to the standard\ninterpretation of first order logic. In this way the `reasonable conditions'\ncan be read as conditions for sound search.\n  We indicate briefly how to investigate efficiency of search in future\nresearch."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0307067v1", 
    "other_authors": [
        "C. F. M. Vermeulen"
    ], 
    "lead_author": "C. F. M. Vermeulen", 
    "arxiv-id": "cs/0307067v1", 
    "title": "Sound search in a denotational semantics for first order logic", 
    "publish": "2003-07-30T13:57:55Z", 
    "summary": "In this paper we adapt the definitions and results from Apt and Vermeulen on\n`First order logic as a constraint programming language' (in: Proceedings of\nLPAR2001, Baaz and Voronkov (eds.), Springer LNAI 2514) to include important\nideas about search and choice into the system. We give motivating examples.\nThen we set up denotational semantics for first order logic as follows: the\nsemantic universe includes states that consist of two components: a\nsubstitution, which can be seen as the computed answer; and a constraint\nsatisfaction problem, which can be seen as the residue of the original problem,\nyet to be handled by constraint programming. The interaction between these\ncomponents is regulated by an operator called: infer. In this paper we regard\ninfer as an operator on sets of states to enable us to analyze ideas about\nsearch among states and choice between states.\n  The precise adaptations of definitions and results are able to deal with the\nexamples and we show that, given several reasonable conditions, the new\ndefinitions ensure soundness of the system with respect to the standard\ninterpretation of first order logic. In this way the `reasonable conditions'\ncan be read as conditions for sound search.\n  We indicate briefly how to investigate efficiency of search in future\nresearch."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0307067v1", 
    "other_authors": [
        "C. F. M. Vermeulen"
    ], 
    "lead_author": "C. F. M. Vermeulen", 
    "arxiv-id": "cs/0307067v1", 
    "title": "Sound search in a denotational semantics for first order logic", 
    "publish": "2003-07-30T13:57:55Z", 
    "summary": "In this paper we adapt the definitions and results from Apt and Vermeulen on\n`First order logic as a constraint programming language' (in: Proceedings of\nLPAR2001, Baaz and Voronkov (eds.), Springer LNAI 2514) to include important\nideas about search and choice into the system. We give motivating examples.\nThen we set up denotational semantics for first order logic as follows: the\nsemantic universe includes states that consist of two components: a\nsubstitution, which can be seen as the computed answer; and a constraint\nsatisfaction problem, which can be seen as the residue of the original problem,\nyet to be handled by constraint programming. The interaction between these\ncomponents is regulated by an operator called: infer. In this paper we regard\ninfer as an operator on sets of states to enable us to analyze ideas about\nsearch among states and choice between states.\n  The precise adaptations of definitions and results are able to deal with the\nexamples and we show that, given several reasonable conditions, the new\ndefinitions ensure soundness of the system with respect to the standard\ninterpretation of first order logic. In this way the `reasonable conditions'\ncan be read as conditions for sound search.\n  We indicate briefly how to investigate efficiency of search in future\nresearch."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0307067v1", 
    "other_authors": [
        "C. F. M. Vermeulen"
    ], 
    "lead_author": "C. F. M. Vermeulen", 
    "arxiv-id": "cs/0307067v1", 
    "title": "Sound search in a denotational semantics for first order logic", 
    "publish": "2003-07-30T13:57:55Z", 
    "summary": "In this paper we adapt the definitions and results from Apt and Vermeulen on\n`First order logic as a constraint programming language' (in: Proceedings of\nLPAR2001, Baaz and Voronkov (eds.), Springer LNAI 2514) to include important\nideas about search and choice into the system. We give motivating examples.\nThen we set up denotational semantics for first order logic as follows: the\nsemantic universe includes states that consist of two components: a\nsubstitution, which can be seen as the computed answer; and a constraint\nsatisfaction problem, which can be seen as the residue of the original problem,\nyet to be handled by constraint programming. The interaction between these\ncomponents is regulated by an operator called: infer. In this paper we regard\ninfer as an operator on sets of states to enable us to analyze ideas about\nsearch among states and choice between states.\n  The precise adaptations of definitions and results are able to deal with the\nexamples and we show that, given several reasonable conditions, the new\ndefinitions ensure soundness of the system with respect to the standard\ninterpretation of first order logic. In this way the `reasonable conditions'\ncan be read as conditions for sound search.\n  We indicate briefly how to investigate efficiency of search in future\nresearch."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0307067v1", 
    "other_authors": [
        "C. F. M. Vermeulen"
    ], 
    "lead_author": "C. F. M. Vermeulen", 
    "arxiv-id": "cs/0307067v1", 
    "title": "Sound search in a denotational semantics for first order logic", 
    "publish": "2003-07-30T13:57:55Z", 
    "summary": "In this paper we adapt the definitions and results from Apt and Vermeulen on\n`First order logic as a constraint programming language' (in: Proceedings of\nLPAR2001, Baaz and Voronkov (eds.), Springer LNAI 2514) to include important\nideas about search and choice into the system. We give motivating examples.\nThen we set up denotational semantics for first order logic as follows: the\nsemantic universe includes states that consist of two components: a\nsubstitution, which can be seen as the computed answer; and a constraint\nsatisfaction problem, which can be seen as the residue of the original problem,\nyet to be handled by constraint programming. The interaction between these\ncomponents is regulated by an operator called: infer. In this paper we regard\ninfer as an operator on sets of states to enable us to analyze ideas about\nsearch among states and choice between states.\n  The precise adaptations of definitions and results are able to deal with the\nexamples and we show that, given several reasonable conditions, the new\ndefinitions ensure soundness of the system with respect to the standard\ninterpretation of first order logic. In this way the `reasonable conditions'\ncan be read as conditions for sound search.\n  We indicate briefly how to investigate efficiency of search in future\nresearch."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0307067v1", 
    "other_authors": [
        "C. F. M. Vermeulen"
    ], 
    "lead_author": "C. F. M. Vermeulen", 
    "arxiv-id": "cs/0307067v1", 
    "title": "Sound search in a denotational semantics for first order logic", 
    "publish": "2003-07-30T13:57:55Z", 
    "summary": "In this paper we adapt the definitions and results from Apt and Vermeulen on\n`First order logic as a constraint programming language' (in: Proceedings of\nLPAR2001, Baaz and Voronkov (eds.), Springer LNAI 2514) to include important\nideas about search and choice into the system. We give motivating examples.\nThen we set up denotational semantics for first order logic as follows: the\nsemantic universe includes states that consist of two components: a\nsubstitution, which can be seen as the computed answer; and a constraint\nsatisfaction problem, which can be seen as the residue of the original problem,\nyet to be handled by constraint programming. The interaction between these\ncomponents is regulated by an operator called: infer. In this paper we regard\ninfer as an operator on sets of states to enable us to analyze ideas about\nsearch among states and choice between states.\n  The precise adaptations of definitions and results are able to deal with the\nexamples and we show that, given several reasonable conditions, the new\ndefinitions ensure soundness of the system with respect to the standard\ninterpretation of first order logic. In this way the `reasonable conditions'\ncan be read as conditions for sound search.\n  We indicate briefly how to investigate efficiency of search in future\nresearch."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0307067v1", 
    "other_authors": [
        "C. F. M. Vermeulen"
    ], 
    "lead_author": "C. F. M. Vermeulen", 
    "arxiv-id": "cs/0307067v1", 
    "title": "Sound search in a denotational semantics for first order logic", 
    "publish": "2003-07-30T13:57:55Z", 
    "summary": "In this paper we adapt the definitions and results from Apt and Vermeulen on\n`First order logic as a constraint programming language' (in: Proceedings of\nLPAR2001, Baaz and Voronkov (eds.), Springer LNAI 2514) to include important\nideas about search and choice into the system. We give motivating examples.\nThen we set up denotational semantics for first order logic as follows: the\nsemantic universe includes states that consist of two components: a\nsubstitution, which can be seen as the computed answer; and a constraint\nsatisfaction problem, which can be seen as the residue of the original problem,\nyet to be handled by constraint programming. The interaction between these\ncomponents is regulated by an operator called: infer. In this paper we regard\ninfer as an operator on sets of states to enable us to analyze ideas about\nsearch among states and choice between states.\n  The precise adaptations of definitions and results are able to deal with the\nexamples and we show that, given several reasonable conditions, the new\ndefinitions ensure soundness of the system with respect to the standard\ninterpretation of first order logic. In this way the `reasonable conditions'\ncan be read as conditions for sound search.\n  We indicate briefly how to investigate efficiency of search in future\nresearch."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0307067v1", 
    "other_authors": [
        "C. F. M. Vermeulen"
    ], 
    "lead_author": "C. F. M. Vermeulen", 
    "arxiv-id": "cs/0307067v1", 
    "title": "Sound search in a denotational semantics for first order logic", 
    "publish": "2003-07-30T13:57:55Z", 
    "summary": "In this paper we adapt the definitions and results from Apt and Vermeulen on\n`First order logic as a constraint programming language' (in: Proceedings of\nLPAR2001, Baaz and Voronkov (eds.), Springer LNAI 2514) to include important\nideas about search and choice into the system. We give motivating examples.\nThen we set up denotational semantics for first order logic as follows: the\nsemantic universe includes states that consist of two components: a\nsubstitution, which can be seen as the computed answer; and a constraint\nsatisfaction problem, which can be seen as the residue of the original problem,\nyet to be handled by constraint programming. The interaction between these\ncomponents is regulated by an operator called: infer. In this paper we regard\ninfer as an operator on sets of states to enable us to analyze ideas about\nsearch among states and choice between states.\n  The precise adaptations of definitions and results are able to deal with the\nexamples and we show that, given several reasonable conditions, the new\ndefinitions ensure soundness of the system with respect to the standard\ninterpretation of first order logic. In this way the `reasonable conditions'\ncan be read as conditions for sound search.\n  We indicate briefly how to investigate efficiency of search in future\nresearch."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0307067v1", 
    "other_authors": [
        "C. F. M. Vermeulen"
    ], 
    "lead_author": "C. F. M. Vermeulen", 
    "arxiv-id": "cs/0307067v1", 
    "title": "Sound search in a denotational semantics for first order logic", 
    "publish": "2003-07-30T13:57:55Z", 
    "summary": "In this paper we adapt the definitions and results from Apt and Vermeulen on\n`First order logic as a constraint programming language' (in: Proceedings of\nLPAR2001, Baaz and Voronkov (eds.), Springer LNAI 2514) to include important\nideas about search and choice into the system. We give motivating examples.\nThen we set up denotational semantics for first order logic as follows: the\nsemantic universe includes states that consist of two components: a\nsubstitution, which can be seen as the computed answer; and a constraint\nsatisfaction problem, which can be seen as the residue of the original problem,\nyet to be handled by constraint programming. The interaction between these\ncomponents is regulated by an operator called: infer. In this paper we regard\ninfer as an operator on sets of states to enable us to analyze ideas about\nsearch among states and choice between states.\n  The precise adaptations of definitions and results are able to deal with the\nexamples and we show that, given several reasonable conditions, the new\ndefinitions ensure soundness of the system with respect to the standard\ninterpretation of first order logic. In this way the `reasonable conditions'\ncan be read as conditions for sound search.\n  We indicate briefly how to investigate efficiency of search in future\nresearch."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0308029v1", 
    "other_authors": [
        "Fabio Grandi"
    ], 
    "lead_author": "Fabio Grandi", 
    "arxiv-id": "cs/0308029v1", 
    "title": "On Decidability of Expressive Description Logics with Composition of   Roles in Number Restrictions", 
    "publish": "2003-08-19T12:50:02Z", 
    "summary": "Description Logics are knowledge representation formalisms which have been\nused in a wide range of application domains. Owing to their appealing\nexpressiveness, we consider in this paper extensions of the well-known concept\nlanguage ALC allowing for number restrictions on complex role expressions.\nThese have been first introduced by Baader and Sattler as ALCN(M) languages,\nwith the adoption of role constructors M subset-of {o,-,And,Or}. In particular,\nthey showed in 1999 that, although ALCN(o) is decidable, the addition of other\noperators may easily lead to undecidability: in fact, ALCN(o,And) and\nALCN(o,-,Or) were proved undecidable.\n  In this work, we further investigate the computational properties of the ALCN\nfamily, aiming at narrowing the decidability gap left open by Baader and\nSattler's results. In particular, we will show that ALCN(o) extended with\ninverse roles both in number and in value restrictions becomes undecidable,\nwhereas it can be safely extended with qualified number restrictions without\nlosing decidability."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0308029v1", 
    "other_authors": [
        "Fabio Grandi"
    ], 
    "lead_author": "Fabio Grandi", 
    "arxiv-id": "cs/0308029v1", 
    "title": "On Decidability of Expressive Description Logics with Composition of   Roles in Number Restrictions", 
    "publish": "2003-08-19T12:50:02Z", 
    "summary": "Description Logics are knowledge representation formalisms which have been\nused in a wide range of application domains. Owing to their appealing\nexpressiveness, we consider in this paper extensions of the well-known concept\nlanguage ALC allowing for number restrictions on complex role expressions.\nThese have been first introduced by Baader and Sattler as ALCN(M) languages,\nwith the adoption of role constructors M subset-of {o,-,And,Or}. In particular,\nthey showed in 1999 that, although ALCN(o) is decidable, the addition of other\noperators may easily lead to undecidability: in fact, ALCN(o,And) and\nALCN(o,-,Or) were proved undecidable.\n  In this work, we further investigate the computational properties of the ALCN\nfamily, aiming at narrowing the decidability gap left open by Baader and\nSattler's results. In particular, we will show that ALCN(o) extended with\ninverse roles both in number and in value restrictions becomes undecidable,\nwhereas it can be safely extended with qualified number restrictions without\nlosing decidability."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0308029v1", 
    "other_authors": [
        "Fabio Grandi"
    ], 
    "lead_author": "Fabio Grandi", 
    "arxiv-id": "cs/0308029v1", 
    "title": "On Decidability of Expressive Description Logics with Composition of   Roles in Number Restrictions", 
    "publish": "2003-08-19T12:50:02Z", 
    "summary": "Description Logics are knowledge representation formalisms which have been\nused in a wide range of application domains. Owing to their appealing\nexpressiveness, we consider in this paper extensions of the well-known concept\nlanguage ALC allowing for number restrictions on complex role expressions.\nThese have been first introduced by Baader and Sattler as ALCN(M) languages,\nwith the adoption of role constructors M subset-of {o,-,And,Or}. In particular,\nthey showed in 1999 that, although ALCN(o) is decidable, the addition of other\noperators may easily lead to undecidability: in fact, ALCN(o,And) and\nALCN(o,-,Or) were proved undecidable.\n  In this work, we further investigate the computational properties of the ALCN\nfamily, aiming at narrowing the decidability gap left open by Baader and\nSattler's results. In particular, we will show that ALCN(o) extended with\ninverse roles both in number and in value restrictions becomes undecidable,\nwhereas it can be safely extended with qualified number restrictions without\nlosing decidability."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309004v1", 
    "other_authors": [
        "Bruce Long"
    ], 
    "lead_author": "Bruce Long", 
    "arxiv-id": "cs/0309004v1", 
    "title": "The Structure of Information", 
    "publish": "2003-09-02T10:10:51Z", 
    "summary": "A formal model of the structure of information is presented in five axioms\nwhich define identity, containment, and joins of infons. Joins are shown to be\ncommutative, associative, provide inverses of infons, and, potentially, have\nmany identity elements, two of which are multiplicative and additive. Those two\ntypes of join are distributive. The other identity elements are for operators\non entwined states. Multiplicative joins correspond to adding or removing new\nbits to a system while additive joins correspond to a change of state. The\norder or size of an infon is defined. This groundwork is intended to be used to\nmodel continuous and discreet information structures through time, especially\nin closed systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309004v1", 
    "other_authors": [
        "Bruce Long"
    ], 
    "lead_author": "Bruce Long", 
    "arxiv-id": "cs/0309004v1", 
    "title": "The Structure of Information", 
    "publish": "2003-09-02T10:10:51Z", 
    "summary": "A formal model of the structure of information is presented in five axioms\nwhich define identity, containment, and joins of infons. Joins are shown to be\ncommutative, associative, provide inverses of infons, and, potentially, have\nmany identity elements, two of which are multiplicative and additive. Those two\ntypes of join are distributive. The other identity elements are for operators\non entwined states. Multiplicative joins correspond to adding or removing new\nbits to a system while additive joins correspond to a change of state. The\norder or size of an infon is defined. This groundwork is intended to be used to\nmodel continuous and discreet information structures through time, especially\nin closed systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309004v1", 
    "other_authors": [
        "Bruce Long"
    ], 
    "lead_author": "Bruce Long", 
    "arxiv-id": "cs/0309004v1", 
    "title": "The Structure of Information", 
    "publish": "2003-09-02T10:10:51Z", 
    "summary": "A formal model of the structure of information is presented in five axioms\nwhich define identity, containment, and joins of infons. Joins are shown to be\ncommutative, associative, provide inverses of infons, and, potentially, have\nmany identity elements, two of which are multiplicative and additive. Those two\ntypes of join are distributive. The other identity elements are for operators\non entwined states. Multiplicative joins correspond to adding or removing new\nbits to a system while additive joins correspond to a change of state. The\norder or size of an infon is defined. This groundwork is intended to be used to\nmodel continuous and discreet information structures through time, especially\nin closed systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309004v1", 
    "other_authors": [
        "Bruce Long"
    ], 
    "lead_author": "Bruce Long", 
    "arxiv-id": "cs/0309004v1", 
    "title": "The Structure of Information", 
    "publish": "2003-09-02T10:10:51Z", 
    "summary": "A formal model of the structure of information is presented in five axioms\nwhich define identity, containment, and joins of infons. Joins are shown to be\ncommutative, associative, provide inverses of infons, and, potentially, have\nmany identity elements, two of which are multiplicative and additive. Those two\ntypes of join are distributive. The other identity elements are for operators\non entwined states. Multiplicative joins correspond to adding or removing new\nbits to a system while additive joins correspond to a change of state. The\norder or size of an infon is defined. This groundwork is intended to be used to\nmodel continuous and discreet information structures through time, especially\nin closed systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309004v1", 
    "other_authors": [
        "Bruce Long"
    ], 
    "lead_author": "Bruce Long", 
    "arxiv-id": "cs/0309004v1", 
    "title": "The Structure of Information", 
    "publish": "2003-09-02T10:10:51Z", 
    "summary": "A formal model of the structure of information is presented in five axioms\nwhich define identity, containment, and joins of infons. Joins are shown to be\ncommutative, associative, provide inverses of infons, and, potentially, have\nmany identity elements, two of which are multiplicative and additive. Those two\ntypes of join are distributive. The other identity elements are for operators\non entwined states. Multiplicative joins correspond to adding or removing new\nbits to a system while additive joins correspond to a change of state. The\norder or size of an infon is defined. This groundwork is intended to be used to\nmodel continuous and discreet information structures through time, especially\nin closed systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309004v1", 
    "other_authors": [
        "Bruce Long"
    ], 
    "lead_author": "Bruce Long", 
    "arxiv-id": "cs/0309004v1", 
    "title": "The Structure of Information", 
    "publish": "2003-09-02T10:10:51Z", 
    "summary": "A formal model of the structure of information is presented in five axioms\nwhich define identity, containment, and joins of infons. Joins are shown to be\ncommutative, associative, provide inverses of infons, and, potentially, have\nmany identity elements, two of which are multiplicative and additive. Those two\ntypes of join are distributive. The other identity elements are for operators\non entwined states. Multiplicative joins correspond to adding or removing new\nbits to a system while additive joins correspond to a change of state. The\norder or size of an infon is defined. This groundwork is intended to be used to\nmodel continuous and discreet information structures through time, especially\nin closed systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309004v1", 
    "other_authors": [
        "Bruce Long"
    ], 
    "lead_author": "Bruce Long", 
    "arxiv-id": "cs/0309004v1", 
    "title": "The Structure of Information", 
    "publish": "2003-09-02T10:10:51Z", 
    "summary": "A formal model of the structure of information is presented in five axioms\nwhich define identity, containment, and joins of infons. Joins are shown to be\ncommutative, associative, provide inverses of infons, and, potentially, have\nmany identity elements, two of which are multiplicative and additive. Those two\ntypes of join are distributive. The other identity elements are for operators\non entwined states. Multiplicative joins correspond to adding or removing new\nbits to a system while additive joins correspond to a change of state. The\norder or size of an infon is defined. This groundwork is intended to be used to\nmodel continuous and discreet information structures through time, especially\nin closed systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309004v1", 
    "other_authors": [
        "Bruce Long"
    ], 
    "lead_author": "Bruce Long", 
    "arxiv-id": "cs/0309004v1", 
    "title": "The Structure of Information", 
    "publish": "2003-09-02T10:10:51Z", 
    "summary": "A formal model of the structure of information is presented in five axioms\nwhich define identity, containment, and joins of infons. Joins are shown to be\ncommutative, associative, provide inverses of infons, and, potentially, have\nmany identity elements, two of which are multiplicative and additive. Those two\ntypes of join are distributive. The other identity elements are for operators\non entwined states. Multiplicative joins correspond to adding or removing new\nbits to a system while additive joins correspond to a change of state. The\norder or size of an infon is defined. This groundwork is intended to be used to\nmodel continuous and discreet information structures through time, especially\nin closed systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309004v1", 
    "other_authors": [
        "Bruce Long"
    ], 
    "lead_author": "Bruce Long", 
    "arxiv-id": "cs/0309004v1", 
    "title": "The Structure of Information", 
    "publish": "2003-09-02T10:10:51Z", 
    "summary": "A formal model of the structure of information is presented in five axioms\nwhich define identity, containment, and joins of infons. Joins are shown to be\ncommutative, associative, provide inverses of infons, and, potentially, have\nmany identity elements, two of which are multiplicative and additive. Those two\ntypes of join are distributive. The other identity elements are for operators\non entwined states. Multiplicative joins correspond to adding or removing new\nbits to a system while additive joins correspond to a change of state. The\norder or size of an infon is defined. This groundwork is intended to be used to\nmodel continuous and discreet information structures through time, especially\nin closed systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309004v1", 
    "other_authors": [
        "Bruce Long"
    ], 
    "lead_author": "Bruce Long", 
    "arxiv-id": "cs/0309004v1", 
    "title": "The Structure of Information", 
    "publish": "2003-09-02T10:10:51Z", 
    "summary": "A formal model of the structure of information is presented in five axioms\nwhich define identity, containment, and joins of infons. Joins are shown to be\ncommutative, associative, provide inverses of infons, and, potentially, have\nmany identity elements, two of which are multiplicative and additive. Those two\ntypes of join are distributive. The other identity elements are for operators\non entwined states. Multiplicative joins correspond to adding or removing new\nbits to a system while additive joins correspond to a change of state. The\norder or size of an infon is defined. This groundwork is intended to be used to\nmodel continuous and discreet information structures through time, especially\nin closed systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309004v1", 
    "other_authors": [
        "Bruce Long"
    ], 
    "lead_author": "Bruce Long", 
    "arxiv-id": "cs/0309004v1", 
    "title": "The Structure of Information", 
    "publish": "2003-09-02T10:10:51Z", 
    "summary": "A formal model of the structure of information is presented in five axioms\nwhich define identity, containment, and joins of infons. Joins are shown to be\ncommutative, associative, provide inverses of infons, and, potentially, have\nmany identity elements, two of which are multiplicative and additive. Those two\ntypes of join are distributive. The other identity elements are for operators\non entwined states. Multiplicative joins correspond to adding or removing new\nbits to a system while additive joins correspond to a change of state. The\norder or size of an infon is defined. This groundwork is intended to be used to\nmodel continuous and discreet information structures through time, especially\nin closed systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309004v1", 
    "other_authors": [
        "Bruce Long"
    ], 
    "lead_author": "Bruce Long", 
    "arxiv-id": "cs/0309004v1", 
    "title": "The Structure of Information", 
    "publish": "2003-09-02T10:10:51Z", 
    "summary": "A formal model of the structure of information is presented in five axioms\nwhich define identity, containment, and joins of infons. Joins are shown to be\ncommutative, associative, provide inverses of infons, and, potentially, have\nmany identity elements, two of which are multiplicative and additive. Those two\ntypes of join are distributive. The other identity elements are for operators\non entwined states. Multiplicative joins correspond to adding or removing new\nbits to a system while additive joins correspond to a change of state. The\norder or size of an infon is defined. This groundwork is intended to be used to\nmodel continuous and discreet information structures through time, especially\nin closed systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309004v1", 
    "other_authors": [
        "Bruce Long"
    ], 
    "lead_author": "Bruce Long", 
    "arxiv-id": "cs/0309004v1", 
    "title": "The Structure of Information", 
    "publish": "2003-09-02T10:10:51Z", 
    "summary": "A formal model of the structure of information is presented in five axioms\nwhich define identity, containment, and joins of infons. Joins are shown to be\ncommutative, associative, provide inverses of infons, and, potentially, have\nmany identity elements, two of which are multiplicative and additive. Those two\ntypes of join are distributive. The other identity elements are for operators\non entwined states. Multiplicative joins correspond to adding or removing new\nbits to a system while additive joins correspond to a change of state. The\norder or size of an infon is defined. This groundwork is intended to be used to\nmodel continuous and discreet information structures through time, especially\nin closed systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309004v1", 
    "other_authors": [
        "Bruce Long"
    ], 
    "lead_author": "Bruce Long", 
    "arxiv-id": "cs/0309004v1", 
    "title": "The Structure of Information", 
    "publish": "2003-09-02T10:10:51Z", 
    "summary": "A formal model of the structure of information is presented in five axioms\nwhich define identity, containment, and joins of infons. Joins are shown to be\ncommutative, associative, provide inverses of infons, and, potentially, have\nmany identity elements, two of which are multiplicative and additive. Those two\ntypes of join are distributive. The other identity elements are for operators\non entwined states. Multiplicative joins correspond to adding or removing new\nbits to a system while additive joins correspond to a change of state. The\norder or size of an infon is defined. This groundwork is intended to be used to\nmodel continuous and discreet information structures through time, especially\nin closed systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309004v1", 
    "other_authors": [
        "Bruce Long"
    ], 
    "lead_author": "Bruce Long", 
    "arxiv-id": "cs/0309004v1", 
    "title": "The Structure of Information", 
    "publish": "2003-09-02T10:10:51Z", 
    "summary": "A formal model of the structure of information is presented in five axioms\nwhich define identity, containment, and joins of infons. Joins are shown to be\ncommutative, associative, provide inverses of infons, and, potentially, have\nmany identity elements, two of which are multiplicative and additive. Those two\ntypes of join are distributive. The other identity elements are for operators\non entwined states. Multiplicative joins correspond to adding or removing new\nbits to a system while additive joins correspond to a change of state. The\norder or size of an infon is defined. This groundwork is intended to be used to\nmodel continuous and discreet information structures through time, especially\nin closed systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309004v1", 
    "other_authors": [
        "Bruce Long"
    ], 
    "lead_author": "Bruce Long", 
    "arxiv-id": "cs/0309004v1", 
    "title": "The Structure of Information", 
    "publish": "2003-09-02T10:10:51Z", 
    "summary": "A formal model of the structure of information is presented in five axioms\nwhich define identity, containment, and joins of infons. Joins are shown to be\ncommutative, associative, provide inverses of infons, and, potentially, have\nmany identity elements, two of which are multiplicative and additive. Those two\ntypes of join are distributive. The other identity elements are for operators\non entwined states. Multiplicative joins correspond to adding or removing new\nbits to a system while additive joins correspond to a change of state. The\norder or size of an infon is defined. This groundwork is intended to be used to\nmodel continuous and discreet information structures through time, especially\nin closed systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309004v1", 
    "other_authors": [
        "Bruce Long"
    ], 
    "lead_author": "Bruce Long", 
    "arxiv-id": "cs/0309004v1", 
    "title": "The Structure of Information", 
    "publish": "2003-09-02T10:10:51Z", 
    "summary": "A formal model of the structure of information is presented in five axioms\nwhich define identity, containment, and joins of infons. Joins are shown to be\ncommutative, associative, provide inverses of infons, and, potentially, have\nmany identity elements, two of which are multiplicative and additive. Those two\ntypes of join are distributive. The other identity elements are for operators\non entwined states. Multiplicative joins correspond to adding or removing new\nbits to a system while additive joins correspond to a change of state. The\norder or size of an infon is defined. This groundwork is intended to be used to\nmodel continuous and discreet information structures through time, especially\nin closed systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309004v1", 
    "other_authors": [
        "Bruce Long"
    ], 
    "lead_author": "Bruce Long", 
    "arxiv-id": "cs/0309004v1", 
    "title": "The Structure of Information", 
    "publish": "2003-09-02T10:10:51Z", 
    "summary": "A formal model of the structure of information is presented in five axioms\nwhich define identity, containment, and joins of infons. Joins are shown to be\ncommutative, associative, provide inverses of infons, and, potentially, have\nmany identity elements, two of which are multiplicative and additive. Those two\ntypes of join are distributive. The other identity elements are for operators\non entwined states. Multiplicative joins correspond to adding or removing new\nbits to a system while additive joins correspond to a change of state. The\norder or size of an infon is defined. This groundwork is intended to be used to\nmodel continuous and discreet information structures through time, especially\nin closed systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309004v1", 
    "other_authors": [
        "Bruce Long"
    ], 
    "lead_author": "Bruce Long", 
    "arxiv-id": "cs/0309004v1", 
    "title": "The Structure of Information", 
    "publish": "2003-09-02T10:10:51Z", 
    "summary": "A formal model of the structure of information is presented in five axioms\nwhich define identity, containment, and joins of infons. Joins are shown to be\ncommutative, associative, provide inverses of infons, and, potentially, have\nmany identity elements, two of which are multiplicative and additive. Those two\ntypes of join are distributive. The other identity elements are for operators\non entwined states. Multiplicative joins correspond to adding or removing new\nbits to a system while additive joins correspond to a change of state. The\norder or size of an infon is defined. This groundwork is intended to be used to\nmodel continuous and discreet information structures through time, especially\nin closed systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309004v1", 
    "other_authors": [
        "Bruce Long"
    ], 
    "lead_author": "Bruce Long", 
    "arxiv-id": "cs/0309004v1", 
    "title": "The Structure of Information", 
    "publish": "2003-09-02T10:10:51Z", 
    "summary": "A formal model of the structure of information is presented in five axioms\nwhich define identity, containment, and joins of infons. Joins are shown to be\ncommutative, associative, provide inverses of infons, and, potentially, have\nmany identity elements, two of which are multiplicative and additive. Those two\ntypes of join are distributive. The other identity elements are for operators\non entwined states. Multiplicative joins correspond to adding or removing new\nbits to a system while additive joins correspond to a change of state. The\norder or size of an infon is defined. This groundwork is intended to be used to\nmodel continuous and discreet information structures through time, especially\nin closed systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309004v1", 
    "other_authors": [
        "Bruce Long"
    ], 
    "lead_author": "Bruce Long", 
    "arxiv-id": "cs/0309004v1", 
    "title": "The Structure of Information", 
    "publish": "2003-09-02T10:10:51Z", 
    "summary": "A formal model of the structure of information is presented in five axioms\nwhich define identity, containment, and joins of infons. Joins are shown to be\ncommutative, associative, provide inverses of infons, and, potentially, have\nmany identity elements, two of which are multiplicative and additive. Those two\ntypes of join are distributive. The other identity elements are for operators\non entwined states. Multiplicative joins correspond to adding or removing new\nbits to a system while additive joins correspond to a change of state. The\norder or size of an infon is defined. This groundwork is intended to be used to\nmodel continuous and discreet information structures through time, especially\nin closed systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309004v1", 
    "other_authors": [
        "Bruce Long"
    ], 
    "lead_author": "Bruce Long", 
    "arxiv-id": "cs/0309004v1", 
    "title": "The Structure of Information", 
    "publish": "2003-09-02T10:10:51Z", 
    "summary": "A formal model of the structure of information is presented in five axioms\nwhich define identity, containment, and joins of infons. Joins are shown to be\ncommutative, associative, provide inverses of infons, and, potentially, have\nmany identity elements, two of which are multiplicative and additive. Those two\ntypes of join are distributive. The other identity elements are for operators\non entwined states. Multiplicative joins correspond to adding or removing new\nbits to a system while additive joins correspond to a change of state. The\norder or size of an infon is defined. This groundwork is intended to be used to\nmodel continuous and discreet information structures through time, especially\nin closed systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309004v1", 
    "other_authors": [
        "Bruce Long"
    ], 
    "lead_author": "Bruce Long", 
    "arxiv-id": "cs/0309004v1", 
    "title": "The Structure of Information", 
    "publish": "2003-09-02T10:10:51Z", 
    "summary": "A formal model of the structure of information is presented in five axioms\nwhich define identity, containment, and joins of infons. Joins are shown to be\ncommutative, associative, provide inverses of infons, and, potentially, have\nmany identity elements, two of which are multiplicative and additive. Those two\ntypes of join are distributive. The other identity elements are for operators\non entwined states. Multiplicative joins correspond to adding or removing new\nbits to a system while additive joins correspond to a change of state. The\norder or size of an infon is defined. This groundwork is intended to be used to\nmodel continuous and discreet information structures through time, especially\nin closed systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309004v1", 
    "other_authors": [
        "Bruce Long"
    ], 
    "lead_author": "Bruce Long", 
    "arxiv-id": "cs/0309004v1", 
    "title": "The Structure of Information", 
    "publish": "2003-09-02T10:10:51Z", 
    "summary": "A formal model of the structure of information is presented in five axioms\nwhich define identity, containment, and joins of infons. Joins are shown to be\ncommutative, associative, provide inverses of infons, and, potentially, have\nmany identity elements, two of which are multiplicative and additive. Those two\ntypes of join are distributive. The other identity elements are for operators\non entwined states. Multiplicative joins correspond to adding or removing new\nbits to a system while additive joins correspond to a change of state. The\norder or size of an infon is defined. This groundwork is intended to be used to\nmodel continuous and discreet information structures through time, especially\nin closed systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309004v1", 
    "other_authors": [
        "Bruce Long"
    ], 
    "lead_author": "Bruce Long", 
    "arxiv-id": "cs/0309004v1", 
    "title": "The Structure of Information", 
    "publish": "2003-09-02T10:10:51Z", 
    "summary": "A formal model of the structure of information is presented in five axioms\nwhich define identity, containment, and joins of infons. Joins are shown to be\ncommutative, associative, provide inverses of infons, and, potentially, have\nmany identity elements, two of which are multiplicative and additive. Those two\ntypes of join are distributive. The other identity elements are for operators\non entwined states. Multiplicative joins correspond to adding or removing new\nbits to a system while additive joins correspond to a change of state. The\norder or size of an infon is defined. This groundwork is intended to be used to\nmodel continuous and discreet information structures through time, especially\nin closed systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309004v1", 
    "other_authors": [
        "Bruce Long"
    ], 
    "lead_author": "Bruce Long", 
    "arxiv-id": "cs/0309004v1", 
    "title": "The Structure of Information", 
    "publish": "2003-09-02T10:10:51Z", 
    "summary": "A formal model of the structure of information is presented in five axioms\nwhich define identity, containment, and joins of infons. Joins are shown to be\ncommutative, associative, provide inverses of infons, and, potentially, have\nmany identity elements, two of which are multiplicative and additive. Those two\ntypes of join are distributive. The other identity elements are for operators\non entwined states. Multiplicative joins correspond to adding or removing new\nbits to a system while additive joins correspond to a change of state. The\norder or size of an infon is defined. This groundwork is intended to be used to\nmodel continuous and discreet information structures through time, especially\nin closed systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309004v1", 
    "other_authors": [
        "Bruce Long"
    ], 
    "lead_author": "Bruce Long", 
    "arxiv-id": "cs/0309004v1", 
    "title": "The Structure of Information", 
    "publish": "2003-09-02T10:10:51Z", 
    "summary": "A formal model of the structure of information is presented in five axioms\nwhich define identity, containment, and joins of infons. Joins are shown to be\ncommutative, associative, provide inverses of infons, and, potentially, have\nmany identity elements, two of which are multiplicative and additive. Those two\ntypes of join are distributive. The other identity elements are for operators\non entwined states. Multiplicative joins correspond to adding or removing new\nbits to a system while additive joins correspond to a change of state. The\norder or size of an infon is defined. This groundwork is intended to be used to\nmodel continuous and discreet information structures through time, especially\nin closed systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309004v1", 
    "other_authors": [
        "Bruce Long"
    ], 
    "lead_author": "Bruce Long", 
    "arxiv-id": "cs/0309004v1", 
    "title": "The Structure of Information", 
    "publish": "2003-09-02T10:10:51Z", 
    "summary": "A formal model of the structure of information is presented in five axioms\nwhich define identity, containment, and joins of infons. Joins are shown to be\ncommutative, associative, provide inverses of infons, and, potentially, have\nmany identity elements, two of which are multiplicative and additive. Those two\ntypes of join are distributive. The other identity elements are for operators\non entwined states. Multiplicative joins correspond to adding or removing new\nbits to a system while additive joins correspond to a change of state. The\norder or size of an infon is defined. This groundwork is intended to be used to\nmodel continuous and discreet information structures through time, especially\nin closed systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "K. Vezerides", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0309046v1", 
    "other_authors": [
        "K. Vezerides", 
        "Ath. Kehagias"
    ], 
    "lead_author": "Ath. Kehagias", 
    "arxiv-id": "cs/0309046v1", 
    "title": "The Liar and Related Paradoxes: Fuzzy Truth Value Assignment for   Collections of Self-Referential Sentences", 
    "publish": "2003-09-24T11:50:00Z", 
    "summary": "We study self-referential sentences of the type related to the Liar paradox.\nIn particular, we consider the problem of assigning consistent fuzzy truth\nvalues to collections of self-referential sentences. We show that the problem\ncan be reduced to the solution of a system of nonlinear equations. Furthermore,\nwe prove that, under mild conditions, such a system always has a solution (i.e.\na consistent truth value assignment) and that, for a particular implementation\nof logical ``and'', ``or'' and ``negation'', the ``mid-point'' solution is\nalways consistent. Next we turn to computational issues and present several\ntruth-value assignment algorithms; we argue that these algorithms can be\nunderstood as generalized sequential reasoning. In an Appendix we present a\nlarge number of examples of self-referential collections (including the Liar\nand the Strengthened Liar), we formulate the corresponding truth value\nequations and solve them analytically and/ or numerically."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310054v1", 
    "other_authors": [
        "J. Desharnais", 
        "B. M\u00f6ller", 
        "G. Struth"
    ], 
    "lead_author": "J. Desharnais", 
    "arxiv-id": "cs/0310054v1", 
    "title": "Kleene algebra with domain", 
    "publish": "2003-10-28T16:09:48Z", 
    "summary": "We propose Kleene algebra with domain (KAD), an extension of Kleene algebra\nwith two equational axioms for a domain and a codomain operation, respectively.\nKAD considerably augments the expressiveness of Kleene algebra, in particular\nfor the specification and analysis of state transition systems. We develop the\nbasic calculus, discuss some related theories and present the most important\nmodels of KAD. We demonstrate applicability by two examples: First, an\nalgebraic reconstruction of Noethericity and well-foundedness; second, an\nalgebraic reconstruction of propositional Hoare logic."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310054v1", 
    "other_authors": [
        "J. Desharnais", 
        "B. M\u00f6ller", 
        "G. Struth"
    ], 
    "lead_author": "J. Desharnais", 
    "arxiv-id": "cs/0310054v1", 
    "title": "Kleene algebra with domain", 
    "publish": "2003-10-28T16:09:48Z", 
    "summary": "We propose Kleene algebra with domain (KAD), an extension of Kleene algebra\nwith two equational axioms for a domain and a codomain operation, respectively.\nKAD considerably augments the expressiveness of Kleene algebra, in particular\nfor the specification and analysis of state transition systems. We develop the\nbasic calculus, discuss some related theories and present the most important\nmodels of KAD. We demonstrate applicability by two examples: First, an\nalgebraic reconstruction of Noethericity and well-foundedness; second, an\nalgebraic reconstruction of propositional Hoare logic."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310054v1", 
    "other_authors": [
        "J. Desharnais", 
        "B. M\u00f6ller", 
        "G. Struth"
    ], 
    "lead_author": "J. Desharnais", 
    "arxiv-id": "cs/0310054v1", 
    "title": "Kleene algebra with domain", 
    "publish": "2003-10-28T16:09:48Z", 
    "summary": "We propose Kleene algebra with domain (KAD), an extension of Kleene algebra\nwith two equational axioms for a domain and a codomain operation, respectively.\nKAD considerably augments the expressiveness of Kleene algebra, in particular\nfor the specification and analysis of state transition systems. We develop the\nbasic calculus, discuss some related theories and present the most important\nmodels of KAD. We demonstrate applicability by two examples: First, an\nalgebraic reconstruction of Noethericity and well-foundedness; second, an\nalgebraic reconstruction of propositional Hoare logic."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310054v1", 
    "other_authors": [
        "J. Desharnais", 
        "B. M\u00f6ller", 
        "G. Struth"
    ], 
    "lead_author": "J. Desharnais", 
    "arxiv-id": "cs/0310054v1", 
    "title": "Kleene algebra with domain", 
    "publish": "2003-10-28T16:09:48Z", 
    "summary": "We propose Kleene algebra with domain (KAD), an extension of Kleene algebra\nwith two equational axioms for a domain and a codomain operation, respectively.\nKAD considerably augments the expressiveness of Kleene algebra, in particular\nfor the specification and analysis of state transition systems. We develop the\nbasic calculus, discuss some related theories and present the most important\nmodels of KAD. We demonstrate applicability by two examples: First, an\nalgebraic reconstruction of Noethericity and well-foundedness; second, an\nalgebraic reconstruction of propositional Hoare logic."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310054v1", 
    "other_authors": [
        "J. Desharnais", 
        "B. M\u00f6ller", 
        "G. Struth"
    ], 
    "lead_author": "G. Struth", 
    "arxiv-id": "cs/0310054v1", 
    "title": "Kleene algebra with domain", 
    "publish": "2003-10-28T16:09:48Z", 
    "summary": "We propose Kleene algebra with domain (KAD), an extension of Kleene algebra\nwith two equational axioms for a domain and a codomain operation, respectively.\nKAD considerably augments the expressiveness of Kleene algebra, in particular\nfor the specification and analysis of state transition systems. We develop the\nbasic calculus, discuss some related theories and present the most important\nmodels of KAD. We demonstrate applicability by two examples: First, an\nalgebraic reconstruction of Noethericity and well-foundedness; second, an\nalgebraic reconstruction of propositional Hoare logic."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310054v1", 
    "other_authors": [
        "J. Desharnais", 
        "B. M\u00f6ller", 
        "G. Struth"
    ], 
    "lead_author": "G. Struth", 
    "arxiv-id": "cs/0310054v1", 
    "title": "Kleene algebra with domain", 
    "publish": "2003-10-28T16:09:48Z", 
    "summary": "We propose Kleene algebra with domain (KAD), an extension of Kleene algebra\nwith two equational axioms for a domain and a codomain operation, respectively.\nKAD considerably augments the expressiveness of Kleene algebra, in particular\nfor the specification and analysis of state transition systems. We develop the\nbasic calculus, discuss some related theories and present the most important\nmodels of KAD. We demonstrate applicability by two examples: First, an\nalgebraic reconstruction of Noethericity and well-foundedness; second, an\nalgebraic reconstruction of propositional Hoare logic."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310054v1", 
    "other_authors": [
        "J. Desharnais", 
        "B. M\u00f6ller", 
        "G. Struth"
    ], 
    "lead_author": "G. Struth", 
    "arxiv-id": "cs/0310054v1", 
    "title": "Kleene algebra with domain", 
    "publish": "2003-10-28T16:09:48Z", 
    "summary": "We propose Kleene algebra with domain (KAD), an extension of Kleene algebra\nwith two equational axioms for a domain and a codomain operation, respectively.\nKAD considerably augments the expressiveness of Kleene algebra, in particular\nfor the specification and analysis of state transition systems. We develop the\nbasic calculus, discuss some related theories and present the most important\nmodels of KAD. We demonstrate applicability by two examples: First, an\nalgebraic reconstruction of Noethericity and well-foundedness; second, an\nalgebraic reconstruction of propositional Hoare logic."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310054v1", 
    "other_authors": [
        "J. Desharnais", 
        "B. M\u00f6ller", 
        "G. Struth"
    ], 
    "lead_author": "G. Struth", 
    "arxiv-id": "cs/0310054v1", 
    "title": "Kleene algebra with domain", 
    "publish": "2003-10-28T16:09:48Z", 
    "summary": "We propose Kleene algebra with domain (KAD), an extension of Kleene algebra\nwith two equational axioms for a domain and a codomain operation, respectively.\nKAD considerably augments the expressiveness of Kleene algebra, in particular\nfor the specification and analysis of state transition systems. We develop the\nbasic calculus, discuss some related theories and present the most important\nmodels of KAD. We demonstrate applicability by two examples: First, an\nalgebraic reconstruction of Noethericity and well-foundedness; second, an\nalgebraic reconstruction of propositional Hoare logic."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310054v1", 
    "other_authors": [
        "J. Desharnais", 
        "B. M\u00f6ller", 
        "G. Struth"
    ], 
    "lead_author": "G. Struth", 
    "arxiv-id": "cs/0310054v1", 
    "title": "Kleene algebra with domain", 
    "publish": "2003-10-28T16:09:48Z", 
    "summary": "We propose Kleene algebra with domain (KAD), an extension of Kleene algebra\nwith two equational axioms for a domain and a codomain operation, respectively.\nKAD considerably augments the expressiveness of Kleene algebra, in particular\nfor the specification and analysis of state transition systems. We develop the\nbasic calculus, discuss some related theories and present the most important\nmodels of KAD. We demonstrate applicability by two examples: First, an\nalgebraic reconstruction of Noethericity and well-foundedness; second, an\nalgebraic reconstruction of propositional Hoare logic."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310054v1", 
    "other_authors": [
        "J. Desharnais", 
        "B. M\u00f6ller", 
        "G. Struth"
    ], 
    "lead_author": "G. Struth", 
    "arxiv-id": "cs/0310054v1", 
    "title": "Kleene algebra with domain", 
    "publish": "2003-10-28T16:09:48Z", 
    "summary": "We propose Kleene algebra with domain (KAD), an extension of Kleene algebra\nwith two equational axioms for a domain and a codomain operation, respectively.\nKAD considerably augments the expressiveness of Kleene algebra, in particular\nfor the specification and analysis of state transition systems. We develop the\nbasic calculus, discuss some related theories and present the most important\nmodels of KAD. We demonstrate applicability by two examples: First, an\nalgebraic reconstruction of Noethericity and well-foundedness; second, an\nalgebraic reconstruction of propositional Hoare logic."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310054v1", 
    "other_authors": [
        "J. Desharnais", 
        "B. M\u00f6ller", 
        "G. Struth"
    ], 
    "lead_author": "G. Struth", 
    "arxiv-id": "cs/0310054v1", 
    "title": "Kleene algebra with domain", 
    "publish": "2003-10-28T16:09:48Z", 
    "summary": "We propose Kleene algebra with domain (KAD), an extension of Kleene algebra\nwith two equational axioms for a domain and a codomain operation, respectively.\nKAD considerably augments the expressiveness of Kleene algebra, in particular\nfor the specification and analysis of state transition systems. We develop the\nbasic calculus, discuss some related theories and present the most important\nmodels of KAD. We demonstrate applicability by two examples: First, an\nalgebraic reconstruction of Noethericity and well-foundedness; second, an\nalgebraic reconstruction of propositional Hoare logic."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310054v1", 
    "other_authors": [
        "J. Desharnais", 
        "B. M\u00f6ller", 
        "G. Struth"
    ], 
    "lead_author": "G. Struth", 
    "arxiv-id": "cs/0310054v1", 
    "title": "Kleene algebra with domain", 
    "publish": "2003-10-28T16:09:48Z", 
    "summary": "We propose Kleene algebra with domain (KAD), an extension of Kleene algebra\nwith two equational axioms for a domain and a codomain operation, respectively.\nKAD considerably augments the expressiveness of Kleene algebra, in particular\nfor the specification and analysis of state transition systems. We develop the\nbasic calculus, discuss some related theories and present the most important\nmodels of KAD. We demonstrate applicability by two examples: First, an\nalgebraic reconstruction of Noethericity and well-foundedness; second, an\nalgebraic reconstruction of propositional Hoare logic."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310054v1", 
    "other_authors": [
        "J. Desharnais", 
        "B. M\u00f6ller", 
        "G. Struth"
    ], 
    "lead_author": "G. Struth", 
    "arxiv-id": "cs/0310054v1", 
    "title": "Kleene algebra with domain", 
    "publish": "2003-10-28T16:09:48Z", 
    "summary": "We propose Kleene algebra with domain (KAD), an extension of Kleene algebra\nwith two equational axioms for a domain and a codomain operation, respectively.\nKAD considerably augments the expressiveness of Kleene algebra, in particular\nfor the specification and analysis of state transition systems. We develop the\nbasic calculus, discuss some related theories and present the most important\nmodels of KAD. We demonstrate applicability by two examples: First, an\nalgebraic reconstruction of Noethericity and well-foundedness; second, an\nalgebraic reconstruction of propositional Hoare logic."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310054v1", 
    "other_authors": [
        "J. Desharnais", 
        "B. M\u00f6ller", 
        "G. Struth"
    ], 
    "lead_author": "G. Struth", 
    "arxiv-id": "cs/0310054v1", 
    "title": "Kleene algebra with domain", 
    "publish": "2003-10-28T16:09:48Z", 
    "summary": "We propose Kleene algebra with domain (KAD), an extension of Kleene algebra\nwith two equational axioms for a domain and a codomain operation, respectively.\nKAD considerably augments the expressiveness of Kleene algebra, in particular\nfor the specification and analysis of state transition systems. We develop the\nbasic calculus, discuss some related theories and present the most important\nmodels of KAD. We demonstrate applicability by two examples: First, an\nalgebraic reconstruction of Noethericity and well-foundedness; second, an\nalgebraic reconstruction of propositional Hoare logic."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310054v1", 
    "other_authors": [
        "J. Desharnais", 
        "B. M\u00f6ller", 
        "G. Struth"
    ], 
    "lead_author": "G. Struth", 
    "arxiv-id": "cs/0310054v1", 
    "title": "Kleene algebra with domain", 
    "publish": "2003-10-28T16:09:48Z", 
    "summary": "We propose Kleene algebra with domain (KAD), an extension of Kleene algebra\nwith two equational axioms for a domain and a codomain operation, respectively.\nKAD considerably augments the expressiveness of Kleene algebra, in particular\nfor the specification and analysis of state transition systems. We develop the\nbasic calculus, discuss some related theories and present the most important\nmodels of KAD. We demonstrate applicability by two examples: First, an\nalgebraic reconstruction of Noethericity and well-foundedness; second, an\nalgebraic reconstruction of propositional Hoare logic."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310054v1", 
    "other_authors": [
        "J. Desharnais", 
        "B. M\u00f6ller", 
        "G. Struth"
    ], 
    "lead_author": "G. Struth", 
    "arxiv-id": "cs/0310054v1", 
    "title": "Kleene algebra with domain", 
    "publish": "2003-10-28T16:09:48Z", 
    "summary": "We propose Kleene algebra with domain (KAD), an extension of Kleene algebra\nwith two equational axioms for a domain and a codomain operation, respectively.\nKAD considerably augments the expressiveness of Kleene algebra, in particular\nfor the specification and analysis of state transition systems. We develop the\nbasic calculus, discuss some related theories and present the most important\nmodels of KAD. We demonstrate applicability by two examples: First, an\nalgebraic reconstruction of Noethericity and well-foundedness; second, an\nalgebraic reconstruction of propositional Hoare logic."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310054v1", 
    "other_authors": [
        "J. Desharnais", 
        "B. M\u00f6ller", 
        "G. Struth"
    ], 
    "lead_author": "G. Struth", 
    "arxiv-id": "cs/0310054v1", 
    "title": "Kleene algebra with domain", 
    "publish": "2003-10-28T16:09:48Z", 
    "summary": "We propose Kleene algebra with domain (KAD), an extension of Kleene algebra\nwith two equational axioms for a domain and a codomain operation, respectively.\nKAD considerably augments the expressiveness of Kleene algebra, in particular\nfor the specification and analysis of state transition systems. We develop the\nbasic calculus, discuss some related theories and present the most important\nmodels of KAD. We demonstrate applicability by two examples: First, an\nalgebraic reconstruction of Noethericity and well-foundedness; second, an\nalgebraic reconstruction of propositional Hoare logic."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310063v1", 
    "other_authors": [
        "Victor W. Marek", 
        "Ilkka Niemela", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Ilkka Niemela", 
    "arxiv-id": "cs/0310063v1", 
    "title": "Logic programs with monotone cardinality atoms", 
    "publish": "2003-10-31T16:56:18Z", 
    "summary": "We investigate mca-programs, that is, logic programs with clauses built of\nmonotone cardinality atoms of the form kX, where k is a non-negative integer\nand X is a finite set of propositional atoms. We develop a theory of\nmca-programs. We demonstrate that the operational concept of the one-step\nprovability operator generalizes to mca-programs, but the generalization\ninvolves nondeterminism. Our main results show that the formalism of\nmca-programs is a common generalization of (1) normal logic programming with\nits semantics of models, supported models and stable models, (2) logic\nprogramming with cardinality atoms and with the semantics of stable models, as\ndefined by Niemela, Simons and Soininen, and (3) of disjunctive logic\nprogramming with the possible-model semantics of Sakama and Inoue."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310063v1", 
    "other_authors": [
        "Victor W. Marek", 
        "Ilkka Niemela", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Ilkka Niemela", 
    "arxiv-id": "cs/0310063v1", 
    "title": "Logic programs with monotone cardinality atoms", 
    "publish": "2003-10-31T16:56:18Z", 
    "summary": "We investigate mca-programs, that is, logic programs with clauses built of\nmonotone cardinality atoms of the form kX, where k is a non-negative integer\nand X is a finite set of propositional atoms. We develop a theory of\nmca-programs. We demonstrate that the operational concept of the one-step\nprovability operator generalizes to mca-programs, but the generalization\ninvolves nondeterminism. Our main results show that the formalism of\nmca-programs is a common generalization of (1) normal logic programming with\nits semantics of models, supported models and stable models, (2) logic\nprogramming with cardinality atoms and with the semantics of stable models, as\ndefined by Niemela, Simons and Soininen, and (3) of disjunctive logic\nprogramming with the possible-model semantics of Sakama and Inoue."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310063v1", 
    "other_authors": [
        "Victor W. Marek", 
        "Ilkka Niemela", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Ilkka Niemela", 
    "arxiv-id": "cs/0310063v1", 
    "title": "Logic programs with monotone cardinality atoms", 
    "publish": "2003-10-31T16:56:18Z", 
    "summary": "We investigate mca-programs, that is, logic programs with clauses built of\nmonotone cardinality atoms of the form kX, where k is a non-negative integer\nand X is a finite set of propositional atoms. We develop a theory of\nmca-programs. We demonstrate that the operational concept of the one-step\nprovability operator generalizes to mca-programs, but the generalization\ninvolves nondeterminism. Our main results show that the formalism of\nmca-programs is a common generalization of (1) normal logic programming with\nits semantics of models, supported models and stable models, (2) logic\nprogramming with cardinality atoms and with the semantics of stable models, as\ndefined by Niemela, Simons and Soininen, and (3) of disjunctive logic\nprogramming with the possible-model semantics of Sakama and Inoue."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310063v1", 
    "other_authors": [
        "Victor W. Marek", 
        "Ilkka Niemela", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Ilkka Niemela", 
    "arxiv-id": "cs/0310063v1", 
    "title": "Logic programs with monotone cardinality atoms", 
    "publish": "2003-10-31T16:56:18Z", 
    "summary": "We investigate mca-programs, that is, logic programs with clauses built of\nmonotone cardinality atoms of the form kX, where k is a non-negative integer\nand X is a finite set of propositional atoms. We develop a theory of\nmca-programs. We demonstrate that the operational concept of the one-step\nprovability operator generalizes to mca-programs, but the generalization\ninvolves nondeterminism. Our main results show that the formalism of\nmca-programs is a common generalization of (1) normal logic programming with\nits semantics of models, supported models and stable models, (2) logic\nprogramming with cardinality atoms and with the semantics of stable models, as\ndefined by Niemela, Simons and Soininen, and (3) of disjunctive logic\nprogramming with the possible-model semantics of Sakama and Inoue."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310063v1", 
    "other_authors": [
        "Victor W. Marek", 
        "Ilkka Niemela", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Ilkka Niemela", 
    "arxiv-id": "cs/0310063v1", 
    "title": "Logic programs with monotone cardinality atoms", 
    "publish": "2003-10-31T16:56:18Z", 
    "summary": "We investigate mca-programs, that is, logic programs with clauses built of\nmonotone cardinality atoms of the form kX, where k is a non-negative integer\nand X is a finite set of propositional atoms. We develop a theory of\nmca-programs. We demonstrate that the operational concept of the one-step\nprovability operator generalizes to mca-programs, but the generalization\ninvolves nondeterminism. Our main results show that the formalism of\nmca-programs is a common generalization of (1) normal logic programming with\nits semantics of models, supported models and stable models, (2) logic\nprogramming with cardinality atoms and with the semantics of stable models, as\ndefined by Niemela, Simons and Soininen, and (3) of disjunctive logic\nprogramming with the possible-model semantics of Sakama and Inoue."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310063v1", 
    "other_authors": [
        "Victor W. Marek", 
        "Ilkka Niemela", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Ilkka Niemela", 
    "arxiv-id": "cs/0310063v1", 
    "title": "Logic programs with monotone cardinality atoms", 
    "publish": "2003-10-31T16:56:18Z", 
    "summary": "We investigate mca-programs, that is, logic programs with clauses built of\nmonotone cardinality atoms of the form kX, where k is a non-negative integer\nand X is a finite set of propositional atoms. We develop a theory of\nmca-programs. We demonstrate that the operational concept of the one-step\nprovability operator generalizes to mca-programs, but the generalization\ninvolves nondeterminism. Our main results show that the formalism of\nmca-programs is a common generalization of (1) normal logic programming with\nits semantics of models, supported models and stable models, (2) logic\nprogramming with cardinality atoms and with the semantics of stable models, as\ndefined by Niemela, Simons and Soininen, and (3) of disjunctive logic\nprogramming with the possible-model semantics of Sakama and Inoue."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310063v1", 
    "other_authors": [
        "Victor W. Marek", 
        "Ilkka Niemela", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Ilkka Niemela", 
    "arxiv-id": "cs/0310063v1", 
    "title": "Logic programs with monotone cardinality atoms", 
    "publish": "2003-10-31T16:56:18Z", 
    "summary": "We investigate mca-programs, that is, logic programs with clauses built of\nmonotone cardinality atoms of the form kX, where k is a non-negative integer\nand X is a finite set of propositional atoms. We develop a theory of\nmca-programs. We demonstrate that the operational concept of the one-step\nprovability operator generalizes to mca-programs, but the generalization\ninvolves nondeterminism. Our main results show that the formalism of\nmca-programs is a common generalization of (1) normal logic programming with\nits semantics of models, supported models and stable models, (2) logic\nprogramming with cardinality atoms and with the semantics of stable models, as\ndefined by Niemela, Simons and Soininen, and (3) of disjunctive logic\nprogramming with the possible-model semantics of Sakama and Inoue."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310063v1", 
    "other_authors": [
        "Victor W. Marek", 
        "Ilkka Niemela", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Ilkka Niemela", 
    "arxiv-id": "cs/0310063v1", 
    "title": "Logic programs with monotone cardinality atoms", 
    "publish": "2003-10-31T16:56:18Z", 
    "summary": "We investigate mca-programs, that is, logic programs with clauses built of\nmonotone cardinality atoms of the form kX, where k is a non-negative integer\nand X is a finite set of propositional atoms. We develop a theory of\nmca-programs. We demonstrate that the operational concept of the one-step\nprovability operator generalizes to mca-programs, but the generalization\ninvolves nondeterminism. Our main results show that the formalism of\nmca-programs is a common generalization of (1) normal logic programming with\nits semantics of models, supported models and stable models, (2) logic\nprogramming with cardinality atoms and with the semantics of stable models, as\ndefined by Niemela, Simons and Soininen, and (3) of disjunctive logic\nprogramming with the possible-model semantics of Sakama and Inoue."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310063v1", 
    "other_authors": [
        "Victor W. Marek", 
        "Ilkka Niemela", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Ilkka Niemela", 
    "arxiv-id": "cs/0310063v1", 
    "title": "Logic programs with monotone cardinality atoms", 
    "publish": "2003-10-31T16:56:18Z", 
    "summary": "We investigate mca-programs, that is, logic programs with clauses built of\nmonotone cardinality atoms of the form kX, where k is a non-negative integer\nand X is a finite set of propositional atoms. We develop a theory of\nmca-programs. We demonstrate that the operational concept of the one-step\nprovability operator generalizes to mca-programs, but the generalization\ninvolves nondeterminism. Our main results show that the formalism of\nmca-programs is a common generalization of (1) normal logic programming with\nits semantics of models, supported models and stable models, (2) logic\nprogramming with cardinality atoms and with the semantics of stable models, as\ndefined by Niemela, Simons and Soininen, and (3) of disjunctive logic\nprogramming with the possible-model semantics of Sakama and Inoue."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310063v1", 
    "other_authors": [
        "Victor W. Marek", 
        "Ilkka Niemela", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Ilkka Niemela", 
    "arxiv-id": "cs/0310063v1", 
    "title": "Logic programs with monotone cardinality atoms", 
    "publish": "2003-10-31T16:56:18Z", 
    "summary": "We investigate mca-programs, that is, logic programs with clauses built of\nmonotone cardinality atoms of the form kX, where k is a non-negative integer\nand X is a finite set of propositional atoms. We develop a theory of\nmca-programs. We demonstrate that the operational concept of the one-step\nprovability operator generalizes to mca-programs, but the generalization\ninvolves nondeterminism. Our main results show that the formalism of\nmca-programs is a common generalization of (1) normal logic programming with\nits semantics of models, supported models and stable models, (2) logic\nprogramming with cardinality atoms and with the semantics of stable models, as\ndefined by Niemela, Simons and Soininen, and (3) of disjunctive logic\nprogramming with the possible-model semantics of Sakama and Inoue."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310063v1", 
    "other_authors": [
        "Victor W. Marek", 
        "Ilkka Niemela", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Ilkka Niemela", 
    "arxiv-id": "cs/0310063v1", 
    "title": "Logic programs with monotone cardinality atoms", 
    "publish": "2003-10-31T16:56:18Z", 
    "summary": "We investigate mca-programs, that is, logic programs with clauses built of\nmonotone cardinality atoms of the form kX, where k is a non-negative integer\nand X is a finite set of propositional atoms. We develop a theory of\nmca-programs. We demonstrate that the operational concept of the one-step\nprovability operator generalizes to mca-programs, but the generalization\ninvolves nondeterminism. Our main results show that the formalism of\nmca-programs is a common generalization of (1) normal logic programming with\nits semantics of models, supported models and stable models, (2) logic\nprogramming with cardinality atoms and with the semantics of stable models, as\ndefined by Niemela, Simons and Soininen, and (3) of disjunctive logic\nprogramming with the possible-model semantics of Sakama and Inoue."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310063v1", 
    "other_authors": [
        "Victor W. Marek", 
        "Ilkka Niemela", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Ilkka Niemela", 
    "arxiv-id": "cs/0310063v1", 
    "title": "Logic programs with monotone cardinality atoms", 
    "publish": "2003-10-31T16:56:18Z", 
    "summary": "We investigate mca-programs, that is, logic programs with clauses built of\nmonotone cardinality atoms of the form kX, where k is a non-negative integer\nand X is a finite set of propositional atoms. We develop a theory of\nmca-programs. We demonstrate that the operational concept of the one-step\nprovability operator generalizes to mca-programs, but the generalization\ninvolves nondeterminism. Our main results show that the formalism of\nmca-programs is a common generalization of (1) normal logic programming with\nits semantics of models, supported models and stable models, (2) logic\nprogramming with cardinality atoms and with the semantics of stable models, as\ndefined by Niemela, Simons and Soininen, and (3) of disjunctive logic\nprogramming with the possible-model semantics of Sakama and Inoue."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310063v1", 
    "other_authors": [
        "Victor W. Marek", 
        "Ilkka Niemela", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Ilkka Niemela", 
    "arxiv-id": "cs/0310063v1", 
    "title": "Logic programs with monotone cardinality atoms", 
    "publish": "2003-10-31T16:56:18Z", 
    "summary": "We investigate mca-programs, that is, logic programs with clauses built of\nmonotone cardinality atoms of the form kX, where k is a non-negative integer\nand X is a finite set of propositional atoms. We develop a theory of\nmca-programs. We demonstrate that the operational concept of the one-step\nprovability operator generalizes to mca-programs, but the generalization\ninvolves nondeterminism. Our main results show that the formalism of\nmca-programs is a common generalization of (1) normal logic programming with\nits semantics of models, supported models and stable models, (2) logic\nprogramming with cardinality atoms and with the semantics of stable models, as\ndefined by Niemela, Simons and Soininen, and (3) of disjunctive logic\nprogramming with the possible-model semantics of Sakama and Inoue."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310063v1", 
    "other_authors": [
        "Victor W. Marek", 
        "Ilkka Niemela", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Ilkka Niemela", 
    "arxiv-id": "cs/0310063v1", 
    "title": "Logic programs with monotone cardinality atoms", 
    "publish": "2003-10-31T16:56:18Z", 
    "summary": "We investigate mca-programs, that is, logic programs with clauses built of\nmonotone cardinality atoms of the form kX, where k is a non-negative integer\nand X is a finite set of propositional atoms. We develop a theory of\nmca-programs. We demonstrate that the operational concept of the one-step\nprovability operator generalizes to mca-programs, but the generalization\ninvolves nondeterminism. Our main results show that the formalism of\nmca-programs is a common generalization of (1) normal logic programming with\nits semantics of models, supported models and stable models, (2) logic\nprogramming with cardinality atoms and with the semantics of stable models, as\ndefined by Niemela, Simons and Soininen, and (3) of disjunctive logic\nprogramming with the possible-model semantics of Sakama and Inoue."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310063v1", 
    "other_authors": [
        "Victor W. Marek", 
        "Ilkka Niemela", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310063v1", 
    "title": "Logic programs with monotone cardinality atoms", 
    "publish": "2003-10-31T16:56:18Z", 
    "summary": "We investigate mca-programs, that is, logic programs with clauses built of\nmonotone cardinality atoms of the form kX, where k is a non-negative integer\nand X is a finite set of propositional atoms. We develop a theory of\nmca-programs. We demonstrate that the operational concept of the one-step\nprovability operator generalizes to mca-programs, but the generalization\ninvolves nondeterminism. Our main results show that the formalism of\nmca-programs is a common generalization of (1) normal logic programming with\nits semantics of models, supported models and stable models, (2) logic\nprogramming with cardinality atoms and with the semantics of stable models, as\ndefined by Niemela, Simons and Soininen, and (3) of disjunctive logic\nprogramming with the possible-model semantics of Sakama and Inoue."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310063v1", 
    "other_authors": [
        "Victor W. Marek", 
        "Ilkka Niemela", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310063v1", 
    "title": "Logic programs with monotone cardinality atoms", 
    "publish": "2003-10-31T16:56:18Z", 
    "summary": "We investigate mca-programs, that is, logic programs with clauses built of\nmonotone cardinality atoms of the form kX, where k is a non-negative integer\nand X is a finite set of propositional atoms. We develop a theory of\nmca-programs. We demonstrate that the operational concept of the one-step\nprovability operator generalizes to mca-programs, but the generalization\ninvolves nondeterminism. Our main results show that the formalism of\nmca-programs is a common generalization of (1) normal logic programming with\nits semantics of models, supported models and stable models, (2) logic\nprogramming with cardinality atoms and with the semantics of stable models, as\ndefined by Niemela, Simons and Soininen, and (3) of disjunctive logic\nprogramming with the possible-model semantics of Sakama and Inoue."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310063v1", 
    "other_authors": [
        "Victor W. Marek", 
        "Ilkka Niemela", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310063v1", 
    "title": "Logic programs with monotone cardinality atoms", 
    "publish": "2003-10-31T16:56:18Z", 
    "summary": "We investigate mca-programs, that is, logic programs with clauses built of\nmonotone cardinality atoms of the form kX, where k is a non-negative integer\nand X is a finite set of propositional atoms. We develop a theory of\nmca-programs. We demonstrate that the operational concept of the one-step\nprovability operator generalizes to mca-programs, but the generalization\ninvolves nondeterminism. Our main results show that the formalism of\nmca-programs is a common generalization of (1) normal logic programming with\nits semantics of models, supported models and stable models, (2) logic\nprogramming with cardinality atoms and with the semantics of stable models, as\ndefined by Niemela, Simons and Soininen, and (3) of disjunctive logic\nprogramming with the possible-model semantics of Sakama and Inoue."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310063v1", 
    "other_authors": [
        "Victor W. Marek", 
        "Ilkka Niemela", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310063v1", 
    "title": "Logic programs with monotone cardinality atoms", 
    "publish": "2003-10-31T16:56:18Z", 
    "summary": "We investigate mca-programs, that is, logic programs with clauses built of\nmonotone cardinality atoms of the form kX, where k is a non-negative integer\nand X is a finite set of propositional atoms. We develop a theory of\nmca-programs. We demonstrate that the operational concept of the one-step\nprovability operator generalizes to mca-programs, but the generalization\ninvolves nondeterminism. Our main results show that the formalism of\nmca-programs is a common generalization of (1) normal logic programming with\nits semantics of models, supported models and stable models, (2) logic\nprogramming with cardinality atoms and with the semantics of stable models, as\ndefined by Niemela, Simons and Soininen, and (3) of disjunctive logic\nprogramming with the possible-model semantics of Sakama and Inoue."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310063v1", 
    "other_authors": [
        "Victor W. Marek", 
        "Ilkka Niemela", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310063v1", 
    "title": "Logic programs with monotone cardinality atoms", 
    "publish": "2003-10-31T16:56:18Z", 
    "summary": "We investigate mca-programs, that is, logic programs with clauses built of\nmonotone cardinality atoms of the form kX, where k is a non-negative integer\nand X is a finite set of propositional atoms. We develop a theory of\nmca-programs. We demonstrate that the operational concept of the one-step\nprovability operator generalizes to mca-programs, but the generalization\ninvolves nondeterminism. Our main results show that the formalism of\nmca-programs is a common generalization of (1) normal logic programming with\nits semantics of models, supported models and stable models, (2) logic\nprogramming with cardinality atoms and with the semantics of stable models, as\ndefined by Niemela, Simons and Soininen, and (3) of disjunctive logic\nprogramming with the possible-model semantics of Sakama and Inoue."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310063v1", 
    "other_authors": [
        "Victor W. Marek", 
        "Ilkka Niemela", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310063v1", 
    "title": "Logic programs with monotone cardinality atoms", 
    "publish": "2003-10-31T16:56:18Z", 
    "summary": "We investigate mca-programs, that is, logic programs with clauses built of\nmonotone cardinality atoms of the form kX, where k is a non-negative integer\nand X is a finite set of propositional atoms. We develop a theory of\nmca-programs. We demonstrate that the operational concept of the one-step\nprovability operator generalizes to mca-programs, but the generalization\ninvolves nondeterminism. Our main results show that the formalism of\nmca-programs is a common generalization of (1) normal logic programming with\nits semantics of models, supported models and stable models, (2) logic\nprogramming with cardinality atoms and with the semantics of stable models, as\ndefined by Niemela, Simons and Soininen, and (3) of disjunctive logic\nprogramming with the possible-model semantics of Sakama and Inoue."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310063v1", 
    "other_authors": [
        "Victor W. Marek", 
        "Ilkka Niemela", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310063v1", 
    "title": "Logic programs with monotone cardinality atoms", 
    "publish": "2003-10-31T16:56:18Z", 
    "summary": "We investigate mca-programs, that is, logic programs with clauses built of\nmonotone cardinality atoms of the form kX, where k is a non-negative integer\nand X is a finite set of propositional atoms. We develop a theory of\nmca-programs. We demonstrate that the operational concept of the one-step\nprovability operator generalizes to mca-programs, but the generalization\ninvolves nondeterminism. Our main results show that the formalism of\nmca-programs is a common generalization of (1) normal logic programming with\nits semantics of models, supported models and stable models, (2) logic\nprogramming with cardinality atoms and with the semantics of stable models, as\ndefined by Niemela, Simons and Soininen, and (3) of disjunctive logic\nprogramming with the possible-model semantics of Sakama and Inoue."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310063v1", 
    "other_authors": [
        "Victor W. Marek", 
        "Ilkka Niemela", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310063v1", 
    "title": "Logic programs with monotone cardinality atoms", 
    "publish": "2003-10-31T16:56:18Z", 
    "summary": "We investigate mca-programs, that is, logic programs with clauses built of\nmonotone cardinality atoms of the form kX, where k is a non-negative integer\nand X is a finite set of propositional atoms. We develop a theory of\nmca-programs. We demonstrate that the operational concept of the one-step\nprovability operator generalizes to mca-programs, but the generalization\ninvolves nondeterminism. Our main results show that the formalism of\nmca-programs is a common generalization of (1) normal logic programming with\nits semantics of models, supported models and stable models, (2) logic\nprogramming with cardinality atoms and with the semantics of stable models, as\ndefined by Niemela, Simons and Soininen, and (3) of disjunctive logic\nprogramming with the possible-model semantics of Sakama and Inoue."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310063v1", 
    "other_authors": [
        "Victor W. Marek", 
        "Ilkka Niemela", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310063v1", 
    "title": "Logic programs with monotone cardinality atoms", 
    "publish": "2003-10-31T16:56:18Z", 
    "summary": "We investigate mca-programs, that is, logic programs with clauses built of\nmonotone cardinality atoms of the form kX, where k is a non-negative integer\nand X is a finite set of propositional atoms. We develop a theory of\nmca-programs. We demonstrate that the operational concept of the one-step\nprovability operator generalizes to mca-programs, but the generalization\ninvolves nondeterminism. Our main results show that the formalism of\nmca-programs is a common generalization of (1) normal logic programming with\nits semantics of models, supported models and stable models, (2) logic\nprogramming with cardinality atoms and with the semantics of stable models, as\ndefined by Niemela, Simons and Soininen, and (3) of disjunctive logic\nprogramming with the possible-model semantics of Sakama and Inoue."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310063v1", 
    "other_authors": [
        "Victor W. Marek", 
        "Ilkka Niemela", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310063v1", 
    "title": "Logic programs with monotone cardinality atoms", 
    "publish": "2003-10-31T16:56:18Z", 
    "summary": "We investigate mca-programs, that is, logic programs with clauses built of\nmonotone cardinality atoms of the form kX, where k is a non-negative integer\nand X is a finite set of propositional atoms. We develop a theory of\nmca-programs. We demonstrate that the operational concept of the one-step\nprovability operator generalizes to mca-programs, but the generalization\ninvolves nondeterminism. Our main results show that the formalism of\nmca-programs is a common generalization of (1) normal logic programming with\nits semantics of models, supported models and stable models, (2) logic\nprogramming with cardinality atoms and with the semantics of stable models, as\ndefined by Niemela, Simons and Soininen, and (3) of disjunctive logic\nprogramming with the possible-model semantics of Sakama and Inoue."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310063v1", 
    "other_authors": [
        "Victor W. Marek", 
        "Ilkka Niemela", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310063v1", 
    "title": "Logic programs with monotone cardinality atoms", 
    "publish": "2003-10-31T16:56:18Z", 
    "summary": "We investigate mca-programs, that is, logic programs with clauses built of\nmonotone cardinality atoms of the form kX, where k is a non-negative integer\nand X is a finite set of propositional atoms. We develop a theory of\nmca-programs. We demonstrate that the operational concept of the one-step\nprovability operator generalizes to mca-programs, but the generalization\ninvolves nondeterminism. Our main results show that the formalism of\nmca-programs is a common generalization of (1) normal logic programming with\nits semantics of models, supported models and stable models, (2) logic\nprogramming with cardinality atoms and with the semantics of stable models, as\ndefined by Niemela, Simons and Soininen, and (3) of disjunctive logic\nprogramming with the possible-model semantics of Sakama and Inoue."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310063v1", 
    "other_authors": [
        "Victor W. Marek", 
        "Ilkka Niemela", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310063v1", 
    "title": "Logic programs with monotone cardinality atoms", 
    "publish": "2003-10-31T16:56:18Z", 
    "summary": "We investigate mca-programs, that is, logic programs with clauses built of\nmonotone cardinality atoms of the form kX, where k is a non-negative integer\nand X is a finite set of propositional atoms. We develop a theory of\nmca-programs. We demonstrate that the operational concept of the one-step\nprovability operator generalizes to mca-programs, but the generalization\ninvolves nondeterminism. Our main results show that the formalism of\nmca-programs is a common generalization of (1) normal logic programming with\nits semantics of models, supported models and stable models, (2) logic\nprogramming with cardinality atoms and with the semantics of stable models, as\ndefined by Niemela, Simons and Soininen, and (3) of disjunctive logic\nprogramming with the possible-model semantics of Sakama and Inoue."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310063v1", 
    "other_authors": [
        "Victor W. Marek", 
        "Ilkka Niemela", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310063v1", 
    "title": "Logic programs with monotone cardinality atoms", 
    "publish": "2003-10-31T16:56:18Z", 
    "summary": "We investigate mca-programs, that is, logic programs with clauses built of\nmonotone cardinality atoms of the form kX, where k is a non-negative integer\nand X is a finite set of propositional atoms. We develop a theory of\nmca-programs. We demonstrate that the operational concept of the one-step\nprovability operator generalizes to mca-programs, but the generalization\ninvolves nondeterminism. Our main results show that the formalism of\nmca-programs is a common generalization of (1) normal logic programming with\nits semantics of models, supported models and stable models, (2) logic\nprogramming with cardinality atoms and with the semantics of stable models, as\ndefined by Niemela, Simons and Soininen, and (3) of disjunctive logic\nprogramming with the possible-model semantics of Sakama and Inoue."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310063v1", 
    "other_authors": [
        "Victor W. Marek", 
        "Ilkka Niemela", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310063v1", 
    "title": "Logic programs with monotone cardinality atoms", 
    "publish": "2003-10-31T16:56:18Z", 
    "summary": "We investigate mca-programs, that is, logic programs with clauses built of\nmonotone cardinality atoms of the form kX, where k is a non-negative integer\nand X is a finite set of propositional atoms. We develop a theory of\nmca-programs. We demonstrate that the operational concept of the one-step\nprovability operator generalizes to mca-programs, but the generalization\ninvolves nondeterminism. Our main results show that the formalism of\nmca-programs is a common generalization of (1) normal logic programming with\nits semantics of models, supported models and stable models, (2) logic\nprogramming with cardinality atoms and with the semantics of stable models, as\ndefined by Niemela, Simons and Soininen, and (3) of disjunctive logic\nprogramming with the possible-model semantics of Sakama and Inoue."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310063v1", 
    "other_authors": [
        "Victor W. Marek", 
        "Ilkka Niemela", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310063v1", 
    "title": "Logic programs with monotone cardinality atoms", 
    "publish": "2003-10-31T16:56:18Z", 
    "summary": "We investigate mca-programs, that is, logic programs with clauses built of\nmonotone cardinality atoms of the form kX, where k is a non-negative integer\nand X is a finite set of propositional atoms. We develop a theory of\nmca-programs. We demonstrate that the operational concept of the one-step\nprovability operator generalizes to mca-programs, but the generalization\ninvolves nondeterminism. Our main results show that the formalism of\nmca-programs is a common generalization of (1) normal logic programming with\nits semantics of models, supported models and stable models, (2) logic\nprogramming with cardinality atoms and with the semantics of stable models, as\ndefined by Niemela, Simons and Soininen, and (3) of disjunctive logic\nprogramming with the possible-model semantics of Sakama and Inoue."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310063v1", 
    "other_authors": [
        "Victor W. Marek", 
        "Ilkka Niemela", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310063v1", 
    "title": "Logic programs with monotone cardinality atoms", 
    "publish": "2003-10-31T16:56:18Z", 
    "summary": "We investigate mca-programs, that is, logic programs with clauses built of\nmonotone cardinality atoms of the form kX, where k is a non-negative integer\nand X is a finite set of propositional atoms. We develop a theory of\nmca-programs. We demonstrate that the operational concept of the one-step\nprovability operator generalizes to mca-programs, but the generalization\ninvolves nondeterminism. Our main results show that the formalism of\nmca-programs is a common generalization of (1) normal logic programming with\nits semantics of models, supported models and stable models, (2) logic\nprogramming with cardinality atoms and with the semantics of stable models, as\ndefined by Niemela, Simons and Soininen, and (3) of disjunctive logic\nprogramming with the possible-model semantics of Sakama and Inoue."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310063v1", 
    "other_authors": [
        "Victor W. Marek", 
        "Ilkka Niemela", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310063v1", 
    "title": "Logic programs with monotone cardinality atoms", 
    "publish": "2003-10-31T16:56:18Z", 
    "summary": "We investigate mca-programs, that is, logic programs with clauses built of\nmonotone cardinality atoms of the form kX, where k is a non-negative integer\nand X is a finite set of propositional atoms. We develop a theory of\nmca-programs. We demonstrate that the operational concept of the one-step\nprovability operator generalizes to mca-programs, but the generalization\ninvolves nondeterminism. Our main results show that the formalism of\nmca-programs is a common generalization of (1) normal logic programming with\nits semantics of models, supported models and stable models, (2) logic\nprogramming with cardinality atoms and with the semantics of stable models, as\ndefined by Niemela, Simons and Soininen, and (3) of disjunctive logic\nprogramming with the possible-model semantics of Sakama and Inoue."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310063v1", 
    "other_authors": [
        "Victor W. Marek", 
        "Ilkka Niemela", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310063v1", 
    "title": "Logic programs with monotone cardinality atoms", 
    "publish": "2003-10-31T16:56:18Z", 
    "summary": "We investigate mca-programs, that is, logic programs with clauses built of\nmonotone cardinality atoms of the form kX, where k is a non-negative integer\nand X is a finite set of propositional atoms. We develop a theory of\nmca-programs. We demonstrate that the operational concept of the one-step\nprovability operator generalizes to mca-programs, but the generalization\ninvolves nondeterminism. Our main results show that the formalism of\nmca-programs is a common generalization of (1) normal logic programming with\nits semantics of models, supported models and stable models, (2) logic\nprogramming with cardinality atoms and with the semantics of stable models, as\ndefined by Niemela, Simons and Soininen, and (3) of disjunctive logic\nprogramming with the possible-model semantics of Sakama and Inoue."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310063v1", 
    "other_authors": [
        "Victor W. Marek", 
        "Ilkka Niemela", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310063v1", 
    "title": "Logic programs with monotone cardinality atoms", 
    "publish": "2003-10-31T16:56:18Z", 
    "summary": "We investigate mca-programs, that is, logic programs with clauses built of\nmonotone cardinality atoms of the form kX, where k is a non-negative integer\nand X is a finite set of propositional atoms. We develop a theory of\nmca-programs. We demonstrate that the operational concept of the one-step\nprovability operator generalizes to mca-programs, but the generalization\ninvolves nondeterminism. Our main results show that the formalism of\nmca-programs is a common generalization of (1) normal logic programming with\nits semantics of models, supported models and stable models, (2) logic\nprogramming with cardinality atoms and with the semantics of stable models, as\ndefined by Niemela, Simons and Soininen, and (3) of disjunctive logic\nprogramming with the possible-model semantics of Sakama and Inoue."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310063v1", 
    "other_authors": [
        "Victor W. Marek", 
        "Ilkka Niemela", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310063v1", 
    "title": "Logic programs with monotone cardinality atoms", 
    "publish": "2003-10-31T16:56:18Z", 
    "summary": "We investigate mca-programs, that is, logic programs with clauses built of\nmonotone cardinality atoms of the form kX, where k is a non-negative integer\nand X is a finite set of propositional atoms. We develop a theory of\nmca-programs. We demonstrate that the operational concept of the one-step\nprovability operator generalizes to mca-programs, but the generalization\ninvolves nondeterminism. Our main results show that the formalism of\nmca-programs is a common generalization of (1) normal logic programming with\nits semantics of models, supported models and stable models, (2) logic\nprogramming with cardinality atoms and with the semantics of stable models, as\ndefined by Niemela, Simons and Soininen, and (3) of disjunctive logic\nprogramming with the possible-model semantics of Sakama and Inoue."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310063v1", 
    "other_authors": [
        "Victor W. Marek", 
        "Ilkka Niemela", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310063v1", 
    "title": "Logic programs with monotone cardinality atoms", 
    "publish": "2003-10-31T16:56:18Z", 
    "summary": "We investigate mca-programs, that is, logic programs with clauses built of\nmonotone cardinality atoms of the form kX, where k is a non-negative integer\nand X is a finite set of propositional atoms. We develop a theory of\nmca-programs. We demonstrate that the operational concept of the one-step\nprovability operator generalizes to mca-programs, but the generalization\ninvolves nondeterminism. Our main results show that the formalism of\nmca-programs is a common generalization of (1) normal logic programming with\nits semantics of models, supported models and stable models, (2) logic\nprogramming with cardinality atoms and with the semantics of stable models, as\ndefined by Niemela, Simons and Soininen, and (3) of disjunctive logic\nprogramming with the possible-model semantics of Sakama and Inoue."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310063v1", 
    "other_authors": [
        "Victor W. Marek", 
        "Ilkka Niemela", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310063v1", 
    "title": "Logic programs with monotone cardinality atoms", 
    "publish": "2003-10-31T16:56:18Z", 
    "summary": "We investigate mca-programs, that is, logic programs with clauses built of\nmonotone cardinality atoms of the form kX, where k is a non-negative integer\nand X is a finite set of propositional atoms. We develop a theory of\nmca-programs. We demonstrate that the operational concept of the one-step\nprovability operator generalizes to mca-programs, but the generalization\ninvolves nondeterminism. Our main results show that the formalism of\nmca-programs is a common generalization of (1) normal logic programming with\nits semantics of models, supported models and stable models, (2) logic\nprogramming with cardinality atoms and with the semantics of stable models, as\ndefined by Niemela, Simons and Soininen, and (3) of disjunctive logic\nprogramming with the possible-model semantics of Sakama and Inoue."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310063v1", 
    "other_authors": [
        "Victor W. Marek", 
        "Ilkka Niemela", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310063v1", 
    "title": "Logic programs with monotone cardinality atoms", 
    "publish": "2003-10-31T16:56:18Z", 
    "summary": "We investigate mca-programs, that is, logic programs with clauses built of\nmonotone cardinality atoms of the form kX, where k is a non-negative integer\nand X is a finite set of propositional atoms. We develop a theory of\nmca-programs. We demonstrate that the operational concept of the one-step\nprovability operator generalizes to mca-programs, but the generalization\ninvolves nondeterminism. Our main results show that the formalism of\nmca-programs is a common generalization of (1) normal logic programming with\nits semantics of models, supported models and stable models, (2) logic\nprogramming with cardinality atoms and with the semantics of stable models, as\ndefined by Niemela, Simons and Soininen, and (3) of disjunctive logic\nprogramming with the possible-model semantics of Sakama and Inoue."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310063v1", 
    "other_authors": [
        "Victor W. Marek", 
        "Ilkka Niemela", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310063v1", 
    "title": "Logic programs with monotone cardinality atoms", 
    "publish": "2003-10-31T16:56:18Z", 
    "summary": "We investigate mca-programs, that is, logic programs with clauses built of\nmonotone cardinality atoms of the form kX, where k is a non-negative integer\nand X is a finite set of propositional atoms. We develop a theory of\nmca-programs. We demonstrate that the operational concept of the one-step\nprovability operator generalizes to mca-programs, but the generalization\ninvolves nondeterminism. Our main results show that the formalism of\nmca-programs is a common generalization of (1) normal logic programming with\nits semantics of models, supported models and stable models, (2) logic\nprogramming with cardinality atoms and with the semantics of stable models, as\ndefined by Niemela, Simons and Soininen, and (3) of disjunctive logic\nprogramming with the possible-model semantics of Sakama and Inoue."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310063v1", 
    "other_authors": [
        "Victor W. Marek", 
        "Ilkka Niemela", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310063v1", 
    "title": "Logic programs with monotone cardinality atoms", 
    "publish": "2003-10-31T16:56:18Z", 
    "summary": "We investigate mca-programs, that is, logic programs with clauses built of\nmonotone cardinality atoms of the form kX, where k is a non-negative integer\nand X is a finite set of propositional atoms. We develop a theory of\nmca-programs. We demonstrate that the operational concept of the one-step\nprovability operator generalizes to mca-programs, but the generalization\ninvolves nondeterminism. Our main results show that the formalism of\nmca-programs is a common generalization of (1) normal logic programming with\nits semantics of models, supported models and stable models, (2) logic\nprogramming with cardinality atoms and with the semantics of stable models, as\ndefined by Niemela, Simons and Soininen, and (3) of disjunctive logic\nprogramming with the possible-model semantics of Sakama and Inoue."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310063v1", 
    "other_authors": [
        "Victor W. Marek", 
        "Ilkka Niemela", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310063v1", 
    "title": "Logic programs with monotone cardinality atoms", 
    "publish": "2003-10-31T16:56:18Z", 
    "summary": "We investigate mca-programs, that is, logic programs with clauses built of\nmonotone cardinality atoms of the form kX, where k is a non-negative integer\nand X is a finite set of propositional atoms. We develop a theory of\nmca-programs. We demonstrate that the operational concept of the one-step\nprovability operator generalizes to mca-programs, but the generalization\ninvolves nondeterminism. Our main results show that the formalism of\nmca-programs is a common generalization of (1) normal logic programming with\nits semantics of models, supported models and stable models, (2) logic\nprogramming with cardinality atoms and with the semantics of stable models, as\ndefined by Niemela, Simons and Soininen, and (3) of disjunctive logic\nprogramming with the possible-model semantics of Sakama and Inoue."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310063v1", 
    "other_authors": [
        "Victor W. Marek", 
        "Ilkka Niemela", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310063v1", 
    "title": "Logic programs with monotone cardinality atoms", 
    "publish": "2003-10-31T16:56:18Z", 
    "summary": "We investigate mca-programs, that is, logic programs with clauses built of\nmonotone cardinality atoms of the form kX, where k is a non-negative integer\nand X is a finite set of propositional atoms. We develop a theory of\nmca-programs. We demonstrate that the operational concept of the one-step\nprovability operator generalizes to mca-programs, but the generalization\ninvolves nondeterminism. Our main results show that the formalism of\nmca-programs is a common generalization of (1) normal logic programming with\nits semantics of models, supported models and stable models, (2) logic\nprogramming with cardinality atoms and with the semantics of stable models, as\ndefined by Niemela, Simons and Soininen, and (3) of disjunctive logic\nprogramming with the possible-model semantics of Sakama and Inoue."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310063v1", 
    "other_authors": [
        "Victor W. Marek", 
        "Ilkka Niemela", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310063v1", 
    "title": "Logic programs with monotone cardinality atoms", 
    "publish": "2003-10-31T16:56:18Z", 
    "summary": "We investigate mca-programs, that is, logic programs with clauses built of\nmonotone cardinality atoms of the form kX, where k is a non-negative integer\nand X is a finite set of propositional atoms. We develop a theory of\nmca-programs. We demonstrate that the operational concept of the one-step\nprovability operator generalizes to mca-programs, but the generalization\ninvolves nondeterminism. Our main results show that the formalism of\nmca-programs is a common generalization of (1) normal logic programming with\nits semantics of models, supported models and stable models, (2) logic\nprogramming with cardinality atoms and with the semantics of stable models, as\ndefined by Niemela, Simons and Soininen, and (3) of disjunctive logic\nprogramming with the possible-model semantics of Sakama and Inoue."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310063v1", 
    "other_authors": [
        "Victor W. Marek", 
        "Ilkka Niemela", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310063v1", 
    "title": "Logic programs with monotone cardinality atoms", 
    "publish": "2003-10-31T16:56:18Z", 
    "summary": "We investigate mca-programs, that is, logic programs with clauses built of\nmonotone cardinality atoms of the form kX, where k is a non-negative integer\nand X is a finite set of propositional atoms. We develop a theory of\nmca-programs. We demonstrate that the operational concept of the one-step\nprovability operator generalizes to mca-programs, but the generalization\ninvolves nondeterminism. Our main results show that the formalism of\nmca-programs is a common generalization of (1) normal logic programming with\nits semantics of models, supported models and stable models, (2) logic\nprogramming with cardinality atoms and with the semantics of stable models, as\ndefined by Niemela, Simons and Soininen, and (3) of disjunctive logic\nprogramming with the possible-model semantics of Sakama and Inoue."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310063v1", 
    "other_authors": [
        "Victor W. Marek", 
        "Ilkka Niemela", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310063v1", 
    "title": "Logic programs with monotone cardinality atoms", 
    "publish": "2003-10-31T16:56:18Z", 
    "summary": "We investigate mca-programs, that is, logic programs with clauses built of\nmonotone cardinality atoms of the form kX, where k is a non-negative integer\nand X is a finite set of propositional atoms. We develop a theory of\nmca-programs. We demonstrate that the operational concept of the one-step\nprovability operator generalizes to mca-programs, but the generalization\ninvolves nondeterminism. Our main results show that the formalism of\nmca-programs is a common generalization of (1) normal logic programming with\nits semantics of models, supported models and stable models, (2) logic\nprogramming with cardinality atoms and with the semantics of stable models, as\ndefined by Niemela, Simons and Soininen, and (3) of disjunctive logic\nprogramming with the possible-model semantics of Sakama and Inoue."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310063v1", 
    "other_authors": [
        "Victor W. Marek", 
        "Ilkka Niemela", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310063v1", 
    "title": "Logic programs with monotone cardinality atoms", 
    "publish": "2003-10-31T16:56:18Z", 
    "summary": "We investigate mca-programs, that is, logic programs with clauses built of\nmonotone cardinality atoms of the form kX, where k is a non-negative integer\nand X is a finite set of propositional atoms. We develop a theory of\nmca-programs. We demonstrate that the operational concept of the one-step\nprovability operator generalizes to mca-programs, but the generalization\ninvolves nondeterminism. Our main results show that the formalism of\nmca-programs is a common generalization of (1) normal logic programming with\nits semantics of models, supported models and stable models, (2) logic\nprogramming with cardinality atoms and with the semantics of stable models, as\ndefined by Niemela, Simons and Soininen, and (3) of disjunctive logic\nprogramming with the possible-model semantics of Sakama and Inoue."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310063v1", 
    "other_authors": [
        "Victor W. Marek", 
        "Ilkka Niemela", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310063v1", 
    "title": "Logic programs with monotone cardinality atoms", 
    "publish": "2003-10-31T16:56:18Z", 
    "summary": "We investigate mca-programs, that is, logic programs with clauses built of\nmonotone cardinality atoms of the form kX, where k is a non-negative integer\nand X is a finite set of propositional atoms. We develop a theory of\nmca-programs. We demonstrate that the operational concept of the one-step\nprovability operator generalizes to mca-programs, but the generalization\ninvolves nondeterminism. Our main results show that the formalism of\nmca-programs is a common generalization of (1) normal logic programming with\nits semantics of models, supported models and stable models, (2) logic\nprogramming with cardinality atoms and with the semantics of stable models, as\ndefined by Niemela, Simons and Soininen, and (3) of disjunctive logic\nprogramming with the possible-model semantics of Sakama and Inoue."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310063v1", 
    "other_authors": [
        "Victor W. Marek", 
        "Ilkka Niemela", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310063v1", 
    "title": "Logic programs with monotone cardinality atoms", 
    "publish": "2003-10-31T16:56:18Z", 
    "summary": "We investigate mca-programs, that is, logic programs with clauses built of\nmonotone cardinality atoms of the form kX, where k is a non-negative integer\nand X is a finite set of propositional atoms. We develop a theory of\nmca-programs. We demonstrate that the operational concept of the one-step\nprovability operator generalizes to mca-programs, but the generalization\ninvolves nondeterminism. Our main results show that the formalism of\nmca-programs is a common generalization of (1) normal logic programming with\nits semantics of models, supported models and stable models, (2) logic\nprogramming with cardinality atoms and with the semantics of stable models, as\ndefined by Niemela, Simons and Soininen, and (3) of disjunctive logic\nprogramming with the possible-model semantics of Sakama and Inoue."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310063v1", 
    "other_authors": [
        "Victor W. Marek", 
        "Ilkka Niemela", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310063v1", 
    "title": "Logic programs with monotone cardinality atoms", 
    "publish": "2003-10-31T16:56:18Z", 
    "summary": "We investigate mca-programs, that is, logic programs with clauses built of\nmonotone cardinality atoms of the form kX, where k is a non-negative integer\nand X is a finite set of propositional atoms. We develop a theory of\nmca-programs. We demonstrate that the operational concept of the one-step\nprovability operator generalizes to mca-programs, but the generalization\ninvolves nondeterminism. Our main results show that the formalism of\nmca-programs is a common generalization of (1) normal logic programming with\nits semantics of models, supported models and stable models, (2) logic\nprogramming with cardinality atoms and with the semantics of stable models, as\ndefined by Niemela, Simons and Soininen, and (3) of disjunctive logic\nprogramming with the possible-model semantics of Sakama and Inoue."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310063v1", 
    "other_authors": [
        "Victor W. Marek", 
        "Ilkka Niemela", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310063v1", 
    "title": "Logic programs with monotone cardinality atoms", 
    "publish": "2003-10-31T16:56:18Z", 
    "summary": "We investigate mca-programs, that is, logic programs with clauses built of\nmonotone cardinality atoms of the form kX, where k is a non-negative integer\nand X is a finite set of propositional atoms. We develop a theory of\nmca-programs. We demonstrate that the operational concept of the one-step\nprovability operator generalizes to mca-programs, but the generalization\ninvolves nondeterminism. Our main results show that the formalism of\nmca-programs is a common generalization of (1) normal logic programming with\nits semantics of models, supported models and stable models, (2) logic\nprogramming with cardinality atoms and with the semantics of stable models, as\ndefined by Niemela, Simons and Soininen, and (3) of disjunctive logic\nprogramming with the possible-model semantics of Sakama and Inoue."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310063v1", 
    "other_authors": [
        "Victor W. Marek", 
        "Ilkka Niemela", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310063v1", 
    "title": "Logic programs with monotone cardinality atoms", 
    "publish": "2003-10-31T16:56:18Z", 
    "summary": "We investigate mca-programs, that is, logic programs with clauses built of\nmonotone cardinality atoms of the form kX, where k is a non-negative integer\nand X is a finite set of propositional atoms. We develop a theory of\nmca-programs. We demonstrate that the operational concept of the one-step\nprovability operator generalizes to mca-programs, but the generalization\ninvolves nondeterminism. Our main results show that the formalism of\nmca-programs is a common generalization of (1) normal logic programming with\nits semantics of models, supported models and stable models, (2) logic\nprogramming with cardinality atoms and with the semantics of stable models, as\ndefined by Niemela, Simons and Soininen, and (3) of disjunctive logic\nprogramming with the possible-model semantics of Sakama and Inoue."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310063v1", 
    "other_authors": [
        "Victor W. Marek", 
        "Ilkka Niemela", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310063v1", 
    "title": "Logic programs with monotone cardinality atoms", 
    "publish": "2003-10-31T16:56:18Z", 
    "summary": "We investigate mca-programs, that is, logic programs with clauses built of\nmonotone cardinality atoms of the form kX, where k is a non-negative integer\nand X is a finite set of propositional atoms. We develop a theory of\nmca-programs. We demonstrate that the operational concept of the one-step\nprovability operator generalizes to mca-programs, but the generalization\ninvolves nondeterminism. Our main results show that the formalism of\nmca-programs is a common generalization of (1) normal logic programming with\nits semantics of models, supported models and stable models, (2) logic\nprogramming with cardinality atoms and with the semantics of stable models, as\ndefined by Niemela, Simons and Soininen, and (3) of disjunctive logic\nprogramming with the possible-model semantics of Sakama and Inoue."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310063v1", 
    "other_authors": [
        "Victor W. Marek", 
        "Ilkka Niemela", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310063v1", 
    "title": "Logic programs with monotone cardinality atoms", 
    "publish": "2003-10-31T16:56:18Z", 
    "summary": "We investigate mca-programs, that is, logic programs with clauses built of\nmonotone cardinality atoms of the form kX, where k is a non-negative integer\nand X is a finite set of propositional atoms. We develop a theory of\nmca-programs. We demonstrate that the operational concept of the one-step\nprovability operator generalizes to mca-programs, but the generalization\ninvolves nondeterminism. Our main results show that the formalism of\nmca-programs is a common generalization of (1) normal logic programming with\nits semantics of models, supported models and stable models, (2) logic\nprogramming with cardinality atoms and with the semantics of stable models, as\ndefined by Niemela, Simons and Soininen, and (3) of disjunctive logic\nprogramming with the possible-model semantics of Sakama and Inoue."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310064v1", 
    "other_authors": [
        "Michael R. Dransfield", 
        "Victor W. Marek", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310064v1", 
    "title": "Satisfiability and computing van der Waerden numbers", 
    "publish": "2003-10-31T17:05:58Z", 
    "summary": "In this paper we bring together the areas of combinatorics and propositional\nsatisfiability. Many combinatorial theorems establish, often constructively,\nthe existence of positive integer functions, without actually providing their\nclosed algebraic form or tight lower and upper bounds. The area of Ramsey\ntheory is especially rich in such results. Using the problem of computing van\nder Waerden numbers as an example, we show that these problems can be\nrepresented by parameterized propositional theories in such a way that\ndecisions concerning their satisfiability determine the numbers (function) in\nquestion. We show that by using general-purpose complete and local-search\ntechniques for testing propositional satisfiability, this approach becomes\neffective -- competitive with specialized approaches. By following it, we were\nable to obtain several new results pertaining to the problem of computing van\nder Waerden numbers. We also note that due to their properties, especially\ntheir structural simplicity and computational hardness, propositional theories\nthat arise in this research can be of use in development, testing and\nbenchmarking of SAT solvers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310064v1", 
    "other_authors": [
        "Michael R. Dransfield", 
        "Victor W. Marek", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310064v1", 
    "title": "Satisfiability and computing van der Waerden numbers", 
    "publish": "2003-10-31T17:05:58Z", 
    "summary": "In this paper we bring together the areas of combinatorics and propositional\nsatisfiability. Many combinatorial theorems establish, often constructively,\nthe existence of positive integer functions, without actually providing their\nclosed algebraic form or tight lower and upper bounds. The area of Ramsey\ntheory is especially rich in such results. Using the problem of computing van\nder Waerden numbers as an example, we show that these problems can be\nrepresented by parameterized propositional theories in such a way that\ndecisions concerning their satisfiability determine the numbers (function) in\nquestion. We show that by using general-purpose complete and local-search\ntechniques for testing propositional satisfiability, this approach becomes\neffective -- competitive with specialized approaches. By following it, we were\nable to obtain several new results pertaining to the problem of computing van\nder Waerden numbers. We also note that due to their properties, especially\ntheir structural simplicity and computational hardness, propositional theories\nthat arise in this research can be of use in development, testing and\nbenchmarking of SAT solvers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310064v1", 
    "other_authors": [
        "Michael R. Dransfield", 
        "Victor W. Marek", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310064v1", 
    "title": "Satisfiability and computing van der Waerden numbers", 
    "publish": "2003-10-31T17:05:58Z", 
    "summary": "In this paper we bring together the areas of combinatorics and propositional\nsatisfiability. Many combinatorial theorems establish, often constructively,\nthe existence of positive integer functions, without actually providing their\nclosed algebraic form or tight lower and upper bounds. The area of Ramsey\ntheory is especially rich in such results. Using the problem of computing van\nder Waerden numbers as an example, we show that these problems can be\nrepresented by parameterized propositional theories in such a way that\ndecisions concerning their satisfiability determine the numbers (function) in\nquestion. We show that by using general-purpose complete and local-search\ntechniques for testing propositional satisfiability, this approach becomes\neffective -- competitive with specialized approaches. By following it, we were\nable to obtain several new results pertaining to the problem of computing van\nder Waerden numbers. We also note that due to their properties, especially\ntheir structural simplicity and computational hardness, propositional theories\nthat arise in this research can be of use in development, testing and\nbenchmarking of SAT solvers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310064v1", 
    "other_authors": [
        "Michael R. Dransfield", 
        "Victor W. Marek", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310064v1", 
    "title": "Satisfiability and computing van der Waerden numbers", 
    "publish": "2003-10-31T17:05:58Z", 
    "summary": "In this paper we bring together the areas of combinatorics and propositional\nsatisfiability. Many combinatorial theorems establish, often constructively,\nthe existence of positive integer functions, without actually providing their\nclosed algebraic form or tight lower and upper bounds. The area of Ramsey\ntheory is especially rich in such results. Using the problem of computing van\nder Waerden numbers as an example, we show that these problems can be\nrepresented by parameterized propositional theories in such a way that\ndecisions concerning their satisfiability determine the numbers (function) in\nquestion. We show that by using general-purpose complete and local-search\ntechniques for testing propositional satisfiability, this approach becomes\neffective -- competitive with specialized approaches. By following it, we were\nable to obtain several new results pertaining to the problem of computing van\nder Waerden numbers. We also note that due to their properties, especially\ntheir structural simplicity and computational hardness, propositional theories\nthat arise in this research can be of use in development, testing and\nbenchmarking of SAT solvers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310064v1", 
    "other_authors": [
        "Michael R. Dransfield", 
        "Victor W. Marek", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310064v1", 
    "title": "Satisfiability and computing van der Waerden numbers", 
    "publish": "2003-10-31T17:05:58Z", 
    "summary": "In this paper we bring together the areas of combinatorics and propositional\nsatisfiability. Many combinatorial theorems establish, often constructively,\nthe existence of positive integer functions, without actually providing their\nclosed algebraic form or tight lower and upper bounds. The area of Ramsey\ntheory is especially rich in such results. Using the problem of computing van\nder Waerden numbers as an example, we show that these problems can be\nrepresented by parameterized propositional theories in such a way that\ndecisions concerning their satisfiability determine the numbers (function) in\nquestion. We show that by using general-purpose complete and local-search\ntechniques for testing propositional satisfiability, this approach becomes\neffective -- competitive with specialized approaches. By following it, we were\nable to obtain several new results pertaining to the problem of computing van\nder Waerden numbers. We also note that due to their properties, especially\ntheir structural simplicity and computational hardness, propositional theories\nthat arise in this research can be of use in development, testing and\nbenchmarking of SAT solvers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310064v1", 
    "other_authors": [
        "Michael R. Dransfield", 
        "Victor W. Marek", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310064v1", 
    "title": "Satisfiability and computing van der Waerden numbers", 
    "publish": "2003-10-31T17:05:58Z", 
    "summary": "In this paper we bring together the areas of combinatorics and propositional\nsatisfiability. Many combinatorial theorems establish, often constructively,\nthe existence of positive integer functions, without actually providing their\nclosed algebraic form or tight lower and upper bounds. The area of Ramsey\ntheory is especially rich in such results. Using the problem of computing van\nder Waerden numbers as an example, we show that these problems can be\nrepresented by parameterized propositional theories in such a way that\ndecisions concerning their satisfiability determine the numbers (function) in\nquestion. We show that by using general-purpose complete and local-search\ntechniques for testing propositional satisfiability, this approach becomes\neffective -- competitive with specialized approaches. By following it, we were\nable to obtain several new results pertaining to the problem of computing van\nder Waerden numbers. We also note that due to their properties, especially\ntheir structural simplicity and computational hardness, propositional theories\nthat arise in this research can be of use in development, testing and\nbenchmarking of SAT solvers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310064v1", 
    "other_authors": [
        "Michael R. Dransfield", 
        "Victor W. Marek", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310064v1", 
    "title": "Satisfiability and computing van der Waerden numbers", 
    "publish": "2003-10-31T17:05:58Z", 
    "summary": "In this paper we bring together the areas of combinatorics and propositional\nsatisfiability. Many combinatorial theorems establish, often constructively,\nthe existence of positive integer functions, without actually providing their\nclosed algebraic form or tight lower and upper bounds. The area of Ramsey\ntheory is especially rich in such results. Using the problem of computing van\nder Waerden numbers as an example, we show that these problems can be\nrepresented by parameterized propositional theories in such a way that\ndecisions concerning their satisfiability determine the numbers (function) in\nquestion. We show that by using general-purpose complete and local-search\ntechniques for testing propositional satisfiability, this approach becomes\neffective -- competitive with specialized approaches. By following it, we were\nable to obtain several new results pertaining to the problem of computing van\nder Waerden numbers. We also note that due to their properties, especially\ntheir structural simplicity and computational hardness, propositional theories\nthat arise in this research can be of use in development, testing and\nbenchmarking of SAT solvers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310064v1", 
    "other_authors": [
        "Michael R. Dransfield", 
        "Victor W. Marek", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310064v1", 
    "title": "Satisfiability and computing van der Waerden numbers", 
    "publish": "2003-10-31T17:05:58Z", 
    "summary": "In this paper we bring together the areas of combinatorics and propositional\nsatisfiability. Many combinatorial theorems establish, often constructively,\nthe existence of positive integer functions, without actually providing their\nclosed algebraic form or tight lower and upper bounds. The area of Ramsey\ntheory is especially rich in such results. Using the problem of computing van\nder Waerden numbers as an example, we show that these problems can be\nrepresented by parameterized propositional theories in such a way that\ndecisions concerning their satisfiability determine the numbers (function) in\nquestion. We show that by using general-purpose complete and local-search\ntechniques for testing propositional satisfiability, this approach becomes\neffective -- competitive with specialized approaches. By following it, we were\nable to obtain several new results pertaining to the problem of computing van\nder Waerden numbers. We also note that due to their properties, especially\ntheir structural simplicity and computational hardness, propositional theories\nthat arise in this research can be of use in development, testing and\nbenchmarking of SAT solvers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310064v1", 
    "other_authors": [
        "Michael R. Dransfield", 
        "Victor W. Marek", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310064v1", 
    "title": "Satisfiability and computing van der Waerden numbers", 
    "publish": "2003-10-31T17:05:58Z", 
    "summary": "In this paper we bring together the areas of combinatorics and propositional\nsatisfiability. Many combinatorial theorems establish, often constructively,\nthe existence of positive integer functions, without actually providing their\nclosed algebraic form or tight lower and upper bounds. The area of Ramsey\ntheory is especially rich in such results. Using the problem of computing van\nder Waerden numbers as an example, we show that these problems can be\nrepresented by parameterized propositional theories in such a way that\ndecisions concerning their satisfiability determine the numbers (function) in\nquestion. We show that by using general-purpose complete and local-search\ntechniques for testing propositional satisfiability, this approach becomes\neffective -- competitive with specialized approaches. By following it, we were\nable to obtain several new results pertaining to the problem of computing van\nder Waerden numbers. We also note that due to their properties, especially\ntheir structural simplicity and computational hardness, propositional theories\nthat arise in this research can be of use in development, testing and\nbenchmarking of SAT solvers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310064v1", 
    "other_authors": [
        "Michael R. Dransfield", 
        "Victor W. Marek", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310064v1", 
    "title": "Satisfiability and computing van der Waerden numbers", 
    "publish": "2003-10-31T17:05:58Z", 
    "summary": "In this paper we bring together the areas of combinatorics and propositional\nsatisfiability. Many combinatorial theorems establish, often constructively,\nthe existence of positive integer functions, without actually providing their\nclosed algebraic form or tight lower and upper bounds. The area of Ramsey\ntheory is especially rich in such results. Using the problem of computing van\nder Waerden numbers as an example, we show that these problems can be\nrepresented by parameterized propositional theories in such a way that\ndecisions concerning their satisfiability determine the numbers (function) in\nquestion. We show that by using general-purpose complete and local-search\ntechniques for testing propositional satisfiability, this approach becomes\neffective -- competitive with specialized approaches. By following it, we were\nable to obtain several new results pertaining to the problem of computing van\nder Waerden numbers. We also note that due to their properties, especially\ntheir structural simplicity and computational hardness, propositional theories\nthat arise in this research can be of use in development, testing and\nbenchmarking of SAT solvers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310064v1", 
    "other_authors": [
        "Michael R. Dransfield", 
        "Victor W. Marek", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310064v1", 
    "title": "Satisfiability and computing van der Waerden numbers", 
    "publish": "2003-10-31T17:05:58Z", 
    "summary": "In this paper we bring together the areas of combinatorics and propositional\nsatisfiability. Many combinatorial theorems establish, often constructively,\nthe existence of positive integer functions, without actually providing their\nclosed algebraic form or tight lower and upper bounds. The area of Ramsey\ntheory is especially rich in such results. Using the problem of computing van\nder Waerden numbers as an example, we show that these problems can be\nrepresented by parameterized propositional theories in such a way that\ndecisions concerning their satisfiability determine the numbers (function) in\nquestion. We show that by using general-purpose complete and local-search\ntechniques for testing propositional satisfiability, this approach becomes\neffective -- competitive with specialized approaches. By following it, we were\nable to obtain several new results pertaining to the problem of computing van\nder Waerden numbers. We also note that due to their properties, especially\ntheir structural simplicity and computational hardness, propositional theories\nthat arise in this research can be of use in development, testing and\nbenchmarking of SAT solvers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310064v1", 
    "other_authors": [
        "Michael R. Dransfield", 
        "Victor W. Marek", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310064v1", 
    "title": "Satisfiability and computing van der Waerden numbers", 
    "publish": "2003-10-31T17:05:58Z", 
    "summary": "In this paper we bring together the areas of combinatorics and propositional\nsatisfiability. Many combinatorial theorems establish, often constructively,\nthe existence of positive integer functions, without actually providing their\nclosed algebraic form or tight lower and upper bounds. The area of Ramsey\ntheory is especially rich in such results. Using the problem of computing van\nder Waerden numbers as an example, we show that these problems can be\nrepresented by parameterized propositional theories in such a way that\ndecisions concerning their satisfiability determine the numbers (function) in\nquestion. We show that by using general-purpose complete and local-search\ntechniques for testing propositional satisfiability, this approach becomes\neffective -- competitive with specialized approaches. By following it, we were\nable to obtain several new results pertaining to the problem of computing van\nder Waerden numbers. We also note that due to their properties, especially\ntheir structural simplicity and computational hardness, propositional theories\nthat arise in this research can be of use in development, testing and\nbenchmarking of SAT solvers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310064v1", 
    "other_authors": [
        "Michael R. Dransfield", 
        "Victor W. Marek", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310064v1", 
    "title": "Satisfiability and computing van der Waerden numbers", 
    "publish": "2003-10-31T17:05:58Z", 
    "summary": "In this paper we bring together the areas of combinatorics and propositional\nsatisfiability. Many combinatorial theorems establish, often constructively,\nthe existence of positive integer functions, without actually providing their\nclosed algebraic form or tight lower and upper bounds. The area of Ramsey\ntheory is especially rich in such results. Using the problem of computing van\nder Waerden numbers as an example, we show that these problems can be\nrepresented by parameterized propositional theories in such a way that\ndecisions concerning their satisfiability determine the numbers (function) in\nquestion. We show that by using general-purpose complete and local-search\ntechniques for testing propositional satisfiability, this approach becomes\neffective -- competitive with specialized approaches. By following it, we were\nable to obtain several new results pertaining to the problem of computing van\nder Waerden numbers. We also note that due to their properties, especially\ntheir structural simplicity and computational hardness, propositional theories\nthat arise in this research can be of use in development, testing and\nbenchmarking of SAT solvers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310064v1", 
    "other_authors": [
        "Michael R. Dransfield", 
        "Victor W. Marek", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310064v1", 
    "title": "Satisfiability and computing van der Waerden numbers", 
    "publish": "2003-10-31T17:05:58Z", 
    "summary": "In this paper we bring together the areas of combinatorics and propositional\nsatisfiability. Many combinatorial theorems establish, often constructively,\nthe existence of positive integer functions, without actually providing their\nclosed algebraic form or tight lower and upper bounds. The area of Ramsey\ntheory is especially rich in such results. Using the problem of computing van\nder Waerden numbers as an example, we show that these problems can be\nrepresented by parameterized propositional theories in such a way that\ndecisions concerning their satisfiability determine the numbers (function) in\nquestion. We show that by using general-purpose complete and local-search\ntechniques for testing propositional satisfiability, this approach becomes\neffective -- competitive with specialized approaches. By following it, we were\nable to obtain several new results pertaining to the problem of computing van\nder Waerden numbers. We also note that due to their properties, especially\ntheir structural simplicity and computational hardness, propositional theories\nthat arise in this research can be of use in development, testing and\nbenchmarking of SAT solvers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310064v1", 
    "other_authors": [
        "Michael R. Dransfield", 
        "Victor W. Marek", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310064v1", 
    "title": "Satisfiability and computing van der Waerden numbers", 
    "publish": "2003-10-31T17:05:58Z", 
    "summary": "In this paper we bring together the areas of combinatorics and propositional\nsatisfiability. Many combinatorial theorems establish, often constructively,\nthe existence of positive integer functions, without actually providing their\nclosed algebraic form or tight lower and upper bounds. The area of Ramsey\ntheory is especially rich in such results. Using the problem of computing van\nder Waerden numbers as an example, we show that these problems can be\nrepresented by parameterized propositional theories in such a way that\ndecisions concerning their satisfiability determine the numbers (function) in\nquestion. We show that by using general-purpose complete and local-search\ntechniques for testing propositional satisfiability, this approach becomes\neffective -- competitive with specialized approaches. By following it, we were\nable to obtain several new results pertaining to the problem of computing van\nder Waerden numbers. We also note that due to their properties, especially\ntheir structural simplicity and computational hardness, propositional theories\nthat arise in this research can be of use in development, testing and\nbenchmarking of SAT solvers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310064v1", 
    "other_authors": [
        "Michael R. Dransfield", 
        "Victor W. Marek", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310064v1", 
    "title": "Satisfiability and computing van der Waerden numbers", 
    "publish": "2003-10-31T17:05:58Z", 
    "summary": "In this paper we bring together the areas of combinatorics and propositional\nsatisfiability. Many combinatorial theorems establish, often constructively,\nthe existence of positive integer functions, without actually providing their\nclosed algebraic form or tight lower and upper bounds. The area of Ramsey\ntheory is especially rich in such results. Using the problem of computing van\nder Waerden numbers as an example, we show that these problems can be\nrepresented by parameterized propositional theories in such a way that\ndecisions concerning their satisfiability determine the numbers (function) in\nquestion. We show that by using general-purpose complete and local-search\ntechniques for testing propositional satisfiability, this approach becomes\neffective -- competitive with specialized approaches. By following it, we were\nable to obtain several new results pertaining to the problem of computing van\nder Waerden numbers. We also note that due to their properties, especially\ntheir structural simplicity and computational hardness, propositional theories\nthat arise in this research can be of use in development, testing and\nbenchmarking of SAT solvers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310064v1", 
    "other_authors": [
        "Michael R. Dransfield", 
        "Victor W. Marek", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310064v1", 
    "title": "Satisfiability and computing van der Waerden numbers", 
    "publish": "2003-10-31T17:05:58Z", 
    "summary": "In this paper we bring together the areas of combinatorics and propositional\nsatisfiability. Many combinatorial theorems establish, often constructively,\nthe existence of positive integer functions, without actually providing their\nclosed algebraic form or tight lower and upper bounds. The area of Ramsey\ntheory is especially rich in such results. Using the problem of computing van\nder Waerden numbers as an example, we show that these problems can be\nrepresented by parameterized propositional theories in such a way that\ndecisions concerning their satisfiability determine the numbers (function) in\nquestion. We show that by using general-purpose complete and local-search\ntechniques for testing propositional satisfiability, this approach becomes\neffective -- competitive with specialized approaches. By following it, we were\nable to obtain several new results pertaining to the problem of computing van\nder Waerden numbers. We also note that due to their properties, especially\ntheir structural simplicity and computational hardness, propositional theories\nthat arise in this research can be of use in development, testing and\nbenchmarking of SAT solvers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310064v1", 
    "other_authors": [
        "Michael R. Dransfield", 
        "Victor W. Marek", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310064v1", 
    "title": "Satisfiability and computing van der Waerden numbers", 
    "publish": "2003-10-31T17:05:58Z", 
    "summary": "In this paper we bring together the areas of combinatorics and propositional\nsatisfiability. Many combinatorial theorems establish, often constructively,\nthe existence of positive integer functions, without actually providing their\nclosed algebraic form or tight lower and upper bounds. The area of Ramsey\ntheory is especially rich in such results. Using the problem of computing van\nder Waerden numbers as an example, we show that these problems can be\nrepresented by parameterized propositional theories in such a way that\ndecisions concerning their satisfiability determine the numbers (function) in\nquestion. We show that by using general-purpose complete and local-search\ntechniques for testing propositional satisfiability, this approach becomes\neffective -- competitive with specialized approaches. By following it, we were\nable to obtain several new results pertaining to the problem of computing van\nder Waerden numbers. We also note that due to their properties, especially\ntheir structural simplicity and computational hardness, propositional theories\nthat arise in this research can be of use in development, testing and\nbenchmarking of SAT solvers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310064v1", 
    "other_authors": [
        "Michael R. Dransfield", 
        "Victor W. Marek", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310064v1", 
    "title": "Satisfiability and computing van der Waerden numbers", 
    "publish": "2003-10-31T17:05:58Z", 
    "summary": "In this paper we bring together the areas of combinatorics and propositional\nsatisfiability. Many combinatorial theorems establish, often constructively,\nthe existence of positive integer functions, without actually providing their\nclosed algebraic form or tight lower and upper bounds. The area of Ramsey\ntheory is especially rich in such results. Using the problem of computing van\nder Waerden numbers as an example, we show that these problems can be\nrepresented by parameterized propositional theories in such a way that\ndecisions concerning their satisfiability determine the numbers (function) in\nquestion. We show that by using general-purpose complete and local-search\ntechniques for testing propositional satisfiability, this approach becomes\neffective -- competitive with specialized approaches. By following it, we were\nable to obtain several new results pertaining to the problem of computing van\nder Waerden numbers. We also note that due to their properties, especially\ntheir structural simplicity and computational hardness, propositional theories\nthat arise in this research can be of use in development, testing and\nbenchmarking of SAT solvers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310064v1", 
    "other_authors": [
        "Michael R. Dransfield", 
        "Victor W. Marek", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310064v1", 
    "title": "Satisfiability and computing van der Waerden numbers", 
    "publish": "2003-10-31T17:05:58Z", 
    "summary": "In this paper we bring together the areas of combinatorics and propositional\nsatisfiability. Many combinatorial theorems establish, often constructively,\nthe existence of positive integer functions, without actually providing their\nclosed algebraic form or tight lower and upper bounds. The area of Ramsey\ntheory is especially rich in such results. Using the problem of computing van\nder Waerden numbers as an example, we show that these problems can be\nrepresented by parameterized propositional theories in such a way that\ndecisions concerning their satisfiability determine the numbers (function) in\nquestion. We show that by using general-purpose complete and local-search\ntechniques for testing propositional satisfiability, this approach becomes\neffective -- competitive with specialized approaches. By following it, we were\nable to obtain several new results pertaining to the problem of computing van\nder Waerden numbers. We also note that due to their properties, especially\ntheir structural simplicity and computational hardness, propositional theories\nthat arise in this research can be of use in development, testing and\nbenchmarking of SAT solvers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310064v1", 
    "other_authors": [
        "Michael R. Dransfield", 
        "Victor W. Marek", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310064v1", 
    "title": "Satisfiability and computing van der Waerden numbers", 
    "publish": "2003-10-31T17:05:58Z", 
    "summary": "In this paper we bring together the areas of combinatorics and propositional\nsatisfiability. Many combinatorial theorems establish, often constructively,\nthe existence of positive integer functions, without actually providing their\nclosed algebraic form or tight lower and upper bounds. The area of Ramsey\ntheory is especially rich in such results. Using the problem of computing van\nder Waerden numbers as an example, we show that these problems can be\nrepresented by parameterized propositional theories in such a way that\ndecisions concerning their satisfiability determine the numbers (function) in\nquestion. We show that by using general-purpose complete and local-search\ntechniques for testing propositional satisfiability, this approach becomes\neffective -- competitive with specialized approaches. By following it, we were\nable to obtain several new results pertaining to the problem of computing van\nder Waerden numbers. We also note that due to their properties, especially\ntheir structural simplicity and computational hardness, propositional theories\nthat arise in this research can be of use in development, testing and\nbenchmarking of SAT solvers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310064v1", 
    "other_authors": [
        "Michael R. Dransfield", 
        "Victor W. Marek", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310064v1", 
    "title": "Satisfiability and computing van der Waerden numbers", 
    "publish": "2003-10-31T17:05:58Z", 
    "summary": "In this paper we bring together the areas of combinatorics and propositional\nsatisfiability. Many combinatorial theorems establish, often constructively,\nthe existence of positive integer functions, without actually providing their\nclosed algebraic form or tight lower and upper bounds. The area of Ramsey\ntheory is especially rich in such results. Using the problem of computing van\nder Waerden numbers as an example, we show that these problems can be\nrepresented by parameterized propositional theories in such a way that\ndecisions concerning their satisfiability determine the numbers (function) in\nquestion. We show that by using general-purpose complete and local-search\ntechniques for testing propositional satisfiability, this approach becomes\neffective -- competitive with specialized approaches. By following it, we were\nable to obtain several new results pertaining to the problem of computing van\nder Waerden numbers. We also note that due to their properties, especially\ntheir structural simplicity and computational hardness, propositional theories\nthat arise in this research can be of use in development, testing and\nbenchmarking of SAT solvers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310064v1", 
    "other_authors": [
        "Michael R. Dransfield", 
        "Victor W. Marek", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310064v1", 
    "title": "Satisfiability and computing van der Waerden numbers", 
    "publish": "2003-10-31T17:05:58Z", 
    "summary": "In this paper we bring together the areas of combinatorics and propositional\nsatisfiability. Many combinatorial theorems establish, often constructively,\nthe existence of positive integer functions, without actually providing their\nclosed algebraic form or tight lower and upper bounds. The area of Ramsey\ntheory is especially rich in such results. Using the problem of computing van\nder Waerden numbers as an example, we show that these problems can be\nrepresented by parameterized propositional theories in such a way that\ndecisions concerning their satisfiability determine the numbers (function) in\nquestion. We show that by using general-purpose complete and local-search\ntechniques for testing propositional satisfiability, this approach becomes\neffective -- competitive with specialized approaches. By following it, we were\nable to obtain several new results pertaining to the problem of computing van\nder Waerden numbers. We also note that due to their properties, especially\ntheir structural simplicity and computational hardness, propositional theories\nthat arise in this research can be of use in development, testing and\nbenchmarking of SAT solvers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310064v1", 
    "other_authors": [
        "Michael R. Dransfield", 
        "Victor W. Marek", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310064v1", 
    "title": "Satisfiability and computing van der Waerden numbers", 
    "publish": "2003-10-31T17:05:58Z", 
    "summary": "In this paper we bring together the areas of combinatorics and propositional\nsatisfiability. Many combinatorial theorems establish, often constructively,\nthe existence of positive integer functions, without actually providing their\nclosed algebraic form or tight lower and upper bounds. The area of Ramsey\ntheory is especially rich in such results. Using the problem of computing van\nder Waerden numbers as an example, we show that these problems can be\nrepresented by parameterized propositional theories in such a way that\ndecisions concerning their satisfiability determine the numbers (function) in\nquestion. We show that by using general-purpose complete and local-search\ntechniques for testing propositional satisfiability, this approach becomes\neffective -- competitive with specialized approaches. By following it, we were\nable to obtain several new results pertaining to the problem of computing van\nder Waerden numbers. We also note that due to their properties, especially\ntheir structural simplicity and computational hardness, propositional theories\nthat arise in this research can be of use in development, testing and\nbenchmarking of SAT solvers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310064v1", 
    "other_authors": [
        "Michael R. Dransfield", 
        "Victor W. Marek", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310064v1", 
    "title": "Satisfiability and computing van der Waerden numbers", 
    "publish": "2003-10-31T17:05:58Z", 
    "summary": "In this paper we bring together the areas of combinatorics and propositional\nsatisfiability. Many combinatorial theorems establish, often constructively,\nthe existence of positive integer functions, without actually providing their\nclosed algebraic form or tight lower and upper bounds. The area of Ramsey\ntheory is especially rich in such results. Using the problem of computing van\nder Waerden numbers as an example, we show that these problems can be\nrepresented by parameterized propositional theories in such a way that\ndecisions concerning their satisfiability determine the numbers (function) in\nquestion. We show that by using general-purpose complete and local-search\ntechniques for testing propositional satisfiability, this approach becomes\neffective -- competitive with specialized approaches. By following it, we were\nable to obtain several new results pertaining to the problem of computing van\nder Waerden numbers. We also note that due to their properties, especially\ntheir structural simplicity and computational hardness, propositional theories\nthat arise in this research can be of use in development, testing and\nbenchmarking of SAT solvers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310064v1", 
    "other_authors": [
        "Michael R. Dransfield", 
        "Victor W. Marek", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310064v1", 
    "title": "Satisfiability and computing van der Waerden numbers", 
    "publish": "2003-10-31T17:05:58Z", 
    "summary": "In this paper we bring together the areas of combinatorics and propositional\nsatisfiability. Many combinatorial theorems establish, often constructively,\nthe existence of positive integer functions, without actually providing their\nclosed algebraic form or tight lower and upper bounds. The area of Ramsey\ntheory is especially rich in such results. Using the problem of computing van\nder Waerden numbers as an example, we show that these problems can be\nrepresented by parameterized propositional theories in such a way that\ndecisions concerning their satisfiability determine the numbers (function) in\nquestion. We show that by using general-purpose complete and local-search\ntechniques for testing propositional satisfiability, this approach becomes\neffective -- competitive with specialized approaches. By following it, we were\nable to obtain several new results pertaining to the problem of computing van\nder Waerden numbers. We also note that due to their properties, especially\ntheir structural simplicity and computational hardness, propositional theories\nthat arise in this research can be of use in development, testing and\nbenchmarking of SAT solvers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310064v1", 
    "other_authors": [
        "Michael R. Dransfield", 
        "Victor W. Marek", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310064v1", 
    "title": "Satisfiability and computing van der Waerden numbers", 
    "publish": "2003-10-31T17:05:58Z", 
    "summary": "In this paper we bring together the areas of combinatorics and propositional\nsatisfiability. Many combinatorial theorems establish, often constructively,\nthe existence of positive integer functions, without actually providing their\nclosed algebraic form or tight lower and upper bounds. The area of Ramsey\ntheory is especially rich in such results. Using the problem of computing van\nder Waerden numbers as an example, we show that these problems can be\nrepresented by parameterized propositional theories in such a way that\ndecisions concerning their satisfiability determine the numbers (function) in\nquestion. We show that by using general-purpose complete and local-search\ntechniques for testing propositional satisfiability, this approach becomes\neffective -- competitive with specialized approaches. By following it, we were\nable to obtain several new results pertaining to the problem of computing van\nder Waerden numbers. We also note that due to their properties, especially\ntheir structural simplicity and computational hardness, propositional theories\nthat arise in this research can be of use in development, testing and\nbenchmarking of SAT solvers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310064v1", 
    "other_authors": [
        "Michael R. Dransfield", 
        "Victor W. Marek", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310064v1", 
    "title": "Satisfiability and computing van der Waerden numbers", 
    "publish": "2003-10-31T17:05:58Z", 
    "summary": "In this paper we bring together the areas of combinatorics and propositional\nsatisfiability. Many combinatorial theorems establish, often constructively,\nthe existence of positive integer functions, without actually providing their\nclosed algebraic form or tight lower and upper bounds. The area of Ramsey\ntheory is especially rich in such results. Using the problem of computing van\nder Waerden numbers as an example, we show that these problems can be\nrepresented by parameterized propositional theories in such a way that\ndecisions concerning their satisfiability determine the numbers (function) in\nquestion. We show that by using general-purpose complete and local-search\ntechniques for testing propositional satisfiability, this approach becomes\neffective -- competitive with specialized approaches. By following it, we were\nable to obtain several new results pertaining to the problem of computing van\nder Waerden numbers. We also note that due to their properties, especially\ntheir structural simplicity and computational hardness, propositional theories\nthat arise in this research can be of use in development, testing and\nbenchmarking of SAT solvers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310064v1", 
    "other_authors": [
        "Michael R. Dransfield", 
        "Victor W. Marek", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310064v1", 
    "title": "Satisfiability and computing van der Waerden numbers", 
    "publish": "2003-10-31T17:05:58Z", 
    "summary": "In this paper we bring together the areas of combinatorics and propositional\nsatisfiability. Many combinatorial theorems establish, often constructively,\nthe existence of positive integer functions, without actually providing their\nclosed algebraic form or tight lower and upper bounds. The area of Ramsey\ntheory is especially rich in such results. Using the problem of computing van\nder Waerden numbers as an example, we show that these problems can be\nrepresented by parameterized propositional theories in such a way that\ndecisions concerning their satisfiability determine the numbers (function) in\nquestion. We show that by using general-purpose complete and local-search\ntechniques for testing propositional satisfiability, this approach becomes\neffective -- competitive with specialized approaches. By following it, we were\nable to obtain several new results pertaining to the problem of computing van\nder Waerden numbers. We also note that due to their properties, especially\ntheir structural simplicity and computational hardness, propositional theories\nthat arise in this research can be of use in development, testing and\nbenchmarking of SAT solvers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310064v1", 
    "other_authors": [
        "Michael R. Dransfield", 
        "Victor W. Marek", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310064v1", 
    "title": "Satisfiability and computing van der Waerden numbers", 
    "publish": "2003-10-31T17:05:58Z", 
    "summary": "In this paper we bring together the areas of combinatorics and propositional\nsatisfiability. Many combinatorial theorems establish, often constructively,\nthe existence of positive integer functions, without actually providing their\nclosed algebraic form or tight lower and upper bounds. The area of Ramsey\ntheory is especially rich in such results. Using the problem of computing van\nder Waerden numbers as an example, we show that these problems can be\nrepresented by parameterized propositional theories in such a way that\ndecisions concerning their satisfiability determine the numbers (function) in\nquestion. We show that by using general-purpose complete and local-search\ntechniques for testing propositional satisfiability, this approach becomes\neffective -- competitive with specialized approaches. By following it, we were\nable to obtain several new results pertaining to the problem of computing van\nder Waerden numbers. We also note that due to their properties, especially\ntheir structural simplicity and computational hardness, propositional theories\nthat arise in this research can be of use in development, testing and\nbenchmarking of SAT solvers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310064v1", 
    "other_authors": [
        "Michael R. Dransfield", 
        "Victor W. Marek", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310064v1", 
    "title": "Satisfiability and computing van der Waerden numbers", 
    "publish": "2003-10-31T17:05:58Z", 
    "summary": "In this paper we bring together the areas of combinatorics and propositional\nsatisfiability. Many combinatorial theorems establish, often constructively,\nthe existence of positive integer functions, without actually providing their\nclosed algebraic form or tight lower and upper bounds. The area of Ramsey\ntheory is especially rich in such results. Using the problem of computing van\nder Waerden numbers as an example, we show that these problems can be\nrepresented by parameterized propositional theories in such a way that\ndecisions concerning their satisfiability determine the numbers (function) in\nquestion. We show that by using general-purpose complete and local-search\ntechniques for testing propositional satisfiability, this approach becomes\neffective -- competitive with specialized approaches. By following it, we were\nable to obtain several new results pertaining to the problem of computing van\nder Waerden numbers. We also note that due to their properties, especially\ntheir structural simplicity and computational hardness, propositional theories\nthat arise in this research can be of use in development, testing and\nbenchmarking of SAT solvers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310064v1", 
    "other_authors": [
        "Michael R. Dransfield", 
        "Victor W. Marek", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310064v1", 
    "title": "Satisfiability and computing van der Waerden numbers", 
    "publish": "2003-10-31T17:05:58Z", 
    "summary": "In this paper we bring together the areas of combinatorics and propositional\nsatisfiability. Many combinatorial theorems establish, often constructively,\nthe existence of positive integer functions, without actually providing their\nclosed algebraic form or tight lower and upper bounds. The area of Ramsey\ntheory is especially rich in such results. Using the problem of computing van\nder Waerden numbers as an example, we show that these problems can be\nrepresented by parameterized propositional theories in such a way that\ndecisions concerning their satisfiability determine the numbers (function) in\nquestion. We show that by using general-purpose complete and local-search\ntechniques for testing propositional satisfiability, this approach becomes\neffective -- competitive with specialized approaches. By following it, we were\nable to obtain several new results pertaining to the problem of computing van\nder Waerden numbers. We also note that due to their properties, especially\ntheir structural simplicity and computational hardness, propositional theories\nthat arise in this research can be of use in development, testing and\nbenchmarking of SAT solvers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310064v1", 
    "other_authors": [
        "Michael R. Dransfield", 
        "Victor W. Marek", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310064v1", 
    "title": "Satisfiability and computing van der Waerden numbers", 
    "publish": "2003-10-31T17:05:58Z", 
    "summary": "In this paper we bring together the areas of combinatorics and propositional\nsatisfiability. Many combinatorial theorems establish, often constructively,\nthe existence of positive integer functions, without actually providing their\nclosed algebraic form or tight lower and upper bounds. The area of Ramsey\ntheory is especially rich in such results. Using the problem of computing van\nder Waerden numbers as an example, we show that these problems can be\nrepresented by parameterized propositional theories in such a way that\ndecisions concerning their satisfiability determine the numbers (function) in\nquestion. We show that by using general-purpose complete and local-search\ntechniques for testing propositional satisfiability, this approach becomes\neffective -- competitive with specialized approaches. By following it, we were\nable to obtain several new results pertaining to the problem of computing van\nder Waerden numbers. We also note that due to their properties, especially\ntheir structural simplicity and computational hardness, propositional theories\nthat arise in this research can be of use in development, testing and\nbenchmarking of SAT solvers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310064v1", 
    "other_authors": [
        "Michael R. Dransfield", 
        "Victor W. Marek", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310064v1", 
    "title": "Satisfiability and computing van der Waerden numbers", 
    "publish": "2003-10-31T17:05:58Z", 
    "summary": "In this paper we bring together the areas of combinatorics and propositional\nsatisfiability. Many combinatorial theorems establish, often constructively,\nthe existence of positive integer functions, without actually providing their\nclosed algebraic form or tight lower and upper bounds. The area of Ramsey\ntheory is especially rich in such results. Using the problem of computing van\nder Waerden numbers as an example, we show that these problems can be\nrepresented by parameterized propositional theories in such a way that\ndecisions concerning their satisfiability determine the numbers (function) in\nquestion. We show that by using general-purpose complete and local-search\ntechniques for testing propositional satisfiability, this approach becomes\neffective -- competitive with specialized approaches. By following it, we were\nable to obtain several new results pertaining to the problem of computing van\nder Waerden numbers. We also note that due to their properties, especially\ntheir structural simplicity and computational hardness, propositional theories\nthat arise in this research can be of use in development, testing and\nbenchmarking of SAT solvers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310064v1", 
    "other_authors": [
        "Michael R. Dransfield", 
        "Victor W. Marek", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310064v1", 
    "title": "Satisfiability and computing van der Waerden numbers", 
    "publish": "2003-10-31T17:05:58Z", 
    "summary": "In this paper we bring together the areas of combinatorics and propositional\nsatisfiability. Many combinatorial theorems establish, often constructively,\nthe existence of positive integer functions, without actually providing their\nclosed algebraic form or tight lower and upper bounds. The area of Ramsey\ntheory is especially rich in such results. Using the problem of computing van\nder Waerden numbers as an example, we show that these problems can be\nrepresented by parameterized propositional theories in such a way that\ndecisions concerning their satisfiability determine the numbers (function) in\nquestion. We show that by using general-purpose complete and local-search\ntechniques for testing propositional satisfiability, this approach becomes\neffective -- competitive with specialized approaches. By following it, we were\nable to obtain several new results pertaining to the problem of computing van\nder Waerden numbers. We also note that due to their properties, especially\ntheir structural simplicity and computational hardness, propositional theories\nthat arise in this research can be of use in development, testing and\nbenchmarking of SAT solvers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310064v1", 
    "other_authors": [
        "Michael R. Dransfield", 
        "Victor W. Marek", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310064v1", 
    "title": "Satisfiability and computing van der Waerden numbers", 
    "publish": "2003-10-31T17:05:58Z", 
    "summary": "In this paper we bring together the areas of combinatorics and propositional\nsatisfiability. Many combinatorial theorems establish, often constructively,\nthe existence of positive integer functions, without actually providing their\nclosed algebraic form or tight lower and upper bounds. The area of Ramsey\ntheory is especially rich in such results. Using the problem of computing van\nder Waerden numbers as an example, we show that these problems can be\nrepresented by parameterized propositional theories in such a way that\ndecisions concerning their satisfiability determine the numbers (function) in\nquestion. We show that by using general-purpose complete and local-search\ntechniques for testing propositional satisfiability, this approach becomes\neffective -- competitive with specialized approaches. By following it, we were\nable to obtain several new results pertaining to the problem of computing van\nder Waerden numbers. We also note that due to their properties, especially\ntheir structural simplicity and computational hardness, propositional theories\nthat arise in this research can be of use in development, testing and\nbenchmarking of SAT solvers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310064v1", 
    "other_authors": [
        "Michael R. Dransfield", 
        "Victor W. Marek", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310064v1", 
    "title": "Satisfiability and computing van der Waerden numbers", 
    "publish": "2003-10-31T17:05:58Z", 
    "summary": "In this paper we bring together the areas of combinatorics and propositional\nsatisfiability. Many combinatorial theorems establish, often constructively,\nthe existence of positive integer functions, without actually providing their\nclosed algebraic form or tight lower and upper bounds. The area of Ramsey\ntheory is especially rich in such results. Using the problem of computing van\nder Waerden numbers as an example, we show that these problems can be\nrepresented by parameterized propositional theories in such a way that\ndecisions concerning their satisfiability determine the numbers (function) in\nquestion. We show that by using general-purpose complete and local-search\ntechniques for testing propositional satisfiability, this approach becomes\neffective -- competitive with specialized approaches. By following it, we were\nable to obtain several new results pertaining to the problem of computing van\nder Waerden numbers. We also note that due to their properties, especially\ntheir structural simplicity and computational hardness, propositional theories\nthat arise in this research can be of use in development, testing and\nbenchmarking of SAT solvers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0310064v1", 
    "other_authors": [
        "Michael R. Dransfield", 
        "Victor W. Marek", 
        "Miroslaw Truszczynski"
    ], 
    "lead_author": "Miroslaw Truszczynski", 
    "arxiv-id": "cs/0310064v1", 
    "title": "Satisfiability and computing van der Waerden numbers", 
    "publish": "2003-10-31T17:05:58Z", 
    "summary": "In this paper we bring together the areas of combinatorics and propositional\nsatisfiability. Many combinatorial theorems establish, often constructively,\nthe existence of positive integer functions, without actually providing their\nclosed algebraic form or tight lower and upper bounds. The area of Ramsey\ntheory is especially rich in such results. Using the problem of computing van\nder Waerden numbers as an example, we show that these problems can be\nrepresented by parameterized propositional theories in such a way that\ndecisions concerning their satisfiability determine the numbers (function) in\nquestion. We show that by using general-purpose complete and local-search\ntechniques for testing propositional satisfiability, this approach becomes\neffective -- competitive with specialized approaches. By following it, we were\nable to obtain several new results pertaining to the problem of computing van\nder Waerden numbers. We also note that due to their properties, especially\ntheir structural simplicity and computational hardness, propositional theories\nthat arise in this research can be of use in development, testing and\nbenchmarking of SAT solvers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "M. Franceschet", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "M. Franceschet", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "M. Franceschet", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "M. Franceschet", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "M. Franceschet", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "M. Franceschet", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "M. Franceschet", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "M. Franceschet", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "M. Franceschet", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "M. Franceschet", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "M. Franceschet", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "M. Franceschet", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "M. Franceschet", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "M. Franceschet", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "M. Franceschet", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "M. Franceschet", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "M. Franceschet", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311022v1", 
    "other_authors": [
        "M. Franceschet", 
        "A. Montanari"
    ], 
    "lead_author": "A. Montanari", 
    "arxiv-id": "cs/0311022v1", 
    "title": "Temporalized logics and automata for time granularity", 
    "publish": "2003-11-17T14:11:20Z", 
    "summary": "Suitable extensions of the monadic second-order theory of k successors have\nbeen proposed in the literature to capture the notion of time granularity. In\nthis paper, we provide the monadic second-order theories of downward unbounded\nlayered structures, which are infinitely refinable structures consisting of a\ncoarsest domain and an infinite number of finer and finer domains, and of\nupward unbounded layered structures, which consist of a finest domain and an\ninfinite number of coarser and coarser domains, with expressively complete and\nelementarily decidable temporal logic counterparts.\n  We obtain such a result in two steps. First, we define a new class of\ncombined automata, called temporalized automata, which can be proved to be the\nautomata-theoretic counterpart of temporalized logics, and show that relevant\nproperties, such as closure under Boolean operations, decidability, and\nexpressive equivalence with respect to temporal logics, transfer from component\nautomata to temporalized ones. Then, we exploit the correspondence between\ntemporalized logics and automata to reduce the task of finding the temporal\nlogic counterparts of the given theories of time granularity to the easier one\nof finding temporalized automata counterparts of them."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311046v1", 
    "other_authors": [
        "Jan Odelstad", 
        "Magnus Boman"
    ], 
    "lead_author": "Jan Odelstad", 
    "arxiv-id": "cs/0311046v1", 
    "title": "Algebras for Agent Norm-Regulation", 
    "publish": "2003-11-27T13:03:55Z", 
    "summary": "An abstract architecture for idealized multi-agent systems whose behaviour is\nregulated by normative systems is developed and discussed. Agent choices are\ndetermined partially by the preference ordering of possible states and\npartially by normative considerations: The agent chooses that act which leads\nto the best outcome of all permissible actions. If an action is non-permissible\ndepends on if the result of performing that action leads to a state satisfying\na condition which is forbidden, according to the norms regulating the\nmulti-agent system. This idea is formalized by defining set-theoretic\npredicates characterizing multi-agent systems. The definition of the predicate\nuses decision theory, the Kanger-Lindahl theory of normative positions, and an\nalgebraic representation of normative systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311046v1", 
    "other_authors": [
        "Jan Odelstad", 
        "Magnus Boman"
    ], 
    "lead_author": "Magnus Boman", 
    "arxiv-id": "cs/0311046v1", 
    "title": "Algebras for Agent Norm-Regulation", 
    "publish": "2003-11-27T13:03:55Z", 
    "summary": "An abstract architecture for idealized multi-agent systems whose behaviour is\nregulated by normative systems is developed and discussed. Agent choices are\ndetermined partially by the preference ordering of possible states and\npartially by normative considerations: The agent chooses that act which leads\nto the best outcome of all permissible actions. If an action is non-permissible\ndepends on if the result of performing that action leads to a state satisfying\na condition which is forbidden, according to the norms regulating the\nmulti-agent system. This idea is formalized by defining set-theoretic\npredicates characterizing multi-agent systems. The definition of the predicate\nuses decision theory, the Kanger-Lindahl theory of normative positions, and an\nalgebraic representation of normative systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311046v1", 
    "other_authors": [
        "Jan Odelstad", 
        "Magnus Boman"
    ], 
    "lead_author": "Magnus Boman", 
    "arxiv-id": "cs/0311046v1", 
    "title": "Algebras for Agent Norm-Regulation", 
    "publish": "2003-11-27T13:03:55Z", 
    "summary": "An abstract architecture for idealized multi-agent systems whose behaviour is\nregulated by normative systems is developed and discussed. Agent choices are\ndetermined partially by the preference ordering of possible states and\npartially by normative considerations: The agent chooses that act which leads\nto the best outcome of all permissible actions. If an action is non-permissible\ndepends on if the result of performing that action leads to a state satisfying\na condition which is forbidden, according to the norms regulating the\nmulti-agent system. This idea is formalized by defining set-theoretic\npredicates characterizing multi-agent systems. The definition of the predicate\nuses decision theory, the Kanger-Lindahl theory of normative positions, and an\nalgebraic representation of normative systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311046v1", 
    "other_authors": [
        "Jan Odelstad", 
        "Magnus Boman"
    ], 
    "lead_author": "Magnus Boman", 
    "arxiv-id": "cs/0311046v1", 
    "title": "Algebras for Agent Norm-Regulation", 
    "publish": "2003-11-27T13:03:55Z", 
    "summary": "An abstract architecture for idealized multi-agent systems whose behaviour is\nregulated by normative systems is developed and discussed. Agent choices are\ndetermined partially by the preference ordering of possible states and\npartially by normative considerations: The agent chooses that act which leads\nto the best outcome of all permissible actions. If an action is non-permissible\ndepends on if the result of performing that action leads to a state satisfying\na condition which is forbidden, according to the norms regulating the\nmulti-agent system. This idea is formalized by defining set-theoretic\npredicates characterizing multi-agent systems. The definition of the predicate\nuses decision theory, the Kanger-Lindahl theory of normative positions, and an\nalgebraic representation of normative systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311046v1", 
    "other_authors": [
        "Jan Odelstad", 
        "Magnus Boman"
    ], 
    "lead_author": "Magnus Boman", 
    "arxiv-id": "cs/0311046v1", 
    "title": "Algebras for Agent Norm-Regulation", 
    "publish": "2003-11-27T13:03:55Z", 
    "summary": "An abstract architecture for idealized multi-agent systems whose behaviour is\nregulated by normative systems is developed and discussed. Agent choices are\ndetermined partially by the preference ordering of possible states and\npartially by normative considerations: The agent chooses that act which leads\nto the best outcome of all permissible actions. If an action is non-permissible\ndepends on if the result of performing that action leads to a state satisfying\na condition which is forbidden, according to the norms regulating the\nmulti-agent system. This idea is formalized by defining set-theoretic\npredicates characterizing multi-agent systems. The definition of the predicate\nuses decision theory, the Kanger-Lindahl theory of normative positions, and an\nalgebraic representation of normative systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311046v1", 
    "other_authors": [
        "Jan Odelstad", 
        "Magnus Boman"
    ], 
    "lead_author": "Magnus Boman", 
    "arxiv-id": "cs/0311046v1", 
    "title": "Algebras for Agent Norm-Regulation", 
    "publish": "2003-11-27T13:03:55Z", 
    "summary": "An abstract architecture for idealized multi-agent systems whose behaviour is\nregulated by normative systems is developed and discussed. Agent choices are\ndetermined partially by the preference ordering of possible states and\npartially by normative considerations: The agent chooses that act which leads\nto the best outcome of all permissible actions. If an action is non-permissible\ndepends on if the result of performing that action leads to a state satisfying\na condition which is forbidden, according to the norms regulating the\nmulti-agent system. This idea is formalized by defining set-theoretic\npredicates characterizing multi-agent systems. The definition of the predicate\nuses decision theory, the Kanger-Lindahl theory of normative positions, and an\nalgebraic representation of normative systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311046v1", 
    "other_authors": [
        "Jan Odelstad", 
        "Magnus Boman"
    ], 
    "lead_author": "Magnus Boman", 
    "arxiv-id": "cs/0311046v1", 
    "title": "Algebras for Agent Norm-Regulation", 
    "publish": "2003-11-27T13:03:55Z", 
    "summary": "An abstract architecture for idealized multi-agent systems whose behaviour is\nregulated by normative systems is developed and discussed. Agent choices are\ndetermined partially by the preference ordering of possible states and\npartially by normative considerations: The agent chooses that act which leads\nto the best outcome of all permissible actions. If an action is non-permissible\ndepends on if the result of performing that action leads to a state satisfying\na condition which is forbidden, according to the norms regulating the\nmulti-agent system. This idea is formalized by defining set-theoretic\npredicates characterizing multi-agent systems. The definition of the predicate\nuses decision theory, the Kanger-Lindahl theory of normative positions, and an\nalgebraic representation of normative systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311046v1", 
    "other_authors": [
        "Jan Odelstad", 
        "Magnus Boman"
    ], 
    "lead_author": "Magnus Boman", 
    "arxiv-id": "cs/0311046v1", 
    "title": "Algebras for Agent Norm-Regulation", 
    "publish": "2003-11-27T13:03:55Z", 
    "summary": "An abstract architecture for idealized multi-agent systems whose behaviour is\nregulated by normative systems is developed and discussed. Agent choices are\ndetermined partially by the preference ordering of possible states and\npartially by normative considerations: The agent chooses that act which leads\nto the best outcome of all permissible actions. If an action is non-permissible\ndepends on if the result of performing that action leads to a state satisfying\na condition which is forbidden, according to the norms regulating the\nmulti-agent system. This idea is formalized by defining set-theoretic\npredicates characterizing multi-agent systems. The definition of the predicate\nuses decision theory, the Kanger-Lindahl theory of normative positions, and an\nalgebraic representation of normative systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311046v1", 
    "other_authors": [
        "Jan Odelstad", 
        "Magnus Boman"
    ], 
    "lead_author": "Magnus Boman", 
    "arxiv-id": "cs/0311046v1", 
    "title": "Algebras for Agent Norm-Regulation", 
    "publish": "2003-11-27T13:03:55Z", 
    "summary": "An abstract architecture for idealized multi-agent systems whose behaviour is\nregulated by normative systems is developed and discussed. Agent choices are\ndetermined partially by the preference ordering of possible states and\npartially by normative considerations: The agent chooses that act which leads\nto the best outcome of all permissible actions. If an action is non-permissible\ndepends on if the result of performing that action leads to a state satisfying\na condition which is forbidden, according to the norms regulating the\nmulti-agent system. This idea is formalized by defining set-theoretic\npredicates characterizing multi-agent systems. The definition of the predicate\nuses decision theory, the Kanger-Lindahl theory of normative positions, and an\nalgebraic representation of normative systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311046v1", 
    "other_authors": [
        "Jan Odelstad", 
        "Magnus Boman"
    ], 
    "lead_author": "Magnus Boman", 
    "arxiv-id": "cs/0311046v1", 
    "title": "Algebras for Agent Norm-Regulation", 
    "publish": "2003-11-27T13:03:55Z", 
    "summary": "An abstract architecture for idealized multi-agent systems whose behaviour is\nregulated by normative systems is developed and discussed. Agent choices are\ndetermined partially by the preference ordering of possible states and\npartially by normative considerations: The agent chooses that act which leads\nto the best outcome of all permissible actions. If an action is non-permissible\ndepends on if the result of performing that action leads to a state satisfying\na condition which is forbidden, according to the norms regulating the\nmulti-agent system. This idea is formalized by defining set-theoretic\npredicates characterizing multi-agent systems. The definition of the predicate\nuses decision theory, the Kanger-Lindahl theory of normative positions, and an\nalgebraic representation of normative systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311046v1", 
    "other_authors": [
        "Jan Odelstad", 
        "Magnus Boman"
    ], 
    "lead_author": "Magnus Boman", 
    "arxiv-id": "cs/0311046v1", 
    "title": "Algebras for Agent Norm-Regulation", 
    "publish": "2003-11-27T13:03:55Z", 
    "summary": "An abstract architecture for idealized multi-agent systems whose behaviour is\nregulated by normative systems is developed and discussed. Agent choices are\ndetermined partially by the preference ordering of possible states and\npartially by normative considerations: The agent chooses that act which leads\nto the best outcome of all permissible actions. If an action is non-permissible\ndepends on if the result of performing that action leads to a state satisfying\na condition which is forbidden, according to the norms regulating the\nmulti-agent system. This idea is formalized by defining set-theoretic\npredicates characterizing multi-agent systems. The definition of the predicate\nuses decision theory, the Kanger-Lindahl theory of normative positions, and an\nalgebraic representation of normative systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311046v1", 
    "other_authors": [
        "Jan Odelstad", 
        "Magnus Boman"
    ], 
    "lead_author": "Magnus Boman", 
    "arxiv-id": "cs/0311046v1", 
    "title": "Algebras for Agent Norm-Regulation", 
    "publish": "2003-11-27T13:03:55Z", 
    "summary": "An abstract architecture for idealized multi-agent systems whose behaviour is\nregulated by normative systems is developed and discussed. Agent choices are\ndetermined partially by the preference ordering of possible states and\npartially by normative considerations: The agent chooses that act which leads\nto the best outcome of all permissible actions. If an action is non-permissible\ndepends on if the result of performing that action leads to a state satisfying\na condition which is forbidden, according to the norms regulating the\nmulti-agent system. This idea is formalized by defining set-theoretic\npredicates characterizing multi-agent systems. The definition of the predicate\nuses decision theory, the Kanger-Lindahl theory of normative positions, and an\nalgebraic representation of normative systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311046v1", 
    "other_authors": [
        "Jan Odelstad", 
        "Magnus Boman"
    ], 
    "lead_author": "Magnus Boman", 
    "arxiv-id": "cs/0311046v1", 
    "title": "Algebras for Agent Norm-Regulation", 
    "publish": "2003-11-27T13:03:55Z", 
    "summary": "An abstract architecture for idealized multi-agent systems whose behaviour is\nregulated by normative systems is developed and discussed. Agent choices are\ndetermined partially by the preference ordering of possible states and\npartially by normative considerations: The agent chooses that act which leads\nto the best outcome of all permissible actions. If an action is non-permissible\ndepends on if the result of performing that action leads to a state satisfying\na condition which is forbidden, according to the norms regulating the\nmulti-agent system. This idea is formalized by defining set-theoretic\npredicates characterizing multi-agent systems. The definition of the predicate\nuses decision theory, the Kanger-Lindahl theory of normative positions, and an\nalgebraic representation of normative systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0311046v1", 
    "other_authors": [
        "Jan Odelstad", 
        "Magnus Boman"
    ], 
    "lead_author": "Magnus Boman", 
    "arxiv-id": "cs/0311046v1", 
    "title": "Algebras for Agent Norm-Regulation", 
    "publish": "2003-11-27T13:03:55Z", 
    "summary": "An abstract architecture for idealized multi-agent systems whose behaviour is\nregulated by normative systems is developed and discussed. Agent choices are\ndetermined partially by the preference ordering of possible states and\npartially by normative considerations: The agent chooses that act which leads\nto the best outcome of all permissible actions. If an action is non-permissible\ndepends on if the result of performing that action leads to a state satisfying\na condition which is forbidden, according to the norms regulating the\nmulti-agent system. This idea is formalized by defining set-theoretic\npredicates characterizing multi-agent systems. The definition of the predicate\nuses decision theory, the Kanger-Lindahl theory of normative positions, and an\nalgebraic representation of normative systems."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312002v1", 
    "other_authors": [
        "Paola Bruscoli", 
        "Alessio Guglielmi"
    ], 
    "lead_author": "Paola Bruscoli", 
    "arxiv-id": "cs/0312002v1", 
    "title": "On Structuring Proof Search for First Order Linear Logic", 
    "publish": "2003-12-01T14:33:06Z", 
    "summary": "Full first order linear logic can be presented as an abstract logic\nprogramming language in Miller's system Forum, which yields a sensible\noperational interpretation in the 'proof search as computation' paradigm.\nHowever, Forum still has to deal with syntactic details that would normally be\nignored by a reasonable operational semantics. In this respect, Forum improves\non Gentzen systems for linear logic by restricting the language and the form of\ninference rules. We further improve on Forum by restricting the class of\nformulae allowed, in a system we call G-Forum, which is still equivalent to\nfull first order linear logic. The only formulae allowed in G-Forum have the\nsame shape as Forum sequents: the restriction does not diminish expressiveness\nand makes G-Forum amenable to proof theoretic analysis. G-Forum consists of two\n(big) inference rules, for which we show a cut elimination procedure. This does\nnot need to appeal to finer detail in formulae and sequents than is provided by\nG-Forum, thus successfully testing the internal symmetries of our system."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312002v1", 
    "other_authors": [
        "Paola Bruscoli", 
        "Alessio Guglielmi"
    ], 
    "lead_author": "Paola Bruscoli", 
    "arxiv-id": "cs/0312002v1", 
    "title": "On Structuring Proof Search for First Order Linear Logic", 
    "publish": "2003-12-01T14:33:06Z", 
    "summary": "Full first order linear logic can be presented as an abstract logic\nprogramming language in Miller's system Forum, which yields a sensible\noperational interpretation in the 'proof search as computation' paradigm.\nHowever, Forum still has to deal with syntactic details that would normally be\nignored by a reasonable operational semantics. In this respect, Forum improves\non Gentzen systems for linear logic by restricting the language and the form of\ninference rules. We further improve on Forum by restricting the class of\nformulae allowed, in a system we call G-Forum, which is still equivalent to\nfull first order linear logic. The only formulae allowed in G-Forum have the\nsame shape as Forum sequents: the restriction does not diminish expressiveness\nand makes G-Forum amenable to proof theoretic analysis. G-Forum consists of two\n(big) inference rules, for which we show a cut elimination procedure. This does\nnot need to appeal to finer detail in formulae and sequents than is provided by\nG-Forum, thus successfully testing the internal symmetries of our system."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312002v1", 
    "other_authors": [
        "Paola Bruscoli", 
        "Alessio Guglielmi"
    ], 
    "lead_author": "Paola Bruscoli", 
    "arxiv-id": "cs/0312002v1", 
    "title": "On Structuring Proof Search for First Order Linear Logic", 
    "publish": "2003-12-01T14:33:06Z", 
    "summary": "Full first order linear logic can be presented as an abstract logic\nprogramming language in Miller's system Forum, which yields a sensible\noperational interpretation in the 'proof search as computation' paradigm.\nHowever, Forum still has to deal with syntactic details that would normally be\nignored by a reasonable operational semantics. In this respect, Forum improves\non Gentzen systems for linear logic by restricting the language and the form of\ninference rules. We further improve on Forum by restricting the class of\nformulae allowed, in a system we call G-Forum, which is still equivalent to\nfull first order linear logic. The only formulae allowed in G-Forum have the\nsame shape as Forum sequents: the restriction does not diminish expressiveness\nand makes G-Forum amenable to proof theoretic analysis. G-Forum consists of two\n(big) inference rules, for which we show a cut elimination procedure. This does\nnot need to appeal to finer detail in formulae and sequents than is provided by\nG-Forum, thus successfully testing the internal symmetries of our system."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312002v1", 
    "other_authors": [
        "Paola Bruscoli", 
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/0312002v1", 
    "title": "On Structuring Proof Search for First Order Linear Logic", 
    "publish": "2003-12-01T14:33:06Z", 
    "summary": "Full first order linear logic can be presented as an abstract logic\nprogramming language in Miller's system Forum, which yields a sensible\noperational interpretation in the 'proof search as computation' paradigm.\nHowever, Forum still has to deal with syntactic details that would normally be\nignored by a reasonable operational semantics. In this respect, Forum improves\non Gentzen systems for linear logic by restricting the language and the form of\ninference rules. We further improve on Forum by restricting the class of\nformulae allowed, in a system we call G-Forum, which is still equivalent to\nfull first order linear logic. The only formulae allowed in G-Forum have the\nsame shape as Forum sequents: the restriction does not diminish expressiveness\nand makes G-Forum amenable to proof theoretic analysis. G-Forum consists of two\n(big) inference rules, for which we show a cut elimination procedure. This does\nnot need to appeal to finer detail in formulae and sequents than is provided by\nG-Forum, thus successfully testing the internal symmetries of our system."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312002v1", 
    "other_authors": [
        "Paola Bruscoli", 
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/0312002v1", 
    "title": "On Structuring Proof Search for First Order Linear Logic", 
    "publish": "2003-12-01T14:33:06Z", 
    "summary": "Full first order linear logic can be presented as an abstract logic\nprogramming language in Miller's system Forum, which yields a sensible\noperational interpretation in the 'proof search as computation' paradigm.\nHowever, Forum still has to deal with syntactic details that would normally be\nignored by a reasonable operational semantics. In this respect, Forum improves\non Gentzen systems for linear logic by restricting the language and the form of\ninference rules. We further improve on Forum by restricting the class of\nformulae allowed, in a system we call G-Forum, which is still equivalent to\nfull first order linear logic. The only formulae allowed in G-Forum have the\nsame shape as Forum sequents: the restriction does not diminish expressiveness\nand makes G-Forum amenable to proof theoretic analysis. G-Forum consists of two\n(big) inference rules, for which we show a cut elimination procedure. This does\nnot need to appeal to finer detail in formulae and sequents than is provided by\nG-Forum, thus successfully testing the internal symmetries of our system."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312002v1", 
    "other_authors": [
        "Paola Bruscoli", 
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/0312002v1", 
    "title": "On Structuring Proof Search for First Order Linear Logic", 
    "publish": "2003-12-01T14:33:06Z", 
    "summary": "Full first order linear logic can be presented as an abstract logic\nprogramming language in Miller's system Forum, which yields a sensible\noperational interpretation in the 'proof search as computation' paradigm.\nHowever, Forum still has to deal with syntactic details that would normally be\nignored by a reasonable operational semantics. In this respect, Forum improves\non Gentzen systems for linear logic by restricting the language and the form of\ninference rules. We further improve on Forum by restricting the class of\nformulae allowed, in a system we call G-Forum, which is still equivalent to\nfull first order linear logic. The only formulae allowed in G-Forum have the\nsame shape as Forum sequents: the restriction does not diminish expressiveness\nand makes G-Forum amenable to proof theoretic analysis. G-Forum consists of two\n(big) inference rules, for which we show a cut elimination procedure. This does\nnot need to appeal to finer detail in formulae and sequents than is provided by\nG-Forum, thus successfully testing the internal symmetries of our system."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312002v1", 
    "other_authors": [
        "Paola Bruscoli", 
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/0312002v1", 
    "title": "On Structuring Proof Search for First Order Linear Logic", 
    "publish": "2003-12-01T14:33:06Z", 
    "summary": "Full first order linear logic can be presented as an abstract logic\nprogramming language in Miller's system Forum, which yields a sensible\noperational interpretation in the 'proof search as computation' paradigm.\nHowever, Forum still has to deal with syntactic details that would normally be\nignored by a reasonable operational semantics. In this respect, Forum improves\non Gentzen systems for linear logic by restricting the language and the form of\ninference rules. We further improve on Forum by restricting the class of\nformulae allowed, in a system we call G-Forum, which is still equivalent to\nfull first order linear logic. The only formulae allowed in G-Forum have the\nsame shape as Forum sequents: the restriction does not diminish expressiveness\nand makes G-Forum amenable to proof theoretic analysis. G-Forum consists of two\n(big) inference rules, for which we show a cut elimination procedure. This does\nnot need to appeal to finer detail in formulae and sequents than is provided by\nG-Forum, thus successfully testing the internal symmetries of our system."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312002v1", 
    "other_authors": [
        "Paola Bruscoli", 
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/0312002v1", 
    "title": "On Structuring Proof Search for First Order Linear Logic", 
    "publish": "2003-12-01T14:33:06Z", 
    "summary": "Full first order linear logic can be presented as an abstract logic\nprogramming language in Miller's system Forum, which yields a sensible\noperational interpretation in the 'proof search as computation' paradigm.\nHowever, Forum still has to deal with syntactic details that would normally be\nignored by a reasonable operational semantics. In this respect, Forum improves\non Gentzen systems for linear logic by restricting the language and the form of\ninference rules. We further improve on Forum by restricting the class of\nformulae allowed, in a system we call G-Forum, which is still equivalent to\nfull first order linear logic. The only formulae allowed in G-Forum have the\nsame shape as Forum sequents: the restriction does not diminish expressiveness\nand makes G-Forum amenable to proof theoretic analysis. G-Forum consists of two\n(big) inference rules, for which we show a cut elimination procedure. This does\nnot need to appeal to finer detail in formulae and sequents than is provided by\nG-Forum, thus successfully testing the internal symmetries of our system."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312002v1", 
    "other_authors": [
        "Paola Bruscoli", 
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/0312002v1", 
    "title": "On Structuring Proof Search for First Order Linear Logic", 
    "publish": "2003-12-01T14:33:06Z", 
    "summary": "Full first order linear logic can be presented as an abstract logic\nprogramming language in Miller's system Forum, which yields a sensible\noperational interpretation in the 'proof search as computation' paradigm.\nHowever, Forum still has to deal with syntactic details that would normally be\nignored by a reasonable operational semantics. In this respect, Forum improves\non Gentzen systems for linear logic by restricting the language and the form of\ninference rules. We further improve on Forum by restricting the class of\nformulae allowed, in a system we call G-Forum, which is still equivalent to\nfull first order linear logic. The only formulae allowed in G-Forum have the\nsame shape as Forum sequents: the restriction does not diminish expressiveness\nand makes G-Forum amenable to proof theoretic analysis. G-Forum consists of two\n(big) inference rules, for which we show a cut elimination procedure. This does\nnot need to appeal to finer detail in formulae and sequents than is provided by\nG-Forum, thus successfully testing the internal symmetries of our system."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312002v1", 
    "other_authors": [
        "Paola Bruscoli", 
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/0312002v1", 
    "title": "On Structuring Proof Search for First Order Linear Logic", 
    "publish": "2003-12-01T14:33:06Z", 
    "summary": "Full first order linear logic can be presented as an abstract logic\nprogramming language in Miller's system Forum, which yields a sensible\noperational interpretation in the 'proof search as computation' paradigm.\nHowever, Forum still has to deal with syntactic details that would normally be\nignored by a reasonable operational semantics. In this respect, Forum improves\non Gentzen systems for linear logic by restricting the language and the form of\ninference rules. We further improve on Forum by restricting the class of\nformulae allowed, in a system we call G-Forum, which is still equivalent to\nfull first order linear logic. The only formulae allowed in G-Forum have the\nsame shape as Forum sequents: the restriction does not diminish expressiveness\nand makes G-Forum amenable to proof theoretic analysis. G-Forum consists of two\n(big) inference rules, for which we show a cut elimination procedure. This does\nnot need to appeal to finer detail in formulae and sequents than is provided by\nG-Forum, thus successfully testing the internal symmetries of our system."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312002v1", 
    "other_authors": [
        "Paola Bruscoli", 
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/0312002v1", 
    "title": "On Structuring Proof Search for First Order Linear Logic", 
    "publish": "2003-12-01T14:33:06Z", 
    "summary": "Full first order linear logic can be presented as an abstract logic\nprogramming language in Miller's system Forum, which yields a sensible\noperational interpretation in the 'proof search as computation' paradigm.\nHowever, Forum still has to deal with syntactic details that would normally be\nignored by a reasonable operational semantics. In this respect, Forum improves\non Gentzen systems for linear logic by restricting the language and the form of\ninference rules. We further improve on Forum by restricting the class of\nformulae allowed, in a system we call G-Forum, which is still equivalent to\nfull first order linear logic. The only formulae allowed in G-Forum have the\nsame shape as Forum sequents: the restriction does not diminish expressiveness\nand makes G-Forum amenable to proof theoretic analysis. G-Forum consists of two\n(big) inference rules, for which we show a cut elimination procedure. This does\nnot need to appeal to finer detail in formulae and sequents than is provided by\nG-Forum, thus successfully testing the internal symmetries of our system."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312002v1", 
    "other_authors": [
        "Paola Bruscoli", 
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/0312002v1", 
    "title": "On Structuring Proof Search for First Order Linear Logic", 
    "publish": "2003-12-01T14:33:06Z", 
    "summary": "Full first order linear logic can be presented as an abstract logic\nprogramming language in Miller's system Forum, which yields a sensible\noperational interpretation in the 'proof search as computation' paradigm.\nHowever, Forum still has to deal with syntactic details that would normally be\nignored by a reasonable operational semantics. In this respect, Forum improves\non Gentzen systems for linear logic by restricting the language and the form of\ninference rules. We further improve on Forum by restricting the class of\nformulae allowed, in a system we call G-Forum, which is still equivalent to\nfull first order linear logic. The only formulae allowed in G-Forum have the\nsame shape as Forum sequents: the restriction does not diminish expressiveness\nand makes G-Forum amenable to proof theoretic analysis. G-Forum consists of two\n(big) inference rules, for which we show a cut elimination procedure. This does\nnot need to appeal to finer detail in formulae and sequents than is provided by\nG-Forum, thus successfully testing the internal symmetries of our system."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312002v1", 
    "other_authors": [
        "Paola Bruscoli", 
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/0312002v1", 
    "title": "On Structuring Proof Search for First Order Linear Logic", 
    "publish": "2003-12-01T14:33:06Z", 
    "summary": "Full first order linear logic can be presented as an abstract logic\nprogramming language in Miller's system Forum, which yields a sensible\noperational interpretation in the 'proof search as computation' paradigm.\nHowever, Forum still has to deal with syntactic details that would normally be\nignored by a reasonable operational semantics. In this respect, Forum improves\non Gentzen systems for linear logic by restricting the language and the form of\ninference rules. We further improve on Forum by restricting the class of\nformulae allowed, in a system we call G-Forum, which is still equivalent to\nfull first order linear logic. The only formulae allowed in G-Forum have the\nsame shape as Forum sequents: the restriction does not diminish expressiveness\nand makes G-Forum amenable to proof theoretic analysis. G-Forum consists of two\n(big) inference rules, for which we show a cut elimination procedure. This does\nnot need to appeal to finer detail in formulae and sequents than is provided by\nG-Forum, thus successfully testing the internal symmetries of our system."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312002v1", 
    "other_authors": [
        "Paola Bruscoli", 
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/0312002v1", 
    "title": "On Structuring Proof Search for First Order Linear Logic", 
    "publish": "2003-12-01T14:33:06Z", 
    "summary": "Full first order linear logic can be presented as an abstract logic\nprogramming language in Miller's system Forum, which yields a sensible\noperational interpretation in the 'proof search as computation' paradigm.\nHowever, Forum still has to deal with syntactic details that would normally be\nignored by a reasonable operational semantics. In this respect, Forum improves\non Gentzen systems for linear logic by restricting the language and the form of\ninference rules. We further improve on Forum by restricting the class of\nformulae allowed, in a system we call G-Forum, which is still equivalent to\nfull first order linear logic. The only formulae allowed in G-Forum have the\nsame shape as Forum sequents: the restriction does not diminish expressiveness\nand makes G-Forum amenable to proof theoretic analysis. G-Forum consists of two\n(big) inference rules, for which we show a cut elimination procedure. This does\nnot need to appeal to finer detail in formulae and sequents than is provided by\nG-Forum, thus successfully testing the internal symmetries of our system."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312002v1", 
    "other_authors": [
        "Paola Bruscoli", 
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/0312002v1", 
    "title": "On Structuring Proof Search for First Order Linear Logic", 
    "publish": "2003-12-01T14:33:06Z", 
    "summary": "Full first order linear logic can be presented as an abstract logic\nprogramming language in Miller's system Forum, which yields a sensible\noperational interpretation in the 'proof search as computation' paradigm.\nHowever, Forum still has to deal with syntactic details that would normally be\nignored by a reasonable operational semantics. In this respect, Forum improves\non Gentzen systems for linear logic by restricting the language and the form of\ninference rules. We further improve on Forum by restricting the class of\nformulae allowed, in a system we call G-Forum, which is still equivalent to\nfull first order linear logic. The only formulae allowed in G-Forum have the\nsame shape as Forum sequents: the restriction does not diminish expressiveness\nand makes G-Forum amenable to proof theoretic analysis. G-Forum consists of two\n(big) inference rules, for which we show a cut elimination procedure. This does\nnot need to appeal to finer detail in formulae and sequents than is provided by\nG-Forum, thus successfully testing the internal symmetries of our system."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312002v1", 
    "other_authors": [
        "Paola Bruscoli", 
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/0312002v1", 
    "title": "On Structuring Proof Search for First Order Linear Logic", 
    "publish": "2003-12-01T14:33:06Z", 
    "summary": "Full first order linear logic can be presented as an abstract logic\nprogramming language in Miller's system Forum, which yields a sensible\noperational interpretation in the 'proof search as computation' paradigm.\nHowever, Forum still has to deal with syntactic details that would normally be\nignored by a reasonable operational semantics. In this respect, Forum improves\non Gentzen systems for linear logic by restricting the language and the form of\ninference rules. We further improve on Forum by restricting the class of\nformulae allowed, in a system we call G-Forum, which is still equivalent to\nfull first order linear logic. The only formulae allowed in G-Forum have the\nsame shape as Forum sequents: the restriction does not diminish expressiveness\nand makes G-Forum amenable to proof theoretic analysis. G-Forum consists of two\n(big) inference rules, for which we show a cut elimination procedure. This does\nnot need to appeal to finer detail in formulae and sequents than is provided by\nG-Forum, thus successfully testing the internal symmetries of our system."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312002v1", 
    "other_authors": [
        "Paola Bruscoli", 
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/0312002v1", 
    "title": "On Structuring Proof Search for First Order Linear Logic", 
    "publish": "2003-12-01T14:33:06Z", 
    "summary": "Full first order linear logic can be presented as an abstract logic\nprogramming language in Miller's system Forum, which yields a sensible\noperational interpretation in the 'proof search as computation' paradigm.\nHowever, Forum still has to deal with syntactic details that would normally be\nignored by a reasonable operational semantics. In this respect, Forum improves\non Gentzen systems for linear logic by restricting the language and the form of\ninference rules. We further improve on Forum by restricting the class of\nformulae allowed, in a system we call G-Forum, which is still equivalent to\nfull first order linear logic. The only formulae allowed in G-Forum have the\nsame shape as Forum sequents: the restriction does not diminish expressiveness\nand makes G-Forum amenable to proof theoretic analysis. G-Forum consists of two\n(big) inference rules, for which we show a cut elimination procedure. This does\nnot need to appeal to finer detail in formulae and sequents than is provided by\nG-Forum, thus successfully testing the internal symmetries of our system."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312002v1", 
    "other_authors": [
        "Paola Bruscoli", 
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/0312002v1", 
    "title": "On Structuring Proof Search for First Order Linear Logic", 
    "publish": "2003-12-01T14:33:06Z", 
    "summary": "Full first order linear logic can be presented as an abstract logic\nprogramming language in Miller's system Forum, which yields a sensible\noperational interpretation in the 'proof search as computation' paradigm.\nHowever, Forum still has to deal with syntactic details that would normally be\nignored by a reasonable operational semantics. In this respect, Forum improves\non Gentzen systems for linear logic by restricting the language and the form of\ninference rules. We further improve on Forum by restricting the class of\nformulae allowed, in a system we call G-Forum, which is still equivalent to\nfull first order linear logic. The only formulae allowed in G-Forum have the\nsame shape as Forum sequents: the restriction does not diminish expressiveness\nand makes G-Forum amenable to proof theoretic analysis. G-Forum consists of two\n(big) inference rules, for which we show a cut elimination procedure. This does\nnot need to appeal to finer detail in formulae and sequents than is provided by\nG-Forum, thus successfully testing the internal symmetries of our system."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312002v1", 
    "other_authors": [
        "Paola Bruscoli", 
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/0312002v1", 
    "title": "On Structuring Proof Search for First Order Linear Logic", 
    "publish": "2003-12-01T14:33:06Z", 
    "summary": "Full first order linear logic can be presented as an abstract logic\nprogramming language in Miller's system Forum, which yields a sensible\noperational interpretation in the 'proof search as computation' paradigm.\nHowever, Forum still has to deal with syntactic details that would normally be\nignored by a reasonable operational semantics. In this respect, Forum improves\non Gentzen systems for linear logic by restricting the language and the form of\ninference rules. We further improve on Forum by restricting the class of\nformulae allowed, in a system we call G-Forum, which is still equivalent to\nfull first order linear logic. The only formulae allowed in G-Forum have the\nsame shape as Forum sequents: the restriction does not diminish expressiveness\nand makes G-Forum amenable to proof theoretic analysis. G-Forum consists of two\n(big) inference rules, for which we show a cut elimination procedure. This does\nnot need to appeal to finer detail in formulae and sequents than is provided by\nG-Forum, thus successfully testing the internal symmetries of our system."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312002v1", 
    "other_authors": [
        "Paola Bruscoli", 
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/0312002v1", 
    "title": "On Structuring Proof Search for First Order Linear Logic", 
    "publish": "2003-12-01T14:33:06Z", 
    "summary": "Full first order linear logic can be presented as an abstract logic\nprogramming language in Miller's system Forum, which yields a sensible\noperational interpretation in the 'proof search as computation' paradigm.\nHowever, Forum still has to deal with syntactic details that would normally be\nignored by a reasonable operational semantics. In this respect, Forum improves\non Gentzen systems for linear logic by restricting the language and the form of\ninference rules. We further improve on Forum by restricting the class of\nformulae allowed, in a system we call G-Forum, which is still equivalent to\nfull first order linear logic. The only formulae allowed in G-Forum have the\nsame shape as Forum sequents: the restriction does not diminish expressiveness\nand makes G-Forum amenable to proof theoretic analysis. G-Forum consists of two\n(big) inference rules, for which we show a cut elimination procedure. This does\nnot need to appeal to finer detail in formulae and sequents than is provided by\nG-Forum, thus successfully testing the internal symmetries of our system."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312002v1", 
    "other_authors": [
        "Paola Bruscoli", 
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/0312002v1", 
    "title": "On Structuring Proof Search for First Order Linear Logic", 
    "publish": "2003-12-01T14:33:06Z", 
    "summary": "Full first order linear logic can be presented as an abstract logic\nprogramming language in Miller's system Forum, which yields a sensible\noperational interpretation in the 'proof search as computation' paradigm.\nHowever, Forum still has to deal with syntactic details that would normally be\nignored by a reasonable operational semantics. In this respect, Forum improves\non Gentzen systems for linear logic by restricting the language and the form of\ninference rules. We further improve on Forum by restricting the class of\nformulae allowed, in a system we call G-Forum, which is still equivalent to\nfull first order linear logic. The only formulae allowed in G-Forum have the\nsame shape as Forum sequents: the restriction does not diminish expressiveness\nand makes G-Forum amenable to proof theoretic analysis. G-Forum consists of two\n(big) inference rules, for which we show a cut elimination procedure. This does\nnot need to appeal to finer detail in formulae and sequents than is provided by\nG-Forum, thus successfully testing the internal symmetries of our system."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312002v1", 
    "other_authors": [
        "Paola Bruscoli", 
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/0312002v1", 
    "title": "On Structuring Proof Search for First Order Linear Logic", 
    "publish": "2003-12-01T14:33:06Z", 
    "summary": "Full first order linear logic can be presented as an abstract logic\nprogramming language in Miller's system Forum, which yields a sensible\noperational interpretation in the 'proof search as computation' paradigm.\nHowever, Forum still has to deal with syntactic details that would normally be\nignored by a reasonable operational semantics. In this respect, Forum improves\non Gentzen systems for linear logic by restricting the language and the form of\ninference rules. We further improve on Forum by restricting the class of\nformulae allowed, in a system we call G-Forum, which is still equivalent to\nfull first order linear logic. The only formulae allowed in G-Forum have the\nsame shape as Forum sequents: the restriction does not diminish expressiveness\nand makes G-Forum amenable to proof theoretic analysis. G-Forum consists of two\n(big) inference rules, for which we show a cut elimination procedure. This does\nnot need to appeal to finer detail in formulae and sequents than is provided by\nG-Forum, thus successfully testing the internal symmetries of our system."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312002v1", 
    "other_authors": [
        "Paola Bruscoli", 
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/0312002v1", 
    "title": "On Structuring Proof Search for First Order Linear Logic", 
    "publish": "2003-12-01T14:33:06Z", 
    "summary": "Full first order linear logic can be presented as an abstract logic\nprogramming language in Miller's system Forum, which yields a sensible\noperational interpretation in the 'proof search as computation' paradigm.\nHowever, Forum still has to deal with syntactic details that would normally be\nignored by a reasonable operational semantics. In this respect, Forum improves\non Gentzen systems for linear logic by restricting the language and the form of\ninference rules. We further improve on Forum by restricting the class of\nformulae allowed, in a system we call G-Forum, which is still equivalent to\nfull first order linear logic. The only formulae allowed in G-Forum have the\nsame shape as Forum sequents: the restriction does not diminish expressiveness\nand makes G-Forum amenable to proof theoretic analysis. G-Forum consists of two\n(big) inference rules, for which we show a cut elimination procedure. This does\nnot need to appeal to finer detail in formulae and sequents than is provided by\nG-Forum, thus successfully testing the internal symmetries of our system."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312002v1", 
    "other_authors": [
        "Paola Bruscoli", 
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/0312002v1", 
    "title": "On Structuring Proof Search for First Order Linear Logic", 
    "publish": "2003-12-01T14:33:06Z", 
    "summary": "Full first order linear logic can be presented as an abstract logic\nprogramming language in Miller's system Forum, which yields a sensible\noperational interpretation in the 'proof search as computation' paradigm.\nHowever, Forum still has to deal with syntactic details that would normally be\nignored by a reasonable operational semantics. In this respect, Forum improves\non Gentzen systems for linear logic by restricting the language and the form of\ninference rules. We further improve on Forum by restricting the class of\nformulae allowed, in a system we call G-Forum, which is still equivalent to\nfull first order linear logic. The only formulae allowed in G-Forum have the\nsame shape as Forum sequents: the restriction does not diminish expressiveness\nand makes G-Forum amenable to proof theoretic analysis. G-Forum consists of two\n(big) inference rules, for which we show a cut elimination procedure. This does\nnot need to appeal to finer detail in formulae and sequents than is provided by\nG-Forum, thus successfully testing the internal symmetries of our system."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312002v1", 
    "other_authors": [
        "Paola Bruscoli", 
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/0312002v1", 
    "title": "On Structuring Proof Search for First Order Linear Logic", 
    "publish": "2003-12-01T14:33:06Z", 
    "summary": "Full first order linear logic can be presented as an abstract logic\nprogramming language in Miller's system Forum, which yields a sensible\noperational interpretation in the 'proof search as computation' paradigm.\nHowever, Forum still has to deal with syntactic details that would normally be\nignored by a reasonable operational semantics. In this respect, Forum improves\non Gentzen systems for linear logic by restricting the language and the form of\ninference rules. We further improve on Forum by restricting the class of\nformulae allowed, in a system we call G-Forum, which is still equivalent to\nfull first order linear logic. The only formulae allowed in G-Forum have the\nsame shape as Forum sequents: the restriction does not diminish expressiveness\nand makes G-Forum amenable to proof theoretic analysis. G-Forum consists of two\n(big) inference rules, for which we show a cut elimination procedure. This does\nnot need to appeal to finer detail in formulae and sequents than is provided by\nG-Forum, thus successfully testing the internal symmetries of our system."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312002v1", 
    "other_authors": [
        "Paola Bruscoli", 
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/0312002v1", 
    "title": "On Structuring Proof Search for First Order Linear Logic", 
    "publish": "2003-12-01T14:33:06Z", 
    "summary": "Full first order linear logic can be presented as an abstract logic\nprogramming language in Miller's system Forum, which yields a sensible\noperational interpretation in the 'proof search as computation' paradigm.\nHowever, Forum still has to deal with syntactic details that would normally be\nignored by a reasonable operational semantics. In this respect, Forum improves\non Gentzen systems for linear logic by restricting the language and the form of\ninference rules. We further improve on Forum by restricting the class of\nformulae allowed, in a system we call G-Forum, which is still equivalent to\nfull first order linear logic. The only formulae allowed in G-Forum have the\nsame shape as Forum sequents: the restriction does not diminish expressiveness\nand makes G-Forum amenable to proof theoretic analysis. G-Forum consists of two\n(big) inference rules, for which we show a cut elimination procedure. This does\nnot need to appeal to finer detail in formulae and sequents than is provided by\nG-Forum, thus successfully testing the internal symmetries of our system."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312002v1", 
    "other_authors": [
        "Paola Bruscoli", 
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/0312002v1", 
    "title": "On Structuring Proof Search for First Order Linear Logic", 
    "publish": "2003-12-01T14:33:06Z", 
    "summary": "Full first order linear logic can be presented as an abstract logic\nprogramming language in Miller's system Forum, which yields a sensible\noperational interpretation in the 'proof search as computation' paradigm.\nHowever, Forum still has to deal with syntactic details that would normally be\nignored by a reasonable operational semantics. In this respect, Forum improves\non Gentzen systems for linear logic by restricting the language and the form of\ninference rules. We further improve on Forum by restricting the class of\nformulae allowed, in a system we call G-Forum, which is still equivalent to\nfull first order linear logic. The only formulae allowed in G-Forum have the\nsame shape as Forum sequents: the restriction does not diminish expressiveness\nand makes G-Forum amenable to proof theoretic analysis. G-Forum consists of two\n(big) inference rules, for which we show a cut elimination procedure. This does\nnot need to appeal to finer detail in formulae and sequents than is provided by\nG-Forum, thus successfully testing the internal symmetries of our system."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312002v1", 
    "other_authors": [
        "Paola Bruscoli", 
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/0312002v1", 
    "title": "On Structuring Proof Search for First Order Linear Logic", 
    "publish": "2003-12-01T14:33:06Z", 
    "summary": "Full first order linear logic can be presented as an abstract logic\nprogramming language in Miller's system Forum, which yields a sensible\noperational interpretation in the 'proof search as computation' paradigm.\nHowever, Forum still has to deal with syntactic details that would normally be\nignored by a reasonable operational semantics. In this respect, Forum improves\non Gentzen systems for linear logic by restricting the language and the form of\ninference rules. We further improve on Forum by restricting the class of\nformulae allowed, in a system we call G-Forum, which is still equivalent to\nfull first order linear logic. The only formulae allowed in G-Forum have the\nsame shape as Forum sequents: the restriction does not diminish expressiveness\nand makes G-Forum amenable to proof theoretic analysis. G-Forum consists of two\n(big) inference rules, for which we show a cut elimination procedure. This does\nnot need to appeal to finer detail in formulae and sequents than is provided by\nG-Forum, thus successfully testing the internal symmetries of our system."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312002v1", 
    "other_authors": [
        "Paola Bruscoli", 
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/0312002v1", 
    "title": "On Structuring Proof Search for First Order Linear Logic", 
    "publish": "2003-12-01T14:33:06Z", 
    "summary": "Full first order linear logic can be presented as an abstract logic\nprogramming language in Miller's system Forum, which yields a sensible\noperational interpretation in the 'proof search as computation' paradigm.\nHowever, Forum still has to deal with syntactic details that would normally be\nignored by a reasonable operational semantics. In this respect, Forum improves\non Gentzen systems for linear logic by restricting the language and the form of\ninference rules. We further improve on Forum by restricting the class of\nformulae allowed, in a system we call G-Forum, which is still equivalent to\nfull first order linear logic. The only formulae allowed in G-Forum have the\nsame shape as Forum sequents: the restriction does not diminish expressiveness\nand makes G-Forum amenable to proof theoretic analysis. G-Forum consists of two\n(big) inference rules, for which we show a cut elimination procedure. This does\nnot need to appeal to finer detail in formulae and sequents than is provided by\nG-Forum, thus successfully testing the internal symmetries of our system."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312002v1", 
    "other_authors": [
        "Paola Bruscoli", 
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/0312002v1", 
    "title": "On Structuring Proof Search for First Order Linear Logic", 
    "publish": "2003-12-01T14:33:06Z", 
    "summary": "Full first order linear logic can be presented as an abstract logic\nprogramming language in Miller's system Forum, which yields a sensible\noperational interpretation in the 'proof search as computation' paradigm.\nHowever, Forum still has to deal with syntactic details that would normally be\nignored by a reasonable operational semantics. In this respect, Forum improves\non Gentzen systems for linear logic by restricting the language and the form of\ninference rules. We further improve on Forum by restricting the class of\nformulae allowed, in a system we call G-Forum, which is still equivalent to\nfull first order linear logic. The only formulae allowed in G-Forum have the\nsame shape as Forum sequents: the restriction does not diminish expressiveness\nand makes G-Forum amenable to proof theoretic analysis. G-Forum consists of two\n(big) inference rules, for which we show a cut elimination procedure. This does\nnot need to appeal to finer detail in formulae and sequents than is provided by\nG-Forum, thus successfully testing the internal symmetries of our system."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312002v1", 
    "other_authors": [
        "Paola Bruscoli", 
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/0312002v1", 
    "title": "On Structuring Proof Search for First Order Linear Logic", 
    "publish": "2003-12-01T14:33:06Z", 
    "summary": "Full first order linear logic can be presented as an abstract logic\nprogramming language in Miller's system Forum, which yields a sensible\noperational interpretation in the 'proof search as computation' paradigm.\nHowever, Forum still has to deal with syntactic details that would normally be\nignored by a reasonable operational semantics. In this respect, Forum improves\non Gentzen systems for linear logic by restricting the language and the form of\ninference rules. We further improve on Forum by restricting the class of\nformulae allowed, in a system we call G-Forum, which is still equivalent to\nfull first order linear logic. The only formulae allowed in G-Forum have the\nsame shape as Forum sequents: the restriction does not diminish expressiveness\nand makes G-Forum amenable to proof theoretic analysis. G-Forum consists of two\n(big) inference rules, for which we show a cut elimination procedure. This does\nnot need to appeal to finer detail in formulae and sequents than is provided by\nG-Forum, thus successfully testing the internal symmetries of our system."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312002v1", 
    "other_authors": [
        "Paola Bruscoli", 
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/0312002v1", 
    "title": "On Structuring Proof Search for First Order Linear Logic", 
    "publish": "2003-12-01T14:33:06Z", 
    "summary": "Full first order linear logic can be presented as an abstract logic\nprogramming language in Miller's system Forum, which yields a sensible\noperational interpretation in the 'proof search as computation' paradigm.\nHowever, Forum still has to deal with syntactic details that would normally be\nignored by a reasonable operational semantics. In this respect, Forum improves\non Gentzen systems for linear logic by restricting the language and the form of\ninference rules. We further improve on Forum by restricting the class of\nformulae allowed, in a system we call G-Forum, which is still equivalent to\nfull first order linear logic. The only formulae allowed in G-Forum have the\nsame shape as Forum sequents: the restriction does not diminish expressiveness\nand makes G-Forum amenable to proof theoretic analysis. G-Forum consists of two\n(big) inference rules, for which we show a cut elimination procedure. This does\nnot need to appeal to finer detail in formulae and sequents than is provided by\nG-Forum, thus successfully testing the internal symmetries of our system."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312002v1", 
    "other_authors": [
        "Paola Bruscoli", 
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/0312002v1", 
    "title": "On Structuring Proof Search for First Order Linear Logic", 
    "publish": "2003-12-01T14:33:06Z", 
    "summary": "Full first order linear logic can be presented as an abstract logic\nprogramming language in Miller's system Forum, which yields a sensible\noperational interpretation in the 'proof search as computation' paradigm.\nHowever, Forum still has to deal with syntactic details that would normally be\nignored by a reasonable operational semantics. In this respect, Forum improves\non Gentzen systems for linear logic by restricting the language and the form of\ninference rules. We further improve on Forum by restricting the class of\nformulae allowed, in a system we call G-Forum, which is still equivalent to\nfull first order linear logic. The only formulae allowed in G-Forum have the\nsame shape as Forum sequents: the restriction does not diminish expressiveness\nand makes G-Forum amenable to proof theoretic analysis. G-Forum consists of two\n(big) inference rules, for which we show a cut elimination procedure. This does\nnot need to appeal to finer detail in formulae and sequents than is provided by\nG-Forum, thus successfully testing the internal symmetries of our system."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312002v1", 
    "other_authors": [
        "Paola Bruscoli", 
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/0312002v1", 
    "title": "On Structuring Proof Search for First Order Linear Logic", 
    "publish": "2003-12-01T14:33:06Z", 
    "summary": "Full first order linear logic can be presented as an abstract logic\nprogramming language in Miller's system Forum, which yields a sensible\noperational interpretation in the 'proof search as computation' paradigm.\nHowever, Forum still has to deal with syntactic details that would normally be\nignored by a reasonable operational semantics. In this respect, Forum improves\non Gentzen systems for linear logic by restricting the language and the form of\ninference rules. We further improve on Forum by restricting the class of\nformulae allowed, in a system we call G-Forum, which is still equivalent to\nfull first order linear logic. The only formulae allowed in G-Forum have the\nsame shape as Forum sequents: the restriction does not diminish expressiveness\nand makes G-Forum amenable to proof theoretic analysis. G-Forum consists of two\n(big) inference rules, for which we show a cut elimination procedure. This does\nnot need to appeal to finer detail in formulae and sequents than is provided by\nG-Forum, thus successfully testing the internal symmetries of our system."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312002v1", 
    "other_authors": [
        "Paola Bruscoli", 
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/0312002v1", 
    "title": "On Structuring Proof Search for First Order Linear Logic", 
    "publish": "2003-12-01T14:33:06Z", 
    "summary": "Full first order linear logic can be presented as an abstract logic\nprogramming language in Miller's system Forum, which yields a sensible\noperational interpretation in the 'proof search as computation' paradigm.\nHowever, Forum still has to deal with syntactic details that would normally be\nignored by a reasonable operational semantics. In this respect, Forum improves\non Gentzen systems for linear logic by restricting the language and the form of\ninference rules. We further improve on Forum by restricting the class of\nformulae allowed, in a system we call G-Forum, which is still equivalent to\nfull first order linear logic. The only formulae allowed in G-Forum have the\nsame shape as Forum sequents: the restriction does not diminish expressiveness\nand makes G-Forum amenable to proof theoretic analysis. G-Forum consists of two\n(big) inference rules, for which we show a cut elimination procedure. This does\nnot need to appeal to finer detail in formulae and sequents than is provided by\nG-Forum, thus successfully testing the internal symmetries of our system."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312002v1", 
    "other_authors": [
        "Paola Bruscoli", 
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/0312002v1", 
    "title": "On Structuring Proof Search for First Order Linear Logic", 
    "publish": "2003-12-01T14:33:06Z", 
    "summary": "Full first order linear logic can be presented as an abstract logic\nprogramming language in Miller's system Forum, which yields a sensible\noperational interpretation in the 'proof search as computation' paradigm.\nHowever, Forum still has to deal with syntactic details that would normally be\nignored by a reasonable operational semantics. In this respect, Forum improves\non Gentzen systems for linear logic by restricting the language and the form of\ninference rules. We further improve on Forum by restricting the class of\nformulae allowed, in a system we call G-Forum, which is still equivalent to\nfull first order linear logic. The only formulae allowed in G-Forum have the\nsame shape as Forum sequents: the restriction does not diminish expressiveness\nand makes G-Forum amenable to proof theoretic analysis. G-Forum consists of two\n(big) inference rules, for which we show a cut elimination procedure. This does\nnot need to appeal to finer detail in formulae and sequents than is provided by\nG-Forum, thus successfully testing the internal symmetries of our system."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312002v1", 
    "other_authors": [
        "Paola Bruscoli", 
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/0312002v1", 
    "title": "On Structuring Proof Search for First Order Linear Logic", 
    "publish": "2003-12-01T14:33:06Z", 
    "summary": "Full first order linear logic can be presented as an abstract logic\nprogramming language in Miller's system Forum, which yields a sensible\noperational interpretation in the 'proof search as computation' paradigm.\nHowever, Forum still has to deal with syntactic details that would normally be\nignored by a reasonable operational semantics. In this respect, Forum improves\non Gentzen systems for linear logic by restricting the language and the form of\ninference rules. We further improve on Forum by restricting the class of\nformulae allowed, in a system we call G-Forum, which is still equivalent to\nfull first order linear logic. The only formulae allowed in G-Forum have the\nsame shape as Forum sequents: the restriction does not diminish expressiveness\nand makes G-Forum amenable to proof theoretic analysis. G-Forum consists of two\n(big) inference rules, for which we show a cut elimination procedure. This does\nnot need to appeal to finer detail in formulae and sequents than is provided by\nG-Forum, thus successfully testing the internal symmetries of our system."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312002v1", 
    "other_authors": [
        "Paola Bruscoli", 
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/0312002v1", 
    "title": "On Structuring Proof Search for First Order Linear Logic", 
    "publish": "2003-12-01T14:33:06Z", 
    "summary": "Full first order linear logic can be presented as an abstract logic\nprogramming language in Miller's system Forum, which yields a sensible\noperational interpretation in the 'proof search as computation' paradigm.\nHowever, Forum still has to deal with syntactic details that would normally be\nignored by a reasonable operational semantics. In this respect, Forum improves\non Gentzen systems for linear logic by restricting the language and the form of\ninference rules. We further improve on Forum by restricting the class of\nformulae allowed, in a system we call G-Forum, which is still equivalent to\nfull first order linear logic. The only formulae allowed in G-Forum have the\nsame shape as Forum sequents: the restriction does not diminish expressiveness\nand makes G-Forum amenable to proof theoretic analysis. G-Forum consists of two\n(big) inference rules, for which we show a cut elimination procedure. This does\nnot need to appeal to finer detail in formulae and sequents than is provided by\nG-Forum, thus successfully testing the internal symmetries of our system."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312002v1", 
    "other_authors": [
        "Paola Bruscoli", 
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/0312002v1", 
    "title": "On Structuring Proof Search for First Order Linear Logic", 
    "publish": "2003-12-01T14:33:06Z", 
    "summary": "Full first order linear logic can be presented as an abstract logic\nprogramming language in Miller's system Forum, which yields a sensible\noperational interpretation in the 'proof search as computation' paradigm.\nHowever, Forum still has to deal with syntactic details that would normally be\nignored by a reasonable operational semantics. In this respect, Forum improves\non Gentzen systems for linear logic by restricting the language and the form of\ninference rules. We further improve on Forum by restricting the class of\nformulae allowed, in a system we call G-Forum, which is still equivalent to\nfull first order linear logic. The only formulae allowed in G-Forum have the\nsame shape as Forum sequents: the restriction does not diminish expressiveness\nand makes G-Forum amenable to proof theoretic analysis. G-Forum consists of two\n(big) inference rules, for which we show a cut elimination procedure. This does\nnot need to appeal to finer detail in formulae and sequents than is provided by\nG-Forum, thus successfully testing the internal symmetries of our system."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312002v1", 
    "other_authors": [
        "Paola Bruscoli", 
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/0312002v1", 
    "title": "On Structuring Proof Search for First Order Linear Logic", 
    "publish": "2003-12-01T14:33:06Z", 
    "summary": "Full first order linear logic can be presented as an abstract logic\nprogramming language in Miller's system Forum, which yields a sensible\noperational interpretation in the 'proof search as computation' paradigm.\nHowever, Forum still has to deal with syntactic details that would normally be\nignored by a reasonable operational semantics. In this respect, Forum improves\non Gentzen systems for linear logic by restricting the language and the form of\ninference rules. We further improve on Forum by restricting the class of\nformulae allowed, in a system we call G-Forum, which is still equivalent to\nfull first order linear logic. The only formulae allowed in G-Forum have the\nsame shape as Forum sequents: the restriction does not diminish expressiveness\nand makes G-Forum amenable to proof theoretic analysis. G-Forum consists of two\n(big) inference rules, for which we show a cut elimination procedure. This does\nnot need to appeal to finer detail in formulae and sequents than is provided by\nG-Forum, thus successfully testing the internal symmetries of our system."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312002v1", 
    "other_authors": [
        "Paola Bruscoli", 
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/0312002v1", 
    "title": "On Structuring Proof Search for First Order Linear Logic", 
    "publish": "2003-12-01T14:33:06Z", 
    "summary": "Full first order linear logic can be presented as an abstract logic\nprogramming language in Miller's system Forum, which yields a sensible\noperational interpretation in the 'proof search as computation' paradigm.\nHowever, Forum still has to deal with syntactic details that would normally be\nignored by a reasonable operational semantics. In this respect, Forum improves\non Gentzen systems for linear logic by restricting the language and the form of\ninference rules. We further improve on Forum by restricting the class of\nformulae allowed, in a system we call G-Forum, which is still equivalent to\nfull first order linear logic. The only formulae allowed in G-Forum have the\nsame shape as Forum sequents: the restriction does not diminish expressiveness\nand makes G-Forum amenable to proof theoretic analysis. G-Forum consists of two\n(big) inference rules, for which we show a cut elimination procedure. This does\nnot need to appeal to finer detail in formulae and sequents than is provided by\nG-Forum, thus successfully testing the internal symmetries of our system."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312002v1", 
    "other_authors": [
        "Paola Bruscoli", 
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/0312002v1", 
    "title": "On Structuring Proof Search for First Order Linear Logic", 
    "publish": "2003-12-01T14:33:06Z", 
    "summary": "Full first order linear logic can be presented as an abstract logic\nprogramming language in Miller's system Forum, which yields a sensible\noperational interpretation in the 'proof search as computation' paradigm.\nHowever, Forum still has to deal with syntactic details that would normally be\nignored by a reasonable operational semantics. In this respect, Forum improves\non Gentzen systems for linear logic by restricting the language and the form of\ninference rules. We further improve on Forum by restricting the class of\nformulae allowed, in a system we call G-Forum, which is still equivalent to\nfull first order linear logic. The only formulae allowed in G-Forum have the\nsame shape as Forum sequents: the restriction does not diminish expressiveness\nand makes G-Forum amenable to proof theoretic analysis. G-Forum consists of two\n(big) inference rules, for which we show a cut elimination procedure. This does\nnot need to appeal to finer detail in formulae and sequents than is provided by\nG-Forum, thus successfully testing the internal symmetries of our system."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312002v1", 
    "other_authors": [
        "Paola Bruscoli", 
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/0312002v1", 
    "title": "On Structuring Proof Search for First Order Linear Logic", 
    "publish": "2003-12-01T14:33:06Z", 
    "summary": "Full first order linear logic can be presented as an abstract logic\nprogramming language in Miller's system Forum, which yields a sensible\noperational interpretation in the 'proof search as computation' paradigm.\nHowever, Forum still has to deal with syntactic details that would normally be\nignored by a reasonable operational semantics. In this respect, Forum improves\non Gentzen systems for linear logic by restricting the language and the form of\ninference rules. We further improve on Forum by restricting the class of\nformulae allowed, in a system we call G-Forum, which is still equivalent to\nfull first order linear logic. The only formulae allowed in G-Forum have the\nsame shape as Forum sequents: the restriction does not diminish expressiveness\nand makes G-Forum amenable to proof theoretic analysis. G-Forum consists of two\n(big) inference rules, for which we show a cut elimination procedure. This does\nnot need to appeal to finer detail in formulae and sequents than is provided by\nG-Forum, thus successfully testing the internal symmetries of our system."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312002v1", 
    "other_authors": [
        "Paola Bruscoli", 
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/0312002v1", 
    "title": "On Structuring Proof Search for First Order Linear Logic", 
    "publish": "2003-12-01T14:33:06Z", 
    "summary": "Full first order linear logic can be presented as an abstract logic\nprogramming language in Miller's system Forum, which yields a sensible\noperational interpretation in the 'proof search as computation' paradigm.\nHowever, Forum still has to deal with syntactic details that would normally be\nignored by a reasonable operational semantics. In this respect, Forum improves\non Gentzen systems for linear logic by restricting the language and the form of\ninference rules. We further improve on Forum by restricting the class of\nformulae allowed, in a system we call G-Forum, which is still equivalent to\nfull first order linear logic. The only formulae allowed in G-Forum have the\nsame shape as Forum sequents: the restriction does not diminish expressiveness\nand makes G-Forum amenable to proof theoretic analysis. G-Forum consists of two\n(big) inference rules, for which we show a cut elimination procedure. This does\nnot need to appeal to finer detail in formulae and sequents than is provided by\nG-Forum, thus successfully testing the internal symmetries of our system."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312002v1", 
    "other_authors": [
        "Paola Bruscoli", 
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/0312002v1", 
    "title": "On Structuring Proof Search for First Order Linear Logic", 
    "publish": "2003-12-01T14:33:06Z", 
    "summary": "Full first order linear logic can be presented as an abstract logic\nprogramming language in Miller's system Forum, which yields a sensible\noperational interpretation in the 'proof search as computation' paradigm.\nHowever, Forum still has to deal with syntactic details that would normally be\nignored by a reasonable operational semantics. In this respect, Forum improves\non Gentzen systems for linear logic by restricting the language and the form of\ninference rules. We further improve on Forum by restricting the class of\nformulae allowed, in a system we call G-Forum, which is still equivalent to\nfull first order linear logic. The only formulae allowed in G-Forum have the\nsame shape as Forum sequents: the restriction does not diminish expressiveness\nand makes G-Forum amenable to proof theoretic analysis. G-Forum consists of two\n(big) inference rules, for which we show a cut elimination procedure. This does\nnot need to appeal to finer detail in formulae and sequents than is provided by\nG-Forum, thus successfully testing the internal symmetries of our system."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312002v1", 
    "other_authors": [
        "Paola Bruscoli", 
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/0312002v1", 
    "title": "On Structuring Proof Search for First Order Linear Logic", 
    "publish": "2003-12-01T14:33:06Z", 
    "summary": "Full first order linear logic can be presented as an abstract logic\nprogramming language in Miller's system Forum, which yields a sensible\noperational interpretation in the 'proof search as computation' paradigm.\nHowever, Forum still has to deal with syntactic details that would normally be\nignored by a reasonable operational semantics. In this respect, Forum improves\non Gentzen systems for linear logic by restricting the language and the form of\ninference rules. We further improve on Forum by restricting the class of\nformulae allowed, in a system we call G-Forum, which is still equivalent to\nfull first order linear logic. The only formulae allowed in G-Forum have the\nsame shape as Forum sequents: the restriction does not diminish expressiveness\nand makes G-Forum amenable to proof theoretic analysis. G-Forum consists of two\n(big) inference rules, for which we show a cut elimination procedure. This does\nnot need to appeal to finer detail in formulae and sequents than is provided by\nG-Forum, thus successfully testing the internal symmetries of our system."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312002v1", 
    "other_authors": [
        "Paola Bruscoli", 
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/0312002v1", 
    "title": "On Structuring Proof Search for First Order Linear Logic", 
    "publish": "2003-12-01T14:33:06Z", 
    "summary": "Full first order linear logic can be presented as an abstract logic\nprogramming language in Miller's system Forum, which yields a sensible\noperational interpretation in the 'proof search as computation' paradigm.\nHowever, Forum still has to deal with syntactic details that would normally be\nignored by a reasonable operational semantics. In this respect, Forum improves\non Gentzen systems for linear logic by restricting the language and the form of\ninference rules. We further improve on Forum by restricting the class of\nformulae allowed, in a system we call G-Forum, which is still equivalent to\nfull first order linear logic. The only formulae allowed in G-Forum have the\nsame shape as Forum sequents: the restriction does not diminish expressiveness\nand makes G-Forum amenable to proof theoretic analysis. G-Forum consists of two\n(big) inference rules, for which we show a cut elimination procedure. This does\nnot need to appeal to finer detail in formulae and sequents than is provided by\nG-Forum, thus successfully testing the internal symmetries of our system."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312002v1", 
    "other_authors": [
        "Paola Bruscoli", 
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/0312002v1", 
    "title": "On Structuring Proof Search for First Order Linear Logic", 
    "publish": "2003-12-01T14:33:06Z", 
    "summary": "Full first order linear logic can be presented as an abstract logic\nprogramming language in Miller's system Forum, which yields a sensible\noperational interpretation in the 'proof search as computation' paradigm.\nHowever, Forum still has to deal with syntactic details that would normally be\nignored by a reasonable operational semantics. In this respect, Forum improves\non Gentzen systems for linear logic by restricting the language and the form of\ninference rules. We further improve on Forum by restricting the class of\nformulae allowed, in a system we call G-Forum, which is still equivalent to\nfull first order linear logic. The only formulae allowed in G-Forum have the\nsame shape as Forum sequents: the restriction does not diminish expressiveness\nand makes G-Forum amenable to proof theoretic analysis. G-Forum consists of two\n(big) inference rules, for which we show a cut elimination procedure. This does\nnot need to appeal to finer detail in formulae and sequents than is provided by\nG-Forum, thus successfully testing the internal symmetries of our system."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312002v1", 
    "other_authors": [
        "Paola Bruscoli", 
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/0312002v1", 
    "title": "On Structuring Proof Search for First Order Linear Logic", 
    "publish": "2003-12-01T14:33:06Z", 
    "summary": "Full first order linear logic can be presented as an abstract logic\nprogramming language in Miller's system Forum, which yields a sensible\noperational interpretation in the 'proof search as computation' paradigm.\nHowever, Forum still has to deal with syntactic details that would normally be\nignored by a reasonable operational semantics. In this respect, Forum improves\non Gentzen systems for linear logic by restricting the language and the form of\ninference rules. We further improve on Forum by restricting the class of\nformulae allowed, in a system we call G-Forum, which is still equivalent to\nfull first order linear logic. The only formulae allowed in G-Forum have the\nsame shape as Forum sequents: the restriction does not diminish expressiveness\nand makes G-Forum amenable to proof theoretic analysis. G-Forum consists of two\n(big) inference rules, for which we show a cut elimination procedure. This does\nnot need to appeal to finer detail in formulae and sequents than is provided by\nG-Forum, thus successfully testing the internal symmetries of our system."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312002v1", 
    "other_authors": [
        "Paola Bruscoli", 
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/0312002v1", 
    "title": "On Structuring Proof Search for First Order Linear Logic", 
    "publish": "2003-12-01T14:33:06Z", 
    "summary": "Full first order linear logic can be presented as an abstract logic\nprogramming language in Miller's system Forum, which yields a sensible\noperational interpretation in the 'proof search as computation' paradigm.\nHowever, Forum still has to deal with syntactic details that would normally be\nignored by a reasonable operational semantics. In this respect, Forum improves\non Gentzen systems for linear logic by restricting the language and the form of\ninference rules. We further improve on Forum by restricting the class of\nformulae allowed, in a system we call G-Forum, which is still equivalent to\nfull first order linear logic. The only formulae allowed in G-Forum have the\nsame shape as Forum sequents: the restriction does not diminish expressiveness\nand makes G-Forum amenable to proof theoretic analysis. G-Forum consists of two\n(big) inference rules, for which we show a cut elimination procedure. This does\nnot need to appeal to finer detail in formulae and sequents than is provided by\nG-Forum, thus successfully testing the internal symmetries of our system."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312002v1", 
    "other_authors": [
        "Paola Bruscoli", 
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/0312002v1", 
    "title": "On Structuring Proof Search for First Order Linear Logic", 
    "publish": "2003-12-01T14:33:06Z", 
    "summary": "Full first order linear logic can be presented as an abstract logic\nprogramming language in Miller's system Forum, which yields a sensible\noperational interpretation in the 'proof search as computation' paradigm.\nHowever, Forum still has to deal with syntactic details that would normally be\nignored by a reasonable operational semantics. In this respect, Forum improves\non Gentzen systems for linear logic by restricting the language and the form of\ninference rules. We further improve on Forum by restricting the class of\nformulae allowed, in a system we call G-Forum, which is still equivalent to\nfull first order linear logic. The only formulae allowed in G-Forum have the\nsame shape as Forum sequents: the restriction does not diminish expressiveness\nand makes G-Forum amenable to proof theoretic analysis. G-Forum consists of two\n(big) inference rules, for which we show a cut elimination procedure. This does\nnot need to appeal to finer detail in formulae and sequents than is provided by\nG-Forum, thus successfully testing the internal symmetries of our system."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312002v1", 
    "other_authors": [
        "Paola Bruscoli", 
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/0312002v1", 
    "title": "On Structuring Proof Search for First Order Linear Logic", 
    "publish": "2003-12-01T14:33:06Z", 
    "summary": "Full first order linear logic can be presented as an abstract logic\nprogramming language in Miller's system Forum, which yields a sensible\noperational interpretation in the 'proof search as computation' paradigm.\nHowever, Forum still has to deal with syntactic details that would normally be\nignored by a reasonable operational semantics. In this respect, Forum improves\non Gentzen systems for linear logic by restricting the language and the form of\ninference rules. We further improve on Forum by restricting the class of\nformulae allowed, in a system we call G-Forum, which is still equivalent to\nfull first order linear logic. The only formulae allowed in G-Forum have the\nsame shape as Forum sequents: the restriction does not diminish expressiveness\nand makes G-Forum amenable to proof theoretic analysis. G-Forum consists of two\n(big) inference rules, for which we show a cut elimination procedure. This does\nnot need to appeal to finer detail in formulae and sequents than is provided by\nG-Forum, thus successfully testing the internal symmetries of our system."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312002v1", 
    "other_authors": [
        "Paola Bruscoli", 
        "Alessio Guglielmi"
    ], 
    "lead_author": "Alessio Guglielmi", 
    "arxiv-id": "cs/0312002v1", 
    "title": "On Structuring Proof Search for First Order Linear Logic", 
    "publish": "2003-12-01T14:33:06Z", 
    "summary": "Full first order linear logic can be presented as an abstract logic\nprogramming language in Miller's system Forum, which yields a sensible\noperational interpretation in the 'proof search as computation' paradigm.\nHowever, Forum still has to deal with syntactic details that would normally be\nignored by a reasonable operational semantics. In this respect, Forum improves\non Gentzen systems for linear logic by restricting the language and the form of\ninference rules. We further improve on Forum by restricting the class of\nformulae allowed, in a system we call G-Forum, which is still equivalent to\nfull first order linear logic. The only formulae allowed in G-Forum have the\nsame shape as Forum sequents: the restriction does not diminish expressiveness\nand makes G-Forum amenable to proof theoretic analysis. G-Forum consists of two\n(big) inference rules, for which we show a cut elimination procedure. This does\nnot need to appeal to finer detail in formulae and sequents than is provided by\nG-Forum, thus successfully testing the internal symmetries of our system."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312013v2", 
    "other_authors": [
        "F. Jurkovic"
    ], 
    "lead_author": "F. Jurkovic", 
    "arxiv-id": "cs/0312013v2", 
    "title": "Fuzziness versus probability again", 
    "publish": "2003-12-06T18:37:06Z", 
    "summary": "A construction of a fuzzy logic controller based on an analogy between fuzzy\nconditional rule of inference and marginal probability in terms of the\nconditional probability function has been proposed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312013v2", 
    "other_authors": [
        "F. Jurkovic"
    ], 
    "lead_author": "F. Jurkovic", 
    "arxiv-id": "cs/0312013v2", 
    "title": "Fuzziness versus probability again", 
    "publish": "2003-12-06T18:37:06Z", 
    "summary": "A construction of a fuzzy logic controller based on an analogy between fuzzy\nconditional rule of inference and marginal probability in terms of the\nconditional probability function has been proposed."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312014v3", 
    "other_authors": [
        "G. Yorsh", 
        "T. Reps", 
        "M. Sagiv", 
        "R. Wilhelm"
    ], 
    "lead_author": "G. Yorsh", 
    "arxiv-id": "cs/0312014v3", 
    "title": "Logical Characterizations of Heap Abstractions", 
    "publish": "2003-12-07T20:31:23Z", 
    "summary": "Shape analysis concerns the problem of determining \"shape invariants\" for\nprograms that perform destructive updating on dynamically allocated storage. In\nrecent work, we have shown how shape analysis can be performed, using an\nabstract interpretation based on 3-valued first-order logic. In that work,\nconcrete stores are finite 2-valued logical structures, and the sets of stores\nthat can possibly arise during execution are represented (conservatively) using\na certain family of finite 3-valued logical structures. In this paper, we show\nhow 3-valued structures that arise in shape analysis can be characterized using\nformulas in first-order logic with transitive closure.\n  We also define a non-standard (\"supervaluational\") semantics for 3-valued\nfirst-order logic that is more precise than a conventional 3-valued semantics,\nand demonstrate that the supervaluational semantics can be effectively\nimplemented using existing theorem provers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312014v3", 
    "other_authors": [
        "G. Yorsh", 
        "T. Reps", 
        "M. Sagiv", 
        "R. Wilhelm"
    ], 
    "lead_author": "G. Yorsh", 
    "arxiv-id": "cs/0312014v3", 
    "title": "Logical Characterizations of Heap Abstractions", 
    "publish": "2003-12-07T20:31:23Z", 
    "summary": "Shape analysis concerns the problem of determining \"shape invariants\" for\nprograms that perform destructive updating on dynamically allocated storage. In\nrecent work, we have shown how shape analysis can be performed, using an\nabstract interpretation based on 3-valued first-order logic. In that work,\nconcrete stores are finite 2-valued logical structures, and the sets of stores\nthat can possibly arise during execution are represented (conservatively) using\na certain family of finite 3-valued logical structures. In this paper, we show\nhow 3-valued structures that arise in shape analysis can be characterized using\nformulas in first-order logic with transitive closure.\n  We also define a non-standard (\"supervaluational\") semantics for 3-valued\nfirst-order logic that is more precise than a conventional 3-valued semantics,\nand demonstrate that the supervaluational semantics can be effectively\nimplemented using existing theorem provers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312014v3", 
    "other_authors": [
        "G. Yorsh", 
        "T. Reps", 
        "M. Sagiv", 
        "R. Wilhelm"
    ], 
    "lead_author": "G. Yorsh", 
    "arxiv-id": "cs/0312014v3", 
    "title": "Logical Characterizations of Heap Abstractions", 
    "publish": "2003-12-07T20:31:23Z", 
    "summary": "Shape analysis concerns the problem of determining \"shape invariants\" for\nprograms that perform destructive updating on dynamically allocated storage. In\nrecent work, we have shown how shape analysis can be performed, using an\nabstract interpretation based on 3-valued first-order logic. In that work,\nconcrete stores are finite 2-valued logical structures, and the sets of stores\nthat can possibly arise during execution are represented (conservatively) using\na certain family of finite 3-valued logical structures. In this paper, we show\nhow 3-valued structures that arise in shape analysis can be characterized using\nformulas in first-order logic with transitive closure.\n  We also define a non-standard (\"supervaluational\") semantics for 3-valued\nfirst-order logic that is more precise than a conventional 3-valued semantics,\nand demonstrate that the supervaluational semantics can be effectively\nimplemented using existing theorem provers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312014v3", 
    "other_authors": [
        "G. Yorsh", 
        "T. Reps", 
        "M. Sagiv", 
        "R. Wilhelm"
    ], 
    "lead_author": "T. Reps", 
    "arxiv-id": "cs/0312014v3", 
    "title": "Logical Characterizations of Heap Abstractions", 
    "publish": "2003-12-07T20:31:23Z", 
    "summary": "Shape analysis concerns the problem of determining \"shape invariants\" for\nprograms that perform destructive updating on dynamically allocated storage. In\nrecent work, we have shown how shape analysis can be performed, using an\nabstract interpretation based on 3-valued first-order logic. In that work,\nconcrete stores are finite 2-valued logical structures, and the sets of stores\nthat can possibly arise during execution are represented (conservatively) using\na certain family of finite 3-valued logical structures. In this paper, we show\nhow 3-valued structures that arise in shape analysis can be characterized using\nformulas in first-order logic with transitive closure.\n  We also define a non-standard (\"supervaluational\") semantics for 3-valued\nfirst-order logic that is more precise than a conventional 3-valued semantics,\nand demonstrate that the supervaluational semantics can be effectively\nimplemented using existing theorem provers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312014v3", 
    "other_authors": [
        "G. Yorsh", 
        "T. Reps", 
        "M. Sagiv", 
        "R. Wilhelm"
    ], 
    "lead_author": "T. Reps", 
    "arxiv-id": "cs/0312014v3", 
    "title": "Logical Characterizations of Heap Abstractions", 
    "publish": "2003-12-07T20:31:23Z", 
    "summary": "Shape analysis concerns the problem of determining \"shape invariants\" for\nprograms that perform destructive updating on dynamically allocated storage. In\nrecent work, we have shown how shape analysis can be performed, using an\nabstract interpretation based on 3-valued first-order logic. In that work,\nconcrete stores are finite 2-valued logical structures, and the sets of stores\nthat can possibly arise during execution are represented (conservatively) using\na certain family of finite 3-valued logical structures. In this paper, we show\nhow 3-valued structures that arise in shape analysis can be characterized using\nformulas in first-order logic with transitive closure.\n  We also define a non-standard (\"supervaluational\") semantics for 3-valued\nfirst-order logic that is more precise than a conventional 3-valued semantics,\nand demonstrate that the supervaluational semantics can be effectively\nimplemented using existing theorem provers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312014v3", 
    "other_authors": [
        "G. Yorsh", 
        "T. Reps", 
        "M. Sagiv", 
        "R. Wilhelm"
    ], 
    "lead_author": "M. Sagiv", 
    "arxiv-id": "cs/0312014v3", 
    "title": "Logical Characterizations of Heap Abstractions", 
    "publish": "2003-12-07T20:31:23Z", 
    "summary": "Shape analysis concerns the problem of determining \"shape invariants\" for\nprograms that perform destructive updating on dynamically allocated storage. In\nrecent work, we have shown how shape analysis can be performed, using an\nabstract interpretation based on 3-valued first-order logic. In that work,\nconcrete stores are finite 2-valued logical structures, and the sets of stores\nthat can possibly arise during execution are represented (conservatively) using\na certain family of finite 3-valued logical structures. In this paper, we show\nhow 3-valued structures that arise in shape analysis can be characterized using\nformulas in first-order logic with transitive closure.\n  We also define a non-standard (\"supervaluational\") semantics for 3-valued\nfirst-order logic that is more precise than a conventional 3-valued semantics,\nand demonstrate that the supervaluational semantics can be effectively\nimplemented using existing theorem provers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312014v3", 
    "other_authors": [
        "G. Yorsh", 
        "T. Reps", 
        "M. Sagiv", 
        "R. Wilhelm"
    ], 
    "lead_author": "M. Sagiv", 
    "arxiv-id": "cs/0312014v3", 
    "title": "Logical Characterizations of Heap Abstractions", 
    "publish": "2003-12-07T20:31:23Z", 
    "summary": "Shape analysis concerns the problem of determining \"shape invariants\" for\nprograms that perform destructive updating on dynamically allocated storage. In\nrecent work, we have shown how shape analysis can be performed, using an\nabstract interpretation based on 3-valued first-order logic. In that work,\nconcrete stores are finite 2-valued logical structures, and the sets of stores\nthat can possibly arise during execution are represented (conservatively) using\na certain family of finite 3-valued logical structures. In this paper, we show\nhow 3-valued structures that arise in shape analysis can be characterized using\nformulas in first-order logic with transitive closure.\n  We also define a non-standard (\"supervaluational\") semantics for 3-valued\nfirst-order logic that is more precise than a conventional 3-valued semantics,\nand demonstrate that the supervaluational semantics can be effectively\nimplemented using existing theorem provers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312014v3", 
    "other_authors": [
        "G. Yorsh", 
        "T. Reps", 
        "M. Sagiv", 
        "R. Wilhelm"
    ], 
    "lead_author": "M. Sagiv", 
    "arxiv-id": "cs/0312014v3", 
    "title": "Logical Characterizations of Heap Abstractions", 
    "publish": "2003-12-07T20:31:23Z", 
    "summary": "Shape analysis concerns the problem of determining \"shape invariants\" for\nprograms that perform destructive updating on dynamically allocated storage. In\nrecent work, we have shown how shape analysis can be performed, using an\nabstract interpretation based on 3-valued first-order logic. In that work,\nconcrete stores are finite 2-valued logical structures, and the sets of stores\nthat can possibly arise during execution are represented (conservatively) using\na certain family of finite 3-valued logical structures. In this paper, we show\nhow 3-valued structures that arise in shape analysis can be characterized using\nformulas in first-order logic with transitive closure.\n  We also define a non-standard (\"supervaluational\") semantics for 3-valued\nfirst-order logic that is more precise than a conventional 3-valued semantics,\nand demonstrate that the supervaluational semantics can be effectively\nimplemented using existing theorem provers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312014v3", 
    "other_authors": [
        "G. Yorsh", 
        "T. Reps", 
        "M. Sagiv", 
        "R. Wilhelm"
    ], 
    "lead_author": "M. Sagiv", 
    "arxiv-id": "cs/0312014v3", 
    "title": "Logical Characterizations of Heap Abstractions", 
    "publish": "2003-12-07T20:31:23Z", 
    "summary": "Shape analysis concerns the problem of determining \"shape invariants\" for\nprograms that perform destructive updating on dynamically allocated storage. In\nrecent work, we have shown how shape analysis can be performed, using an\nabstract interpretation based on 3-valued first-order logic. In that work,\nconcrete stores are finite 2-valued logical structures, and the sets of stores\nthat can possibly arise during execution are represented (conservatively) using\na certain family of finite 3-valued logical structures. In this paper, we show\nhow 3-valued structures that arise in shape analysis can be characterized using\nformulas in first-order logic with transitive closure.\n  We also define a non-standard (\"supervaluational\") semantics for 3-valued\nfirst-order logic that is more precise than a conventional 3-valued semantics,\nand demonstrate that the supervaluational semantics can be effectively\nimplemented using existing theorem provers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312014v3", 
    "other_authors": [
        "G. Yorsh", 
        "T. Reps", 
        "M. Sagiv", 
        "R. Wilhelm"
    ], 
    "lead_author": "M. Sagiv", 
    "arxiv-id": "cs/0312014v3", 
    "title": "Logical Characterizations of Heap Abstractions", 
    "publish": "2003-12-07T20:31:23Z", 
    "summary": "Shape analysis concerns the problem of determining \"shape invariants\" for\nprograms that perform destructive updating on dynamically allocated storage. In\nrecent work, we have shown how shape analysis can be performed, using an\nabstract interpretation based on 3-valued first-order logic. In that work,\nconcrete stores are finite 2-valued logical structures, and the sets of stores\nthat can possibly arise during execution are represented (conservatively) using\na certain family of finite 3-valued logical structures. In this paper, we show\nhow 3-valued structures that arise in shape analysis can be characterized using\nformulas in first-order logic with transitive closure.\n  We also define a non-standard (\"supervaluational\") semantics for 3-valued\nfirst-order logic that is more precise than a conventional 3-valued semantics,\nand demonstrate that the supervaluational semantics can be effectively\nimplemented using existing theorem provers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312014v3", 
    "other_authors": [
        "G. Yorsh", 
        "T. Reps", 
        "M. Sagiv", 
        "R. Wilhelm"
    ], 
    "lead_author": "M. Sagiv", 
    "arxiv-id": "cs/0312014v3", 
    "title": "Logical Characterizations of Heap Abstractions", 
    "publish": "2003-12-07T20:31:23Z", 
    "summary": "Shape analysis concerns the problem of determining \"shape invariants\" for\nprograms that perform destructive updating on dynamically allocated storage. In\nrecent work, we have shown how shape analysis can be performed, using an\nabstract interpretation based on 3-valued first-order logic. In that work,\nconcrete stores are finite 2-valued logical structures, and the sets of stores\nthat can possibly arise during execution are represented (conservatively) using\na certain family of finite 3-valued logical structures. In this paper, we show\nhow 3-valued structures that arise in shape analysis can be characterized using\nformulas in first-order logic with transitive closure.\n  We also define a non-standard (\"supervaluational\") semantics for 3-valued\nfirst-order logic that is more precise than a conventional 3-valued semantics,\nand demonstrate that the supervaluational semantics can be effectively\nimplemented using existing theorem provers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312014v3", 
    "other_authors": [
        "G. Yorsh", 
        "T. Reps", 
        "M. Sagiv", 
        "R. Wilhelm"
    ], 
    "lead_author": "R. Wilhelm", 
    "arxiv-id": "cs/0312014v3", 
    "title": "Logical Characterizations of Heap Abstractions", 
    "publish": "2003-12-07T20:31:23Z", 
    "summary": "Shape analysis concerns the problem of determining \"shape invariants\" for\nprograms that perform destructive updating on dynamically allocated storage. In\nrecent work, we have shown how shape analysis can be performed, using an\nabstract interpretation based on 3-valued first-order logic. In that work,\nconcrete stores are finite 2-valued logical structures, and the sets of stores\nthat can possibly arise during execution are represented (conservatively) using\na certain family of finite 3-valued logical structures. In this paper, we show\nhow 3-valued structures that arise in shape analysis can be characterized using\nformulas in first-order logic with transitive closure.\n  We also define a non-standard (\"supervaluational\") semantics for 3-valued\nfirst-order logic that is more precise than a conventional 3-valued semantics,\nand demonstrate that the supervaluational semantics can be effectively\nimplemented using existing theorem provers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312014v3", 
    "other_authors": [
        "G. Yorsh", 
        "T. Reps", 
        "M. Sagiv", 
        "R. Wilhelm"
    ], 
    "lead_author": "R. Wilhelm", 
    "arxiv-id": "cs/0312014v3", 
    "title": "Logical Characterizations of Heap Abstractions", 
    "publish": "2003-12-07T20:31:23Z", 
    "summary": "Shape analysis concerns the problem of determining \"shape invariants\" for\nprograms that perform destructive updating on dynamically allocated storage. In\nrecent work, we have shown how shape analysis can be performed, using an\nabstract interpretation based on 3-valued first-order logic. In that work,\nconcrete stores are finite 2-valued logical structures, and the sets of stores\nthat can possibly arise during execution are represented (conservatively) using\na certain family of finite 3-valued logical structures. In this paper, we show\nhow 3-valued structures that arise in shape analysis can be characterized using\nformulas in first-order logic with transitive closure.\n  We also define a non-standard (\"supervaluational\") semantics for 3-valued\nfirst-order logic that is more precise than a conventional 3-valued semantics,\nand demonstrate that the supervaluational semantics can be effectively\nimplemented using existing theorem provers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312014v3", 
    "other_authors": [
        "G. Yorsh", 
        "T. Reps", 
        "M. Sagiv", 
        "R. Wilhelm"
    ], 
    "lead_author": "R. Wilhelm", 
    "arxiv-id": "cs/0312014v3", 
    "title": "Logical Characterizations of Heap Abstractions", 
    "publish": "2003-12-07T20:31:23Z", 
    "summary": "Shape analysis concerns the problem of determining \"shape invariants\" for\nprograms that perform destructive updating on dynamically allocated storage. In\nrecent work, we have shown how shape analysis can be performed, using an\nabstract interpretation based on 3-valued first-order logic. In that work,\nconcrete stores are finite 2-valued logical structures, and the sets of stores\nthat can possibly arise during execution are represented (conservatively) using\na certain family of finite 3-valued logical structures. In this paper, we show\nhow 3-valued structures that arise in shape analysis can be characterized using\nformulas in first-order logic with transitive closure.\n  We also define a non-standard (\"supervaluational\") semantics for 3-valued\nfirst-order logic that is more precise than a conventional 3-valued semantics,\nand demonstrate that the supervaluational semantics can be effectively\nimplemented using existing theorem provers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312014v3", 
    "other_authors": [
        "G. Yorsh", 
        "T. Reps", 
        "M. Sagiv", 
        "R. Wilhelm"
    ], 
    "lead_author": "R. Wilhelm", 
    "arxiv-id": "cs/0312014v3", 
    "title": "Logical Characterizations of Heap Abstractions", 
    "publish": "2003-12-07T20:31:23Z", 
    "summary": "Shape analysis concerns the problem of determining \"shape invariants\" for\nprograms that perform destructive updating on dynamically allocated storage. In\nrecent work, we have shown how shape analysis can be performed, using an\nabstract interpretation based on 3-valued first-order logic. In that work,\nconcrete stores are finite 2-valued logical structures, and the sets of stores\nthat can possibly arise during execution are represented (conservatively) using\na certain family of finite 3-valued logical structures. In this paper, we show\nhow 3-valued structures that arise in shape analysis can be characterized using\nformulas in first-order logic with transitive closure.\n  We also define a non-standard (\"supervaluational\") semantics for 3-valued\nfirst-order logic that is more precise than a conventional 3-valued semantics,\nand demonstrate that the supervaluational semantics can be effectively\nimplemented using existing theorem provers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312014v3", 
    "other_authors": [
        "G. Yorsh", 
        "T. Reps", 
        "M. Sagiv", 
        "R. Wilhelm"
    ], 
    "lead_author": "R. Wilhelm", 
    "arxiv-id": "cs/0312014v3", 
    "title": "Logical Characterizations of Heap Abstractions", 
    "publish": "2003-12-07T20:31:23Z", 
    "summary": "Shape analysis concerns the problem of determining \"shape invariants\" for\nprograms that perform destructive updating on dynamically allocated storage. In\nrecent work, we have shown how shape analysis can be performed, using an\nabstract interpretation based on 3-valued first-order logic. In that work,\nconcrete stores are finite 2-valued logical structures, and the sets of stores\nthat can possibly arise during execution are represented (conservatively) using\na certain family of finite 3-valued logical structures. In this paper, we show\nhow 3-valued structures that arise in shape analysis can be characterized using\nformulas in first-order logic with transitive closure.\n  We also define a non-standard (\"supervaluational\") semantics for 3-valued\nfirst-order logic that is more precise than a conventional 3-valued semantics,\nand demonstrate that the supervaluational semantics can be effectively\nimplemented using existing theorem provers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312014v3", 
    "other_authors": [
        "G. Yorsh", 
        "T. Reps", 
        "M. Sagiv", 
        "R. Wilhelm"
    ], 
    "lead_author": "R. Wilhelm", 
    "arxiv-id": "cs/0312014v3", 
    "title": "Logical Characterizations of Heap Abstractions", 
    "publish": "2003-12-07T20:31:23Z", 
    "summary": "Shape analysis concerns the problem of determining \"shape invariants\" for\nprograms that perform destructive updating on dynamically allocated storage. In\nrecent work, we have shown how shape analysis can be performed, using an\nabstract interpretation based on 3-valued first-order logic. In that work,\nconcrete stores are finite 2-valued logical structures, and the sets of stores\nthat can possibly arise during execution are represented (conservatively) using\na certain family of finite 3-valued logical structures. In this paper, we show\nhow 3-valued structures that arise in shape analysis can be characterized using\nformulas in first-order logic with transitive closure.\n  We also define a non-standard (\"supervaluational\") semantics for 3-valued\nfirst-order logic that is more precise than a conventional 3-valued semantics,\nand demonstrate that the supervaluational semantics can be effectively\nimplemented using existing theorem provers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312014v3", 
    "other_authors": [
        "G. Yorsh", 
        "T. Reps", 
        "M. Sagiv", 
        "R. Wilhelm"
    ], 
    "lead_author": "R. Wilhelm", 
    "arxiv-id": "cs/0312014v3", 
    "title": "Logical Characterizations of Heap Abstractions", 
    "publish": "2003-12-07T20:31:23Z", 
    "summary": "Shape analysis concerns the problem of determining \"shape invariants\" for\nprograms that perform destructive updating on dynamically allocated storage. In\nrecent work, we have shown how shape analysis can be performed, using an\nabstract interpretation based on 3-valued first-order logic. In that work,\nconcrete stores are finite 2-valued logical structures, and the sets of stores\nthat can possibly arise during execution are represented (conservatively) using\na certain family of finite 3-valued logical structures. In this paper, we show\nhow 3-valued structures that arise in shape analysis can be characterized using\nformulas in first-order logic with transitive closure.\n  We also define a non-standard (\"supervaluational\") semantics for 3-valued\nfirst-order logic that is more precise than a conventional 3-valued semantics,\nand demonstrate that the supervaluational semantics can be effectively\nimplemented using existing theorem provers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312014v3", 
    "other_authors": [
        "G. Yorsh", 
        "T. Reps", 
        "M. Sagiv", 
        "R. Wilhelm"
    ], 
    "lead_author": "R. Wilhelm", 
    "arxiv-id": "cs/0312014v3", 
    "title": "Logical Characterizations of Heap Abstractions", 
    "publish": "2003-12-07T20:31:23Z", 
    "summary": "Shape analysis concerns the problem of determining \"shape invariants\" for\nprograms that perform destructive updating on dynamically allocated storage. In\nrecent work, we have shown how shape analysis can be performed, using an\nabstract interpretation based on 3-valued first-order logic. In that work,\nconcrete stores are finite 2-valued logical structures, and the sets of stores\nthat can possibly arise during execution are represented (conservatively) using\na certain family of finite 3-valued logical structures. In this paper, we show\nhow 3-valued structures that arise in shape analysis can be characterized using\nformulas in first-order logic with transitive closure.\n  We also define a non-standard (\"supervaluational\") semantics for 3-valued\nfirst-order logic that is more precise than a conventional 3-valued semantics,\nand demonstrate that the supervaluational semantics can be effectively\nimplemented using existing theorem provers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312014v3", 
    "other_authors": [
        "G. Yorsh", 
        "T. Reps", 
        "M. Sagiv", 
        "R. Wilhelm"
    ], 
    "lead_author": "R. Wilhelm", 
    "arxiv-id": "cs/0312014v3", 
    "title": "Logical Characterizations of Heap Abstractions", 
    "publish": "2003-12-07T20:31:23Z", 
    "summary": "Shape analysis concerns the problem of determining \"shape invariants\" for\nprograms that perform destructive updating on dynamically allocated storage. In\nrecent work, we have shown how shape analysis can be performed, using an\nabstract interpretation based on 3-valued first-order logic. In that work,\nconcrete stores are finite 2-valued logical structures, and the sets of stores\nthat can possibly arise during execution are represented (conservatively) using\na certain family of finite 3-valued logical structures. In this paper, we show\nhow 3-valued structures that arise in shape analysis can be characterized using\nformulas in first-order logic with transitive closure.\n  We also define a non-standard (\"supervaluational\") semantics for 3-valued\nfirst-order logic that is more precise than a conventional 3-valued semantics,\nand demonstrate that the supervaluational semantics can be effectively\nimplemented using existing theorem provers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312014v3", 
    "other_authors": [
        "G. Yorsh", 
        "T. Reps", 
        "M. Sagiv", 
        "R. Wilhelm"
    ], 
    "lead_author": "R. Wilhelm", 
    "arxiv-id": "cs/0312014v3", 
    "title": "Logical Characterizations of Heap Abstractions", 
    "publish": "2003-12-07T20:31:23Z", 
    "summary": "Shape analysis concerns the problem of determining \"shape invariants\" for\nprograms that perform destructive updating on dynamically allocated storage. In\nrecent work, we have shown how shape analysis can be performed, using an\nabstract interpretation based on 3-valued first-order logic. In that work,\nconcrete stores are finite 2-valued logical structures, and the sets of stores\nthat can possibly arise during execution are represented (conservatively) using\na certain family of finite 3-valued logical structures. In this paper, we show\nhow 3-valued structures that arise in shape analysis can be characterized using\nformulas in first-order logic with transitive closure.\n  We also define a non-standard (\"supervaluational\") semantics for 3-valued\nfirst-order logic that is more precise than a conventional 3-valued semantics,\nand demonstrate that the supervaluational semantics can be effectively\nimplemented using existing theorem provers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312014v3", 
    "other_authors": [
        "G. Yorsh", 
        "T. Reps", 
        "M. Sagiv", 
        "R. Wilhelm"
    ], 
    "lead_author": "R. Wilhelm", 
    "arxiv-id": "cs/0312014v3", 
    "title": "Logical Characterizations of Heap Abstractions", 
    "publish": "2003-12-07T20:31:23Z", 
    "summary": "Shape analysis concerns the problem of determining \"shape invariants\" for\nprograms that perform destructive updating on dynamically allocated storage. In\nrecent work, we have shown how shape analysis can be performed, using an\nabstract interpretation based on 3-valued first-order logic. In that work,\nconcrete stores are finite 2-valued logical structures, and the sets of stores\nthat can possibly arise during execution are represented (conservatively) using\na certain family of finite 3-valued logical structures. In this paper, we show\nhow 3-valued structures that arise in shape analysis can be characterized using\nformulas in first-order logic with transitive closure.\n  We also define a non-standard (\"supervaluational\") semantics for 3-valued\nfirst-order logic that is more precise than a conventional 3-valued semantics,\nand demonstrate that the supervaluational semantics can be effectively\nimplemented using existing theorem provers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312014v3", 
    "other_authors": [
        "G. Yorsh", 
        "T. Reps", 
        "M. Sagiv", 
        "R. Wilhelm"
    ], 
    "lead_author": "R. Wilhelm", 
    "arxiv-id": "cs/0312014v3", 
    "title": "Logical Characterizations of Heap Abstractions", 
    "publish": "2003-12-07T20:31:23Z", 
    "summary": "Shape analysis concerns the problem of determining \"shape invariants\" for\nprograms that perform destructive updating on dynamically allocated storage. In\nrecent work, we have shown how shape analysis can be performed, using an\nabstract interpretation based on 3-valued first-order logic. In that work,\nconcrete stores are finite 2-valued logical structures, and the sets of stores\nthat can possibly arise during execution are represented (conservatively) using\na certain family of finite 3-valued logical structures. In this paper, we show\nhow 3-valued structures that arise in shape analysis can be characterized using\nformulas in first-order logic with transitive closure.\n  We also define a non-standard (\"supervaluational\") semantics for 3-valued\nfirst-order logic that is more precise than a conventional 3-valued semantics,\nand demonstrate that the supervaluational semantics can be effectively\nimplemented using existing theorem provers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312014v3", 
    "other_authors": [
        "G. Yorsh", 
        "T. Reps", 
        "M. Sagiv", 
        "R. Wilhelm"
    ], 
    "lead_author": "R. Wilhelm", 
    "arxiv-id": "cs/0312014v3", 
    "title": "Logical Characterizations of Heap Abstractions", 
    "publish": "2003-12-07T20:31:23Z", 
    "summary": "Shape analysis concerns the problem of determining \"shape invariants\" for\nprograms that perform destructive updating on dynamically allocated storage. In\nrecent work, we have shown how shape analysis can be performed, using an\nabstract interpretation based on 3-valued first-order logic. In that work,\nconcrete stores are finite 2-valued logical structures, and the sets of stores\nthat can possibly arise during execution are represented (conservatively) using\na certain family of finite 3-valued logical structures. In this paper, we show\nhow 3-valued structures that arise in shape analysis can be characterized using\nformulas in first-order logic with transitive closure.\n  We also define a non-standard (\"supervaluational\") semantics for 3-valued\nfirst-order logic that is more precise than a conventional 3-valued semantics,\nand demonstrate that the supervaluational semantics can be effectively\nimplemented using existing theorem provers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312014v3", 
    "other_authors": [
        "G. Yorsh", 
        "T. Reps", 
        "M. Sagiv", 
        "R. Wilhelm"
    ], 
    "lead_author": "R. Wilhelm", 
    "arxiv-id": "cs/0312014v3", 
    "title": "Logical Characterizations of Heap Abstractions", 
    "publish": "2003-12-07T20:31:23Z", 
    "summary": "Shape analysis concerns the problem of determining \"shape invariants\" for\nprograms that perform destructive updating on dynamically allocated storage. In\nrecent work, we have shown how shape analysis can be performed, using an\nabstract interpretation based on 3-valued first-order logic. In that work,\nconcrete stores are finite 2-valued logical structures, and the sets of stores\nthat can possibly arise during execution are represented (conservatively) using\na certain family of finite 3-valued logical structures. In this paper, we show\nhow 3-valued structures that arise in shape analysis can be characterized using\nformulas in first-order logic with transitive closure.\n  We also define a non-standard (\"supervaluational\") semantics for 3-valued\nfirst-order logic that is more precise than a conventional 3-valued semantics,\nand demonstrate that the supervaluational semantics can be effectively\nimplemented using existing theorem provers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312014v3", 
    "other_authors": [
        "G. Yorsh", 
        "T. Reps", 
        "M. Sagiv", 
        "R. Wilhelm"
    ], 
    "lead_author": "R. Wilhelm", 
    "arxiv-id": "cs/0312014v3", 
    "title": "Logical Characterizations of Heap Abstractions", 
    "publish": "2003-12-07T20:31:23Z", 
    "summary": "Shape analysis concerns the problem of determining \"shape invariants\" for\nprograms that perform destructive updating on dynamically allocated storage. In\nrecent work, we have shown how shape analysis can be performed, using an\nabstract interpretation based on 3-valued first-order logic. In that work,\nconcrete stores are finite 2-valued logical structures, and the sets of stores\nthat can possibly arise during execution are represented (conservatively) using\na certain family of finite 3-valued logical structures. In this paper, we show\nhow 3-valued structures that arise in shape analysis can be characterized using\nformulas in first-order logic with transitive closure.\n  We also define a non-standard (\"supervaluational\") semantics for 3-valued\nfirst-order logic that is more precise than a conventional 3-valued semantics,\nand demonstrate that the supervaluational semantics can be effectively\nimplemented using existing theorem provers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312014v3", 
    "other_authors": [
        "G. Yorsh", 
        "T. Reps", 
        "M. Sagiv", 
        "R. Wilhelm"
    ], 
    "lead_author": "R. Wilhelm", 
    "arxiv-id": "cs/0312014v3", 
    "title": "Logical Characterizations of Heap Abstractions", 
    "publish": "2003-12-07T20:31:23Z", 
    "summary": "Shape analysis concerns the problem of determining \"shape invariants\" for\nprograms that perform destructive updating on dynamically allocated storage. In\nrecent work, we have shown how shape analysis can be performed, using an\nabstract interpretation based on 3-valued first-order logic. In that work,\nconcrete stores are finite 2-valued logical structures, and the sets of stores\nthat can possibly arise during execution are represented (conservatively) using\na certain family of finite 3-valued logical structures. In this paper, we show\nhow 3-valued structures that arise in shape analysis can be characterized using\nformulas in first-order logic with transitive closure.\n  We also define a non-standard (\"supervaluational\") semantics for 3-valued\nfirst-order logic that is more precise than a conventional 3-valued semantics,\nand demonstrate that the supervaluational semantics can be effectively\nimplemented using existing theorem provers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312014v3", 
    "other_authors": [
        "G. Yorsh", 
        "T. Reps", 
        "M. Sagiv", 
        "R. Wilhelm"
    ], 
    "lead_author": "R. Wilhelm", 
    "arxiv-id": "cs/0312014v3", 
    "title": "Logical Characterizations of Heap Abstractions", 
    "publish": "2003-12-07T20:31:23Z", 
    "summary": "Shape analysis concerns the problem of determining \"shape invariants\" for\nprograms that perform destructive updating on dynamically allocated storage. In\nrecent work, we have shown how shape analysis can be performed, using an\nabstract interpretation based on 3-valued first-order logic. In that work,\nconcrete stores are finite 2-valued logical structures, and the sets of stores\nthat can possibly arise during execution are represented (conservatively) using\na certain family of finite 3-valued logical structures. In this paper, we show\nhow 3-valued structures that arise in shape analysis can be characterized using\nformulas in first-order logic with transitive closure.\n  We also define a non-standard (\"supervaluational\") semantics for 3-valued\nfirst-order logic that is more precise than a conventional 3-valued semantics,\nand demonstrate that the supervaluational semantics can be effectively\nimplemented using existing theorem provers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312014v3", 
    "other_authors": [
        "G. Yorsh", 
        "T. Reps", 
        "M. Sagiv", 
        "R. Wilhelm"
    ], 
    "lead_author": "R. Wilhelm", 
    "arxiv-id": "cs/0312014v3", 
    "title": "Logical Characterizations of Heap Abstractions", 
    "publish": "2003-12-07T20:31:23Z", 
    "summary": "Shape analysis concerns the problem of determining \"shape invariants\" for\nprograms that perform destructive updating on dynamically allocated storage. In\nrecent work, we have shown how shape analysis can be performed, using an\nabstract interpretation based on 3-valued first-order logic. In that work,\nconcrete stores are finite 2-valued logical structures, and the sets of stores\nthat can possibly arise during execution are represented (conservatively) using\na certain family of finite 3-valued logical structures. In this paper, we show\nhow 3-valued structures that arise in shape analysis can be characterized using\nformulas in first-order logic with transitive closure.\n  We also define a non-standard (\"supervaluational\") semantics for 3-valued\nfirst-order logic that is more precise than a conventional 3-valued semantics,\nand demonstrate that the supervaluational semantics can be effectively\nimplemented using existing theorem provers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312014v3", 
    "other_authors": [
        "G. Yorsh", 
        "T. Reps", 
        "M. Sagiv", 
        "R. Wilhelm"
    ], 
    "lead_author": "R. Wilhelm", 
    "arxiv-id": "cs/0312014v3", 
    "title": "Logical Characterizations of Heap Abstractions", 
    "publish": "2003-12-07T20:31:23Z", 
    "summary": "Shape analysis concerns the problem of determining \"shape invariants\" for\nprograms that perform destructive updating on dynamically allocated storage. In\nrecent work, we have shown how shape analysis can be performed, using an\nabstract interpretation based on 3-valued first-order logic. In that work,\nconcrete stores are finite 2-valued logical structures, and the sets of stores\nthat can possibly arise during execution are represented (conservatively) using\na certain family of finite 3-valued logical structures. In this paper, we show\nhow 3-valued structures that arise in shape analysis can be characterized using\nformulas in first-order logic with transitive closure.\n  We also define a non-standard (\"supervaluational\") semantics for 3-valued\nfirst-order logic that is more precise than a conventional 3-valued semantics,\nand demonstrate that the supervaluational semantics can be effectively\nimplemented using existing theorem provers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312014v3", 
    "other_authors": [
        "G. Yorsh", 
        "T. Reps", 
        "M. Sagiv", 
        "R. Wilhelm"
    ], 
    "lead_author": "R. Wilhelm", 
    "arxiv-id": "cs/0312014v3", 
    "title": "Logical Characterizations of Heap Abstractions", 
    "publish": "2003-12-07T20:31:23Z", 
    "summary": "Shape analysis concerns the problem of determining \"shape invariants\" for\nprograms that perform destructive updating on dynamically allocated storage. In\nrecent work, we have shown how shape analysis can be performed, using an\nabstract interpretation based on 3-valued first-order logic. In that work,\nconcrete stores are finite 2-valued logical structures, and the sets of stores\nthat can possibly arise during execution are represented (conservatively) using\na certain family of finite 3-valued logical structures. In this paper, we show\nhow 3-valued structures that arise in shape analysis can be characterized using\nformulas in first-order logic with transitive closure.\n  We also define a non-standard (\"supervaluational\") semantics for 3-valued\nfirst-order logic that is more precise than a conventional 3-valued semantics,\nand demonstrate that the supervaluational semantics can be effectively\nimplemented using existing theorem provers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312014v3", 
    "other_authors": [
        "G. Yorsh", 
        "T. Reps", 
        "M. Sagiv", 
        "R. Wilhelm"
    ], 
    "lead_author": "R. Wilhelm", 
    "arxiv-id": "cs/0312014v3", 
    "title": "Logical Characterizations of Heap Abstractions", 
    "publish": "2003-12-07T20:31:23Z", 
    "summary": "Shape analysis concerns the problem of determining \"shape invariants\" for\nprograms that perform destructive updating on dynamically allocated storage. In\nrecent work, we have shown how shape analysis can be performed, using an\nabstract interpretation based on 3-valued first-order logic. In that work,\nconcrete stores are finite 2-valued logical structures, and the sets of stores\nthat can possibly arise during execution are represented (conservatively) using\na certain family of finite 3-valued logical structures. In this paper, we show\nhow 3-valued structures that arise in shape analysis can be characterized using\nformulas in first-order logic with transitive closure.\n  We also define a non-standard (\"supervaluational\") semantics for 3-valued\nfirst-order logic that is more precise than a conventional 3-valued semantics,\nand demonstrate that the supervaluational semantics can be effectively\nimplemented using existing theorem provers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312014v3", 
    "other_authors": [
        "G. Yorsh", 
        "T. Reps", 
        "M. Sagiv", 
        "R. Wilhelm"
    ], 
    "lead_author": "R. Wilhelm", 
    "arxiv-id": "cs/0312014v3", 
    "title": "Logical Characterizations of Heap Abstractions", 
    "publish": "2003-12-07T20:31:23Z", 
    "summary": "Shape analysis concerns the problem of determining \"shape invariants\" for\nprograms that perform destructive updating on dynamically allocated storage. In\nrecent work, we have shown how shape analysis can be performed, using an\nabstract interpretation based on 3-valued first-order logic. In that work,\nconcrete stores are finite 2-valued logical structures, and the sets of stores\nthat can possibly arise during execution are represented (conservatively) using\na certain family of finite 3-valued logical structures. In this paper, we show\nhow 3-valued structures that arise in shape analysis can be characterized using\nformulas in first-order logic with transitive closure.\n  We also define a non-standard (\"supervaluational\") semantics for 3-valued\nfirst-order logic that is more precise than a conventional 3-valued semantics,\nand demonstrate that the supervaluational semantics can be effectively\nimplemented using existing theorem provers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312014v3", 
    "other_authors": [
        "G. Yorsh", 
        "T. Reps", 
        "M. Sagiv", 
        "R. Wilhelm"
    ], 
    "lead_author": "R. Wilhelm", 
    "arxiv-id": "cs/0312014v3", 
    "title": "Logical Characterizations of Heap Abstractions", 
    "publish": "2003-12-07T20:31:23Z", 
    "summary": "Shape analysis concerns the problem of determining \"shape invariants\" for\nprograms that perform destructive updating on dynamically allocated storage. In\nrecent work, we have shown how shape analysis can be performed, using an\nabstract interpretation based on 3-valued first-order logic. In that work,\nconcrete stores are finite 2-valued logical structures, and the sets of stores\nthat can possibly arise during execution are represented (conservatively) using\na certain family of finite 3-valued logical structures. In this paper, we show\nhow 3-valued structures that arise in shape analysis can be characterized using\nformulas in first-order logic with transitive closure.\n  We also define a non-standard (\"supervaluational\") semantics for 3-valued\nfirst-order logic that is more precise than a conventional 3-valued semantics,\nand demonstrate that the supervaluational semantics can be effectively\nimplemented using existing theorem provers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312014v3", 
    "other_authors": [
        "G. Yorsh", 
        "T. Reps", 
        "M. Sagiv", 
        "R. Wilhelm"
    ], 
    "lead_author": "R. Wilhelm", 
    "arxiv-id": "cs/0312014v3", 
    "title": "Logical Characterizations of Heap Abstractions", 
    "publish": "2003-12-07T20:31:23Z", 
    "summary": "Shape analysis concerns the problem of determining \"shape invariants\" for\nprograms that perform destructive updating on dynamically allocated storage. In\nrecent work, we have shown how shape analysis can be performed, using an\nabstract interpretation based on 3-valued first-order logic. In that work,\nconcrete stores are finite 2-valued logical structures, and the sets of stores\nthat can possibly arise during execution are represented (conservatively) using\na certain family of finite 3-valued logical structures. In this paper, we show\nhow 3-valued structures that arise in shape analysis can be characterized using\nformulas in first-order logic with transitive closure.\n  We also define a non-standard (\"supervaluational\") semantics for 3-valued\nfirst-order logic that is more precise than a conventional 3-valued semantics,\nand demonstrate that the supervaluational semantics can be effectively\nimplemented using existing theorem provers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312014v3", 
    "other_authors": [
        "G. Yorsh", 
        "T. Reps", 
        "M. Sagiv", 
        "R. Wilhelm"
    ], 
    "lead_author": "R. Wilhelm", 
    "arxiv-id": "cs/0312014v3", 
    "title": "Logical Characterizations of Heap Abstractions", 
    "publish": "2003-12-07T20:31:23Z", 
    "summary": "Shape analysis concerns the problem of determining \"shape invariants\" for\nprograms that perform destructive updating on dynamically allocated storage. In\nrecent work, we have shown how shape analysis can be performed, using an\nabstract interpretation based on 3-valued first-order logic. In that work,\nconcrete stores are finite 2-valued logical structures, and the sets of stores\nthat can possibly arise during execution are represented (conservatively) using\na certain family of finite 3-valued logical structures. In this paper, we show\nhow 3-valued structures that arise in shape analysis can be characterized using\nformulas in first-order logic with transitive closure.\n  We also define a non-standard (\"supervaluational\") semantics for 3-valued\nfirst-order logic that is more precise than a conventional 3-valued semantics,\nand demonstrate that the supervaluational semantics can be effectively\nimplemented using existing theorem provers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312014v3", 
    "other_authors": [
        "G. Yorsh", 
        "T. Reps", 
        "M. Sagiv", 
        "R. Wilhelm"
    ], 
    "lead_author": "R. Wilhelm", 
    "arxiv-id": "cs/0312014v3", 
    "title": "Logical Characterizations of Heap Abstractions", 
    "publish": "2003-12-07T20:31:23Z", 
    "summary": "Shape analysis concerns the problem of determining \"shape invariants\" for\nprograms that perform destructive updating on dynamically allocated storage. In\nrecent work, we have shown how shape analysis can be performed, using an\nabstract interpretation based on 3-valued first-order logic. In that work,\nconcrete stores are finite 2-valued logical structures, and the sets of stores\nthat can possibly arise during execution are represented (conservatively) using\na certain family of finite 3-valued logical structures. In this paper, we show\nhow 3-valued structures that arise in shape analysis can be characterized using\nformulas in first-order logic with transitive closure.\n  We also define a non-standard (\"supervaluational\") semantics for 3-valued\nfirst-order logic that is more precise than a conventional 3-valued semantics,\nand demonstrate that the supervaluational semantics can be effectively\nimplemented using existing theorem provers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312014v3", 
    "other_authors": [
        "G. Yorsh", 
        "T. Reps", 
        "M. Sagiv", 
        "R. Wilhelm"
    ], 
    "lead_author": "R. Wilhelm", 
    "arxiv-id": "cs/0312014v3", 
    "title": "Logical Characterizations of Heap Abstractions", 
    "publish": "2003-12-07T20:31:23Z", 
    "summary": "Shape analysis concerns the problem of determining \"shape invariants\" for\nprograms that perform destructive updating on dynamically allocated storage. In\nrecent work, we have shown how shape analysis can be performed, using an\nabstract interpretation based on 3-valued first-order logic. In that work,\nconcrete stores are finite 2-valued logical structures, and the sets of stores\nthat can possibly arise during execution are represented (conservatively) using\na certain family of finite 3-valued logical structures. In this paper, we show\nhow 3-valued structures that arise in shape analysis can be characterized using\nformulas in first-order logic with transitive closure.\n  We also define a non-standard (\"supervaluational\") semantics for 3-valued\nfirst-order logic that is more precise than a conventional 3-valued semantics,\nand demonstrate that the supervaluational semantics can be effectively\nimplemented using existing theorem provers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312014v3", 
    "other_authors": [
        "G. Yorsh", 
        "T. Reps", 
        "M. Sagiv", 
        "R. Wilhelm"
    ], 
    "lead_author": "R. Wilhelm", 
    "arxiv-id": "cs/0312014v3", 
    "title": "Logical Characterizations of Heap Abstractions", 
    "publish": "2003-12-07T20:31:23Z", 
    "summary": "Shape analysis concerns the problem of determining \"shape invariants\" for\nprograms that perform destructive updating on dynamically allocated storage. In\nrecent work, we have shown how shape analysis can be performed, using an\nabstract interpretation based on 3-valued first-order logic. In that work,\nconcrete stores are finite 2-valued logical structures, and the sets of stores\nthat can possibly arise during execution are represented (conservatively) using\na certain family of finite 3-valued logical structures. In this paper, we show\nhow 3-valued structures that arise in shape analysis can be characterized using\nformulas in first-order logic with transitive closure.\n  We also define a non-standard (\"supervaluational\") semantics for 3-valued\nfirst-order logic that is more precise than a conventional 3-valued semantics,\nand demonstrate that the supervaluational semantics can be effectively\nimplemented using existing theorem provers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312014v3", 
    "other_authors": [
        "G. Yorsh", 
        "T. Reps", 
        "M. Sagiv", 
        "R. Wilhelm"
    ], 
    "lead_author": "R. Wilhelm", 
    "arxiv-id": "cs/0312014v3", 
    "title": "Logical Characterizations of Heap Abstractions", 
    "publish": "2003-12-07T20:31:23Z", 
    "summary": "Shape analysis concerns the problem of determining \"shape invariants\" for\nprograms that perform destructive updating on dynamically allocated storage. In\nrecent work, we have shown how shape analysis can be performed, using an\nabstract interpretation based on 3-valued first-order logic. In that work,\nconcrete stores are finite 2-valued logical structures, and the sets of stores\nthat can possibly arise during execution are represented (conservatively) using\na certain family of finite 3-valued logical structures. In this paper, we show\nhow 3-valued structures that arise in shape analysis can be characterized using\nformulas in first-order logic with transitive closure.\n  We also define a non-standard (\"supervaluational\") semantics for 3-valued\nfirst-order logic that is more precise than a conventional 3-valued semantics,\nand demonstrate that the supervaluational semantics can be effectively\nimplemented using existing theorem provers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312014v3", 
    "other_authors": [
        "G. Yorsh", 
        "T. Reps", 
        "M. Sagiv", 
        "R. Wilhelm"
    ], 
    "lead_author": "R. Wilhelm", 
    "arxiv-id": "cs/0312014v3", 
    "title": "Logical Characterizations of Heap Abstractions", 
    "publish": "2003-12-07T20:31:23Z", 
    "summary": "Shape analysis concerns the problem of determining \"shape invariants\" for\nprograms that perform destructive updating on dynamically allocated storage. In\nrecent work, we have shown how shape analysis can be performed, using an\nabstract interpretation based on 3-valued first-order logic. In that work,\nconcrete stores are finite 2-valued logical structures, and the sets of stores\nthat can possibly arise during execution are represented (conservatively) using\na certain family of finite 3-valued logical structures. In this paper, we show\nhow 3-valued structures that arise in shape analysis can be characterized using\nformulas in first-order logic with transitive closure.\n  We also define a non-standard (\"supervaluational\") semantics for 3-valued\nfirst-order logic that is more precise than a conventional 3-valued semantics,\nand demonstrate that the supervaluational semantics can be effectively\nimplemented using existing theorem provers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312014v3", 
    "other_authors": [
        "G. Yorsh", 
        "T. Reps", 
        "M. Sagiv", 
        "R. Wilhelm"
    ], 
    "lead_author": "R. Wilhelm", 
    "arxiv-id": "cs/0312014v3", 
    "title": "Logical Characterizations of Heap Abstractions", 
    "publish": "2003-12-07T20:31:23Z", 
    "summary": "Shape analysis concerns the problem of determining \"shape invariants\" for\nprograms that perform destructive updating on dynamically allocated storage. In\nrecent work, we have shown how shape analysis can be performed, using an\nabstract interpretation based on 3-valued first-order logic. In that work,\nconcrete stores are finite 2-valued logical structures, and the sets of stores\nthat can possibly arise during execution are represented (conservatively) using\na certain family of finite 3-valued logical structures. In this paper, we show\nhow 3-valued structures that arise in shape analysis can be characterized using\nformulas in first-order logic with transitive closure.\n  We also define a non-standard (\"supervaluational\") semantics for 3-valued\nfirst-order logic that is more precise than a conventional 3-valued semantics,\nand demonstrate that the supervaluational semantics can be effectively\nimplemented using existing theorem provers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312014v3", 
    "other_authors": [
        "G. Yorsh", 
        "T. Reps", 
        "M. Sagiv", 
        "R. Wilhelm"
    ], 
    "lead_author": "R. Wilhelm", 
    "arxiv-id": "cs/0312014v3", 
    "title": "Logical Characterizations of Heap Abstractions", 
    "publish": "2003-12-07T20:31:23Z", 
    "summary": "Shape analysis concerns the problem of determining \"shape invariants\" for\nprograms that perform destructive updating on dynamically allocated storage. In\nrecent work, we have shown how shape analysis can be performed, using an\nabstract interpretation based on 3-valued first-order logic. In that work,\nconcrete stores are finite 2-valued logical structures, and the sets of stores\nthat can possibly arise during execution are represented (conservatively) using\na certain family of finite 3-valued logical structures. In this paper, we show\nhow 3-valued structures that arise in shape analysis can be characterized using\nformulas in first-order logic with transitive closure.\n  We also define a non-standard (\"supervaluational\") semantics for 3-valued\nfirst-order logic that is more precise than a conventional 3-valued semantics,\nand demonstrate that the supervaluational semantics can be effectively\nimplemented using existing theorem provers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312014v3", 
    "other_authors": [
        "G. Yorsh", 
        "T. Reps", 
        "M. Sagiv", 
        "R. Wilhelm"
    ], 
    "lead_author": "R. Wilhelm", 
    "arxiv-id": "cs/0312014v3", 
    "title": "Logical Characterizations of Heap Abstractions", 
    "publish": "2003-12-07T20:31:23Z", 
    "summary": "Shape analysis concerns the problem of determining \"shape invariants\" for\nprograms that perform destructive updating on dynamically allocated storage. In\nrecent work, we have shown how shape analysis can be performed, using an\nabstract interpretation based on 3-valued first-order logic. In that work,\nconcrete stores are finite 2-valued logical structures, and the sets of stores\nthat can possibly arise during execution are represented (conservatively) using\na certain family of finite 3-valued logical structures. In this paper, we show\nhow 3-valued structures that arise in shape analysis can be characterized using\nformulas in first-order logic with transitive closure.\n  We also define a non-standard (\"supervaluational\") semantics for 3-valued\nfirst-order logic that is more precise than a conventional 3-valued semantics,\nand demonstrate that the supervaluational semantics can be effectively\nimplemented using existing theorem provers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312014v3", 
    "other_authors": [
        "G. Yorsh", 
        "T. Reps", 
        "M. Sagiv", 
        "R. Wilhelm"
    ], 
    "lead_author": "R. Wilhelm", 
    "arxiv-id": "cs/0312014v3", 
    "title": "Logical Characterizations of Heap Abstractions", 
    "publish": "2003-12-07T20:31:23Z", 
    "summary": "Shape analysis concerns the problem of determining \"shape invariants\" for\nprograms that perform destructive updating on dynamically allocated storage. In\nrecent work, we have shown how shape analysis can be performed, using an\nabstract interpretation based on 3-valued first-order logic. In that work,\nconcrete stores are finite 2-valued logical structures, and the sets of stores\nthat can possibly arise during execution are represented (conservatively) using\na certain family of finite 3-valued logical structures. In this paper, we show\nhow 3-valued structures that arise in shape analysis can be characterized using\nformulas in first-order logic with transitive closure.\n  We also define a non-standard (\"supervaluational\") semantics for 3-valued\nfirst-order logic that is more precise than a conventional 3-valued semantics,\nand demonstrate that the supervaluational semantics can be effectively\nimplemented using existing theorem provers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312014v3", 
    "other_authors": [
        "G. Yorsh", 
        "T. Reps", 
        "M. Sagiv", 
        "R. Wilhelm"
    ], 
    "lead_author": "R. Wilhelm", 
    "arxiv-id": "cs/0312014v3", 
    "title": "Logical Characterizations of Heap Abstractions", 
    "publish": "2003-12-07T20:31:23Z", 
    "summary": "Shape analysis concerns the problem of determining \"shape invariants\" for\nprograms that perform destructive updating on dynamically allocated storage. In\nrecent work, we have shown how shape analysis can be performed, using an\nabstract interpretation based on 3-valued first-order logic. In that work,\nconcrete stores are finite 2-valued logical structures, and the sets of stores\nthat can possibly arise during execution are represented (conservatively) using\na certain family of finite 3-valued logical structures. In this paper, we show\nhow 3-valued structures that arise in shape analysis can be characterized using\nformulas in first-order logic with transitive closure.\n  We also define a non-standard (\"supervaluational\") semantics for 3-valued\nfirst-order logic that is more precise than a conventional 3-valued semantics,\nand demonstrate that the supervaluational semantics can be effectively\nimplemented using existing theorem provers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312014v3", 
    "other_authors": [
        "G. Yorsh", 
        "T. Reps", 
        "M. Sagiv", 
        "R. Wilhelm"
    ], 
    "lead_author": "R. Wilhelm", 
    "arxiv-id": "cs/0312014v3", 
    "title": "Logical Characterizations of Heap Abstractions", 
    "publish": "2003-12-07T20:31:23Z", 
    "summary": "Shape analysis concerns the problem of determining \"shape invariants\" for\nprograms that perform destructive updating on dynamically allocated storage. In\nrecent work, we have shown how shape analysis can be performed, using an\nabstract interpretation based on 3-valued first-order logic. In that work,\nconcrete stores are finite 2-valued logical structures, and the sets of stores\nthat can possibly arise during execution are represented (conservatively) using\na certain family of finite 3-valued logical structures. In this paper, we show\nhow 3-valued structures that arise in shape analysis can be characterized using\nformulas in first-order logic with transitive closure.\n  We also define a non-standard (\"supervaluational\") semantics for 3-valued\nfirst-order logic that is more precise than a conventional 3-valued semantics,\nand demonstrate that the supervaluational semantics can be effectively\nimplemented using existing theorem provers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312014v3", 
    "other_authors": [
        "G. Yorsh", 
        "T. Reps", 
        "M. Sagiv", 
        "R. Wilhelm"
    ], 
    "lead_author": "R. Wilhelm", 
    "arxiv-id": "cs/0312014v3", 
    "title": "Logical Characterizations of Heap Abstractions", 
    "publish": "2003-12-07T20:31:23Z", 
    "summary": "Shape analysis concerns the problem of determining \"shape invariants\" for\nprograms that perform destructive updating on dynamically allocated storage. In\nrecent work, we have shown how shape analysis can be performed, using an\nabstract interpretation based on 3-valued first-order logic. In that work,\nconcrete stores are finite 2-valued logical structures, and the sets of stores\nthat can possibly arise during execution are represented (conservatively) using\na certain family of finite 3-valued logical structures. In this paper, we show\nhow 3-valued structures that arise in shape analysis can be characterized using\nformulas in first-order logic with transitive closure.\n  We also define a non-standard (\"supervaluational\") semantics for 3-valued\nfirst-order logic that is more precise than a conventional 3-valued semantics,\nand demonstrate that the supervaluational semantics can be effectively\nimplemented using existing theorem provers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312014v3", 
    "other_authors": [
        "G. Yorsh", 
        "T. Reps", 
        "M. Sagiv", 
        "R. Wilhelm"
    ], 
    "lead_author": "R. Wilhelm", 
    "arxiv-id": "cs/0312014v3", 
    "title": "Logical Characterizations of Heap Abstractions", 
    "publish": "2003-12-07T20:31:23Z", 
    "summary": "Shape analysis concerns the problem of determining \"shape invariants\" for\nprograms that perform destructive updating on dynamically allocated storage. In\nrecent work, we have shown how shape analysis can be performed, using an\nabstract interpretation based on 3-valued first-order logic. In that work,\nconcrete stores are finite 2-valued logical structures, and the sets of stores\nthat can possibly arise during execution are represented (conservatively) using\na certain family of finite 3-valued logical structures. In this paper, we show\nhow 3-valued structures that arise in shape analysis can be characterized using\nformulas in first-order logic with transitive closure.\n  We also define a non-standard (\"supervaluational\") semantics for 3-valued\nfirst-order logic that is more precise than a conventional 3-valued semantics,\nand demonstrate that the supervaluational semantics can be effectively\nimplemented using existing theorem provers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312014v3", 
    "other_authors": [
        "G. Yorsh", 
        "T. Reps", 
        "M. Sagiv", 
        "R. Wilhelm"
    ], 
    "lead_author": "R. Wilhelm", 
    "arxiv-id": "cs/0312014v3", 
    "title": "Logical Characterizations of Heap Abstractions", 
    "publish": "2003-12-07T20:31:23Z", 
    "summary": "Shape analysis concerns the problem of determining \"shape invariants\" for\nprograms that perform destructive updating on dynamically allocated storage. In\nrecent work, we have shown how shape analysis can be performed, using an\nabstract interpretation based on 3-valued first-order logic. In that work,\nconcrete stores are finite 2-valued logical structures, and the sets of stores\nthat can possibly arise during execution are represented (conservatively) using\na certain family of finite 3-valued logical structures. In this paper, we show\nhow 3-valued structures that arise in shape analysis can be characterized using\nformulas in first-order logic with transitive closure.\n  We also define a non-standard (\"supervaluational\") semantics for 3-valued\nfirst-order logic that is more precise than a conventional 3-valued semantics,\nand demonstrate that the supervaluational semantics can be effectively\nimplemented using existing theorem provers."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312019v1", 
    "other_authors": [
        "Laura Bozzelli", 
        "Massimo Benerecetti", 
        "Adriano Peron"
    ], 
    "lead_author": "Laura Bozzelli", 
    "arxiv-id": "cs/0312019v1", 
    "title": "Verification of recursive parallel systems", 
    "publish": "2003-12-11T14:54:06Z", 
    "summary": "In this paper we consider the problem of proving properties of infinite\nbehaviour of formalisms suitable to describe (infinite state) systems with\nrecursion and parallelism. As a formal setting, we consider the framework of\nProcess Rewriting Systems (PRSs). For a meaningfull fragment of PRSs, allowing\nto accommodate both Pushdown Automata and Petri Nets, we state decidability\nresults for a class of properties about infinite derivations (infinite term\nrewritings). The given results can be exploited for the automatic verification\nof some classes of linear time properties of infinite state systems described\nby PRSs. In order to exemplify the assessed results, we introduce a meaningful\nautomaton based formalism which allows to express both recursion and\nmulti--treading."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312019v1", 
    "other_authors": [
        "Laura Bozzelli", 
        "Massimo Benerecetti", 
        "Adriano Peron"
    ], 
    "lead_author": "Laura Bozzelli", 
    "arxiv-id": "cs/0312019v1", 
    "title": "Verification of recursive parallel systems", 
    "publish": "2003-12-11T14:54:06Z", 
    "summary": "In this paper we consider the problem of proving properties of infinite\nbehaviour of formalisms suitable to describe (infinite state) systems with\nrecursion and parallelism. As a formal setting, we consider the framework of\nProcess Rewriting Systems (PRSs). For a meaningfull fragment of PRSs, allowing\nto accommodate both Pushdown Automata and Petri Nets, we state decidability\nresults for a class of properties about infinite derivations (infinite term\nrewritings). The given results can be exploited for the automatic verification\nof some classes of linear time properties of infinite state systems described\nby PRSs. In order to exemplify the assessed results, we introduce a meaningful\nautomaton based formalism which allows to express both recursion and\nmulti--treading."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312019v1", 
    "other_authors": [
        "Laura Bozzelli", 
        "Massimo Benerecetti", 
        "Adriano Peron"
    ], 
    "lead_author": "Laura Bozzelli", 
    "arxiv-id": "cs/0312019v1", 
    "title": "Verification of recursive parallel systems", 
    "publish": "2003-12-11T14:54:06Z", 
    "summary": "In this paper we consider the problem of proving properties of infinite\nbehaviour of formalisms suitable to describe (infinite state) systems with\nrecursion and parallelism. As a formal setting, we consider the framework of\nProcess Rewriting Systems (PRSs). For a meaningfull fragment of PRSs, allowing\nto accommodate both Pushdown Automata and Petri Nets, we state decidability\nresults for a class of properties about infinite derivations (infinite term\nrewritings). The given results can be exploited for the automatic verification\nof some classes of linear time properties of infinite state systems described\nby PRSs. In order to exemplify the assessed results, we introduce a meaningful\nautomaton based formalism which allows to express both recursion and\nmulti--treading."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312019v1", 
    "other_authors": [
        "Laura Bozzelli", 
        "Massimo Benerecetti", 
        "Adriano Peron"
    ], 
    "lead_author": "Laura Bozzelli", 
    "arxiv-id": "cs/0312019v1", 
    "title": "Verification of recursive parallel systems", 
    "publish": "2003-12-11T14:54:06Z", 
    "summary": "In this paper we consider the problem of proving properties of infinite\nbehaviour of formalisms suitable to describe (infinite state) systems with\nrecursion and parallelism. As a formal setting, we consider the framework of\nProcess Rewriting Systems (PRSs). For a meaningfull fragment of PRSs, allowing\nto accommodate both Pushdown Automata and Petri Nets, we state decidability\nresults for a class of properties about infinite derivations (infinite term\nrewritings). The given results can be exploited for the automatic verification\nof some classes of linear time properties of infinite state systems described\nby PRSs. In order to exemplify the assessed results, we introduce a meaningful\nautomaton based formalism which allows to express both recursion and\nmulti--treading."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312019v1", 
    "other_authors": [
        "Laura Bozzelli", 
        "Massimo Benerecetti", 
        "Adriano Peron"
    ], 
    "lead_author": "Laura Bozzelli", 
    "arxiv-id": "cs/0312019v1", 
    "title": "Verification of recursive parallel systems", 
    "publish": "2003-12-11T14:54:06Z", 
    "summary": "In this paper we consider the problem of proving properties of infinite\nbehaviour of formalisms suitable to describe (infinite state) systems with\nrecursion and parallelism. As a formal setting, we consider the framework of\nProcess Rewriting Systems (PRSs). For a meaningfull fragment of PRSs, allowing\nto accommodate both Pushdown Automata and Petri Nets, we state decidability\nresults for a class of properties about infinite derivations (infinite term\nrewritings). The given results can be exploited for the automatic verification\nof some classes of linear time properties of infinite state systems described\nby PRSs. In order to exemplify the assessed results, we introduce a meaningful\nautomaton based formalism which allows to express both recursion and\nmulti--treading."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312019v1", 
    "other_authors": [
        "Laura Bozzelli", 
        "Massimo Benerecetti", 
        "Adriano Peron"
    ], 
    "lead_author": "Laura Bozzelli", 
    "arxiv-id": "cs/0312019v1", 
    "title": "Verification of recursive parallel systems", 
    "publish": "2003-12-11T14:54:06Z", 
    "summary": "In this paper we consider the problem of proving properties of infinite\nbehaviour of formalisms suitable to describe (infinite state) systems with\nrecursion and parallelism. As a formal setting, we consider the framework of\nProcess Rewriting Systems (PRSs). For a meaningfull fragment of PRSs, allowing\nto accommodate both Pushdown Automata and Petri Nets, we state decidability\nresults for a class of properties about infinite derivations (infinite term\nrewritings). The given results can be exploited for the automatic verification\nof some classes of linear time properties of infinite state systems described\nby PRSs. In order to exemplify the assessed results, we introduce a meaningful\nautomaton based formalism which allows to express both recursion and\nmulti--treading."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312019v1", 
    "other_authors": [
        "Laura Bozzelli", 
        "Massimo Benerecetti", 
        "Adriano Peron"
    ], 
    "lead_author": "Laura Bozzelli", 
    "arxiv-id": "cs/0312019v1", 
    "title": "Verification of recursive parallel systems", 
    "publish": "2003-12-11T14:54:06Z", 
    "summary": "In this paper we consider the problem of proving properties of infinite\nbehaviour of formalisms suitable to describe (infinite state) systems with\nrecursion and parallelism. As a formal setting, we consider the framework of\nProcess Rewriting Systems (PRSs). For a meaningfull fragment of PRSs, allowing\nto accommodate both Pushdown Automata and Petri Nets, we state decidability\nresults for a class of properties about infinite derivations (infinite term\nrewritings). The given results can be exploited for the automatic verification\nof some classes of linear time properties of infinite state systems described\nby PRSs. In order to exemplify the assessed results, we introduce a meaningful\nautomaton based formalism which allows to express both recursion and\nmulti--treading."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312019v1", 
    "other_authors": [
        "Laura Bozzelli", 
        "Massimo Benerecetti", 
        "Adriano Peron"
    ], 
    "lead_author": "Laura Bozzelli", 
    "arxiv-id": "cs/0312019v1", 
    "title": "Verification of recursive parallel systems", 
    "publish": "2003-12-11T14:54:06Z", 
    "summary": "In this paper we consider the problem of proving properties of infinite\nbehaviour of formalisms suitable to describe (infinite state) systems with\nrecursion and parallelism. As a formal setting, we consider the framework of\nProcess Rewriting Systems (PRSs). For a meaningfull fragment of PRSs, allowing\nto accommodate both Pushdown Automata and Petri Nets, we state decidability\nresults for a class of properties about infinite derivations (infinite term\nrewritings). The given results can be exploited for the automatic verification\nof some classes of linear time properties of infinite state systems described\nby PRSs. In order to exemplify the assessed results, we introduce a meaningful\nautomaton based formalism which allows to express both recursion and\nmulti--treading."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312019v1", 
    "other_authors": [
        "Laura Bozzelli", 
        "Massimo Benerecetti", 
        "Adriano Peron"
    ], 
    "lead_author": "Laura Bozzelli", 
    "arxiv-id": "cs/0312019v1", 
    "title": "Verification of recursive parallel systems", 
    "publish": "2003-12-11T14:54:06Z", 
    "summary": "In this paper we consider the problem of proving properties of infinite\nbehaviour of formalisms suitable to describe (infinite state) systems with\nrecursion and parallelism. As a formal setting, we consider the framework of\nProcess Rewriting Systems (PRSs). For a meaningfull fragment of PRSs, allowing\nto accommodate both Pushdown Automata and Petri Nets, we state decidability\nresults for a class of properties about infinite derivations (infinite term\nrewritings). The given results can be exploited for the automatic verification\nof some classes of linear time properties of infinite state systems described\nby PRSs. In order to exemplify the assessed results, we introduce a meaningful\nautomaton based formalism which allows to express both recursion and\nmulti--treading."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312019v1", 
    "other_authors": [
        "Laura Bozzelli", 
        "Massimo Benerecetti", 
        "Adriano Peron"
    ], 
    "lead_author": "Laura Bozzelli", 
    "arxiv-id": "cs/0312019v1", 
    "title": "Verification of recursive parallel systems", 
    "publish": "2003-12-11T14:54:06Z", 
    "summary": "In this paper we consider the problem of proving properties of infinite\nbehaviour of formalisms suitable to describe (infinite state) systems with\nrecursion and parallelism. As a formal setting, we consider the framework of\nProcess Rewriting Systems (PRSs). For a meaningfull fragment of PRSs, allowing\nto accommodate both Pushdown Automata and Petri Nets, we state decidability\nresults for a class of properties about infinite derivations (infinite term\nrewritings). The given results can be exploited for the automatic verification\nof some classes of linear time properties of infinite state systems described\nby PRSs. In order to exemplify the assessed results, we introduce a meaningful\nautomaton based formalism which allows to express both recursion and\nmulti--treading."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312019v1", 
    "other_authors": [
        "Laura Bozzelli", 
        "Massimo Benerecetti", 
        "Adriano Peron"
    ], 
    "lead_author": "Massimo Benerecetti", 
    "arxiv-id": "cs/0312019v1", 
    "title": "Verification of recursive parallel systems", 
    "publish": "2003-12-11T14:54:06Z", 
    "summary": "In this paper we consider the problem of proving properties of infinite\nbehaviour of formalisms suitable to describe (infinite state) systems with\nrecursion and parallelism. As a formal setting, we consider the framework of\nProcess Rewriting Systems (PRSs). For a meaningfull fragment of PRSs, allowing\nto accommodate both Pushdown Automata and Petri Nets, we state decidability\nresults for a class of properties about infinite derivations (infinite term\nrewritings). The given results can be exploited for the automatic verification\nof some classes of linear time properties of infinite state systems described\nby PRSs. In order to exemplify the assessed results, we introduce a meaningful\nautomaton based formalism which allows to express both recursion and\nmulti--treading."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312019v1", 
    "other_authors": [
        "Laura Bozzelli", 
        "Massimo Benerecetti", 
        "Adriano Peron"
    ], 
    "lead_author": "Massimo Benerecetti", 
    "arxiv-id": "cs/0312019v1", 
    "title": "Verification of recursive parallel systems", 
    "publish": "2003-12-11T14:54:06Z", 
    "summary": "In this paper we consider the problem of proving properties of infinite\nbehaviour of formalisms suitable to describe (infinite state) systems with\nrecursion and parallelism. As a formal setting, we consider the framework of\nProcess Rewriting Systems (PRSs). For a meaningfull fragment of PRSs, allowing\nto accommodate both Pushdown Automata and Petri Nets, we state decidability\nresults for a class of properties about infinite derivations (infinite term\nrewritings). The given results can be exploited for the automatic verification\nof some classes of linear time properties of infinite state systems described\nby PRSs. In order to exemplify the assessed results, we introduce a meaningful\nautomaton based formalism which allows to express both recursion and\nmulti--treading."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312019v1", 
    "other_authors": [
        "Laura Bozzelli", 
        "Massimo Benerecetti", 
        "Adriano Peron"
    ], 
    "lead_author": "Massimo Benerecetti", 
    "arxiv-id": "cs/0312019v1", 
    "title": "Verification of recursive parallel systems", 
    "publish": "2003-12-11T14:54:06Z", 
    "summary": "In this paper we consider the problem of proving properties of infinite\nbehaviour of formalisms suitable to describe (infinite state) systems with\nrecursion and parallelism. As a formal setting, we consider the framework of\nProcess Rewriting Systems (PRSs). For a meaningfull fragment of PRSs, allowing\nto accommodate both Pushdown Automata and Petri Nets, we state decidability\nresults for a class of properties about infinite derivations (infinite term\nrewritings). The given results can be exploited for the automatic verification\nof some classes of linear time properties of infinite state systems described\nby PRSs. In order to exemplify the assessed results, we introduce a meaningful\nautomaton based formalism which allows to express both recursion and\nmulti--treading."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312019v1", 
    "other_authors": [
        "Laura Bozzelli", 
        "Massimo Benerecetti", 
        "Adriano Peron"
    ], 
    "lead_author": "Massimo Benerecetti", 
    "arxiv-id": "cs/0312019v1", 
    "title": "Verification of recursive parallel systems", 
    "publish": "2003-12-11T14:54:06Z", 
    "summary": "In this paper we consider the problem of proving properties of infinite\nbehaviour of formalisms suitable to describe (infinite state) systems with\nrecursion and parallelism. As a formal setting, we consider the framework of\nProcess Rewriting Systems (PRSs). For a meaningfull fragment of PRSs, allowing\nto accommodate both Pushdown Automata and Petri Nets, we state decidability\nresults for a class of properties about infinite derivations (infinite term\nrewritings). The given results can be exploited for the automatic verification\nof some classes of linear time properties of infinite state systems described\nby PRSs. In order to exemplify the assessed results, we introduce a meaningful\nautomaton based formalism which allows to express both recursion and\nmulti--treading."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312019v1", 
    "other_authors": [
        "Laura Bozzelli", 
        "Massimo Benerecetti", 
        "Adriano Peron"
    ], 
    "lead_author": "Adriano Peron", 
    "arxiv-id": "cs/0312019v1", 
    "title": "Verification of recursive parallel systems", 
    "publish": "2003-12-11T14:54:06Z", 
    "summary": "In this paper we consider the problem of proving properties of infinite\nbehaviour of formalisms suitable to describe (infinite state) systems with\nrecursion and parallelism. As a formal setting, we consider the framework of\nProcess Rewriting Systems (PRSs). For a meaningfull fragment of PRSs, allowing\nto accommodate both Pushdown Automata and Petri Nets, we state decidability\nresults for a class of properties about infinite derivations (infinite term\nrewritings). The given results can be exploited for the automatic verification\nof some classes of linear time properties of infinite state systems described\nby PRSs. In order to exemplify the assessed results, we introduce a meaningful\nautomaton based formalism which allows to express both recursion and\nmulti--treading."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312019v1", 
    "other_authors": [
        "Laura Bozzelli", 
        "Massimo Benerecetti", 
        "Adriano Peron"
    ], 
    "lead_author": "Adriano Peron", 
    "arxiv-id": "cs/0312019v1", 
    "title": "Verification of recursive parallel systems", 
    "publish": "2003-12-11T14:54:06Z", 
    "summary": "In this paper we consider the problem of proving properties of infinite\nbehaviour of formalisms suitable to describe (infinite state) systems with\nrecursion and parallelism. As a formal setting, we consider the framework of\nProcess Rewriting Systems (PRSs). For a meaningfull fragment of PRSs, allowing\nto accommodate both Pushdown Automata and Petri Nets, we state decidability\nresults for a class of properties about infinite derivations (infinite term\nrewritings). The given results can be exploited for the automatic verification\nof some classes of linear time properties of infinite state systems described\nby PRSs. In order to exemplify the assessed results, we introduce a meaningful\nautomaton based formalism which allows to express both recursion and\nmulti--treading."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312019v1", 
    "other_authors": [
        "Laura Bozzelli", 
        "Massimo Benerecetti", 
        "Adriano Peron"
    ], 
    "lead_author": "Adriano Peron", 
    "arxiv-id": "cs/0312019v1", 
    "title": "Verification of recursive parallel systems", 
    "publish": "2003-12-11T14:54:06Z", 
    "summary": "In this paper we consider the problem of proving properties of infinite\nbehaviour of formalisms suitable to describe (infinite state) systems with\nrecursion and parallelism. As a formal setting, we consider the framework of\nProcess Rewriting Systems (PRSs). For a meaningfull fragment of PRSs, allowing\nto accommodate both Pushdown Automata and Petri Nets, we state decidability\nresults for a class of properties about infinite derivations (infinite term\nrewritings). The given results can be exploited for the automatic verification\nof some classes of linear time properties of infinite state systems described\nby PRSs. In order to exemplify the assessed results, we introduce a meaningful\nautomaton based formalism which allows to express both recursion and\nmulti--treading."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312019v1", 
    "other_authors": [
        "Laura Bozzelli", 
        "Massimo Benerecetti", 
        "Adriano Peron"
    ], 
    "lead_author": "Adriano Peron", 
    "arxiv-id": "cs/0312019v1", 
    "title": "Verification of recursive parallel systems", 
    "publish": "2003-12-11T14:54:06Z", 
    "summary": "In this paper we consider the problem of proving properties of infinite\nbehaviour of formalisms suitable to describe (infinite state) systems with\nrecursion and parallelism. As a formal setting, we consider the framework of\nProcess Rewriting Systems (PRSs). For a meaningfull fragment of PRSs, allowing\nto accommodate both Pushdown Automata and Petri Nets, we state decidability\nresults for a class of properties about infinite derivations (infinite term\nrewritings). The given results can be exploited for the automatic verification\nof some classes of linear time properties of infinite state systems described\nby PRSs. In order to exemplify the assessed results, we introduce a meaningful\nautomaton based formalism which allows to express both recursion and\nmulti--treading."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312019v1", 
    "other_authors": [
        "Laura Bozzelli", 
        "Massimo Benerecetti", 
        "Adriano Peron"
    ], 
    "lead_author": "Adriano Peron", 
    "arxiv-id": "cs/0312019v1", 
    "title": "Verification of recursive parallel systems", 
    "publish": "2003-12-11T14:54:06Z", 
    "summary": "In this paper we consider the problem of proving properties of infinite\nbehaviour of formalisms suitable to describe (infinite state) systems with\nrecursion and parallelism. As a formal setting, we consider the framework of\nProcess Rewriting Systems (PRSs). For a meaningfull fragment of PRSs, allowing\nto accommodate both Pushdown Automata and Petri Nets, we state decidability\nresults for a class of properties about infinite derivations (infinite term\nrewritings). The given results can be exploited for the automatic verification\nof some classes of linear time properties of infinite state systems described\nby PRSs. In order to exemplify the assessed results, we introduce a meaningful\nautomaton based formalism which allows to express both recursion and\nmulti--treading."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312019v1", 
    "other_authors": [
        "Laura Bozzelli", 
        "Massimo Benerecetti", 
        "Adriano Peron"
    ], 
    "lead_author": "Adriano Peron", 
    "arxiv-id": "cs/0312019v1", 
    "title": "Verification of recursive parallel systems", 
    "publish": "2003-12-11T14:54:06Z", 
    "summary": "In this paper we consider the problem of proving properties of infinite\nbehaviour of formalisms suitable to describe (infinite state) systems with\nrecursion and parallelism. As a formal setting, we consider the framework of\nProcess Rewriting Systems (PRSs). For a meaningfull fragment of PRSs, allowing\nto accommodate both Pushdown Automata and Petri Nets, we state decidability\nresults for a class of properties about infinite derivations (infinite term\nrewritings). The given results can be exploited for the automatic verification\nof some classes of linear time properties of infinite state systems described\nby PRSs. In order to exemplify the assessed results, we introduce a meaningful\nautomaton based formalism which allows to express both recursion and\nmulti--treading."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312019v1", 
    "other_authors": [
        "Laura Bozzelli", 
        "Massimo Benerecetti", 
        "Adriano Peron"
    ], 
    "lead_author": "Adriano Peron", 
    "arxiv-id": "cs/0312019v1", 
    "title": "Verification of recursive parallel systems", 
    "publish": "2003-12-11T14:54:06Z", 
    "summary": "In this paper we consider the problem of proving properties of infinite\nbehaviour of formalisms suitable to describe (infinite state) systems with\nrecursion and parallelism. As a formal setting, we consider the framework of\nProcess Rewriting Systems (PRSs). For a meaningfull fragment of PRSs, allowing\nto accommodate both Pushdown Automata and Petri Nets, we state decidability\nresults for a class of properties about infinite derivations (infinite term\nrewritings). The given results can be exploited for the automatic verification\nof some classes of linear time properties of infinite state systems described\nby PRSs. In order to exemplify the assessed results, we introduce a meaningful\nautomaton based formalism which allows to express both recursion and\nmulti--treading."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312019v1", 
    "other_authors": [
        "Laura Bozzelli", 
        "Massimo Benerecetti", 
        "Adriano Peron"
    ], 
    "lead_author": "Adriano Peron", 
    "arxiv-id": "cs/0312019v1", 
    "title": "Verification of recursive parallel systems", 
    "publish": "2003-12-11T14:54:06Z", 
    "summary": "In this paper we consider the problem of proving properties of infinite\nbehaviour of formalisms suitable to describe (infinite state) systems with\nrecursion and parallelism. As a formal setting, we consider the framework of\nProcess Rewriting Systems (PRSs). For a meaningfull fragment of PRSs, allowing\nto accommodate both Pushdown Automata and Petri Nets, we state decidability\nresults for a class of properties about infinite derivations (infinite term\nrewritings). The given results can be exploited for the automatic verification\nof some classes of linear time properties of infinite state systems described\nby PRSs. In order to exemplify the assessed results, we introduce a meaningful\nautomaton based formalism which allows to express both recursion and\nmulti--treading."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312019v1", 
    "other_authors": [
        "Laura Bozzelli", 
        "Massimo Benerecetti", 
        "Adriano Peron"
    ], 
    "lead_author": "Adriano Peron", 
    "arxiv-id": "cs/0312019v1", 
    "title": "Verification of recursive parallel systems", 
    "publish": "2003-12-11T14:54:06Z", 
    "summary": "In this paper we consider the problem of proving properties of infinite\nbehaviour of formalisms suitable to describe (infinite state) systems with\nrecursion and parallelism. As a formal setting, we consider the framework of\nProcess Rewriting Systems (PRSs). For a meaningfull fragment of PRSs, allowing\nto accommodate both Pushdown Automata and Petri Nets, we state decidability\nresults for a class of properties about infinite derivations (infinite term\nrewritings). The given results can be exploited for the automatic verification\nof some classes of linear time properties of infinite state systems described\nby PRSs. In order to exemplify the assessed results, we introduce a meaningful\nautomaton based formalism which allows to express both recursion and\nmulti--treading."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312019v1", 
    "other_authors": [
        "Laura Bozzelli", 
        "Massimo Benerecetti", 
        "Adriano Peron"
    ], 
    "lead_author": "Adriano Peron", 
    "arxiv-id": "cs/0312019v1", 
    "title": "Verification of recursive parallel systems", 
    "publish": "2003-12-11T14:54:06Z", 
    "summary": "In this paper we consider the problem of proving properties of infinite\nbehaviour of formalisms suitable to describe (infinite state) systems with\nrecursion and parallelism. As a formal setting, we consider the framework of\nProcess Rewriting Systems (PRSs). For a meaningfull fragment of PRSs, allowing\nto accommodate both Pushdown Automata and Petri Nets, we state decidability\nresults for a class of properties about infinite derivations (infinite term\nrewritings). The given results can be exploited for the automatic verification\nof some classes of linear time properties of infinite state systems described\nby PRSs. In order to exemplify the assessed results, we introduce a meaningful\nautomaton based formalism which allows to express both recursion and\nmulti--treading."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312019v1", 
    "other_authors": [
        "Laura Bozzelli", 
        "Massimo Benerecetti", 
        "Adriano Peron"
    ], 
    "lead_author": "Adriano Peron", 
    "arxiv-id": "cs/0312019v1", 
    "title": "Verification of recursive parallel systems", 
    "publish": "2003-12-11T14:54:06Z", 
    "summary": "In this paper we consider the problem of proving properties of infinite\nbehaviour of formalisms suitable to describe (infinite state) systems with\nrecursion and parallelism. As a formal setting, we consider the framework of\nProcess Rewriting Systems (PRSs). For a meaningfull fragment of PRSs, allowing\nto accommodate both Pushdown Automata and Petri Nets, we state decidability\nresults for a class of properties about infinite derivations (infinite term\nrewritings). The given results can be exploited for the automatic verification\nof some classes of linear time properties of infinite state systems described\nby PRSs. In order to exemplify the assessed results, we introduce a meaningful\nautomaton based formalism which allows to express both recursion and\nmulti--treading."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312032v1", 
    "other_authors": [
        "Anja Remshagen", 
        "Klaus Truemper"
    ], 
    "lead_author": "Anja Remshagen", 
    "arxiv-id": "cs/0312032v1", 
    "title": "Learning in a Compiler for MINSAT Algorithms", 
    "publish": "2003-12-16T17:24:18Z", 
    "summary": "This paper describes learning in a compiler for algorithms solving classes of\nthe logic minimization problem MINSAT, where the underlying propositional\nformula is in conjunctive normal form (CNF) and where costs are associated with\nthe True/False values of the variables. Each class consists of all instances\nthat may be derived from a given propositional formula and costs for True/False\nvalues by fixing or deleting variables, and by deleting clauses. The learning\nstep begins once the compiler has constructed a solution algorithm for a given\nclass. The step applies that algorithm to comparatively few instances of the\nclass, analyses the performance of the algorithm on these instances, and\nmodifies the underlying propositional formula, with the goal that the algorithm\nwill perform much better on all instances of the class."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312032v1", 
    "other_authors": [
        "Anja Remshagen", 
        "Klaus Truemper"
    ], 
    "lead_author": "Anja Remshagen", 
    "arxiv-id": "cs/0312032v1", 
    "title": "Learning in a Compiler for MINSAT Algorithms", 
    "publish": "2003-12-16T17:24:18Z", 
    "summary": "This paper describes learning in a compiler for algorithms solving classes of\nthe logic minimization problem MINSAT, where the underlying propositional\nformula is in conjunctive normal form (CNF) and where costs are associated with\nthe True/False values of the variables. Each class consists of all instances\nthat may be derived from a given propositional formula and costs for True/False\nvalues by fixing or deleting variables, and by deleting clauses. The learning\nstep begins once the compiler has constructed a solution algorithm for a given\nclass. The step applies that algorithm to comparatively few instances of the\nclass, analyses the performance of the algorithm on these instances, and\nmodifies the underlying propositional formula, with the goal that the algorithm\nwill perform much better on all instances of the class."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312032v1", 
    "other_authors": [
        "Anja Remshagen", 
        "Klaus Truemper"
    ], 
    "lead_author": "Klaus Truemper", 
    "arxiv-id": "cs/0312032v1", 
    "title": "Learning in a Compiler for MINSAT Algorithms", 
    "publish": "2003-12-16T17:24:18Z", 
    "summary": "This paper describes learning in a compiler for algorithms solving classes of\nthe logic minimization problem MINSAT, where the underlying propositional\nformula is in conjunctive normal form (CNF) and where costs are associated with\nthe True/False values of the variables. Each class consists of all instances\nthat may be derived from a given propositional formula and costs for True/False\nvalues by fixing or deleting variables, and by deleting clauses. The learning\nstep begins once the compiler has constructed a solution algorithm for a given\nclass. The step applies that algorithm to comparatively few instances of the\nclass, analyses the performance of the algorithm on these instances, and\nmodifies the underlying propositional formula, with the goal that the algorithm\nwill perform much better on all instances of the class."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312032v1", 
    "other_authors": [
        "Anja Remshagen", 
        "Klaus Truemper"
    ], 
    "lead_author": "Klaus Truemper", 
    "arxiv-id": "cs/0312032v1", 
    "title": "Learning in a Compiler for MINSAT Algorithms", 
    "publish": "2003-12-16T17:24:18Z", 
    "summary": "This paper describes learning in a compiler for algorithms solving classes of\nthe logic minimization problem MINSAT, where the underlying propositional\nformula is in conjunctive normal form (CNF) and where costs are associated with\nthe True/False values of the variables. Each class consists of all instances\nthat may be derived from a given propositional formula and costs for True/False\nvalues by fixing or deleting variables, and by deleting clauses. The learning\nstep begins once the compiler has constructed a solution algorithm for a given\nclass. The step applies that algorithm to comparatively few instances of the\nclass, analyses the performance of the algorithm on these instances, and\nmodifies the underlying propositional formula, with the goal that the algorithm\nwill perform much better on all instances of the class."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0312032v1", 
    "other_authors": [
        "Anja Remshagen", 
        "Klaus Truemper"
    ], 
    "lead_author": "Klaus Truemper", 
    "arxiv-id": "cs/0312032v1", 
    "title": "Learning in a Compiler for MINSAT Algorithms", 
    "publish": "2003-12-16T17:24:18Z", 
    "summary": "This paper describes learning in a compiler for algorithms solving classes of\nthe logic minimization problem MINSAT, where the underlying propositional\nformula is in conjunctive normal form (CNF) and where costs are associated with\nthe True/False values of the variables. Each class consists of all instances\nthat may be derived from a given propositional formula and costs for True/False\nvalues by fixing or deleting variables, and by deleting clauses. The learning\nstep begins once the compiler has constructed a solution algorithm for a given\nclass. The step applies that algorithm to comparatively few instances of the\nclass, analyses the performance of the algorithm on these instances, and\nmodifies the underlying propositional formula, with the goal that the algorithm\nwill perform much better on all instances of the class."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0402002v1", 
    "other_authors": [
        "Ofer Strichman"
    ], 
    "lead_author": "Ofer Strichman", 
    "arxiv-id": "cs/0402002v1", 
    "title": "Deciding Disjunctive Linear Arithmetic with SAT", 
    "publish": "2004-02-01T12:42:20Z", 
    "summary": "Disjunctive Linear Arithmetic (DLA) is a major decidable theory that is\nsupported by almost all existing theorem provers. The theory consists of\nBoolean combinations of predicates of the form $\\Sigma_{j=1}^{n}a_j\\cdot x_j\n\\le b$, where the coefficients $a_j$, the bound $b$ and the variables $x_1 >...\nx_n$ are of type Real ($\\mathbb{R}$). We show a reduction to propositional\nlogic from disjunctive linear arithmetic based on Fourier-Motzkin elimination.\nWhile the complexity of this procedure is not better than competing techniques,\nit has practical advantages in solving verification problems. It also promotes\nthe option of deciding a combination of theories by reducing them to this\nlogic. Results from experiments show that this method has a strong advantage\nover existing techniques when there are many disjunctions in the formula."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0402010v1", 
    "other_authors": [
        "Olga Shumsky Matlin", 
        "William McCune"
    ], 
    "lead_author": "William McCune", 
    "arxiv-id": "cs/0402010v1", 
    "title": "Encapsulation for Practical Simplification Procedures", 
    "publish": "2004-02-03T19:04:02Z", 
    "summary": "ACL2 was used to prove properties of two simplification procedures. The\nprocedures differ in complexity but solve the same programming problem that\narises in the context of a resolution/paramodulation theorem proving system.\nTerm rewriting is at the core of the two procedures, but details of the\nrewriting procedure itself are irrelevant. The ACL2 encapsulate construct was\nused to assert the existence of the rewriting function and to state some of its\nproperties. Termination, irreducibility, and soundness properties were\nestablished for each procedure. The availability of the encapsulation mechanism\nin ACL2 is considered essential to rapid and efficient verification of this\nkind of algorithm."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0402010v1", 
    "other_authors": [
        "Olga Shumsky Matlin", 
        "William McCune"
    ], 
    "lead_author": "William McCune", 
    "arxiv-id": "cs/0402010v1", 
    "title": "Encapsulation for Practical Simplification Procedures", 
    "publish": "2004-02-03T19:04:02Z", 
    "summary": "ACL2 was used to prove properties of two simplification procedures. The\nprocedures differ in complexity but solve the same programming problem that\narises in the context of a resolution/paramodulation theorem proving system.\nTerm rewriting is at the core of the two procedures, but details of the\nrewriting procedure itself are irrelevant. The ACL2 encapsulate construct was\nused to assert the existence of the rewriting function and to state some of its\nproperties. Termination, irreducibility, and soundness properties were\nestablished for each procedure. The availability of the encapsulation mechanism\nin ACL2 is considered essential to rapid and efficient verification of this\nkind of algorithm."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0402010v1", 
    "other_authors": [
        "Olga Shumsky Matlin", 
        "William McCune"
    ], 
    "lead_author": "William McCune", 
    "arxiv-id": "cs/0402010v1", 
    "title": "Encapsulation for Practical Simplification Procedures", 
    "publish": "2004-02-03T19:04:02Z", 
    "summary": "ACL2 was used to prove properties of two simplification procedures. The\nprocedures differ in complexity but solve the same programming problem that\narises in the context of a resolution/paramodulation theorem proving system.\nTerm rewriting is at the core of the two procedures, but details of the\nrewriting procedure itself are irrelevant. The ACL2 encapsulate construct was\nused to assert the existence of the rewriting function and to state some of its\nproperties. Termination, irreducibility, and soundness properties were\nestablished for each procedure. The availability of the encapsulation mechanism\nin ACL2 is considered essential to rapid and efficient verification of this\nkind of algorithm."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0402010v1", 
    "other_authors": [
        "Olga Shumsky Matlin", 
        "William McCune"
    ], 
    "lead_author": "William McCune", 
    "arxiv-id": "cs/0402010v1", 
    "title": "Encapsulation for Practical Simplification Procedures", 
    "publish": "2004-02-03T19:04:02Z", 
    "summary": "ACL2 was used to prove properties of two simplification procedures. The\nprocedures differ in complexity but solve the same programming problem that\narises in the context of a resolution/paramodulation theorem proving system.\nTerm rewriting is at the core of the two procedures, but details of the\nrewriting procedure itself are irrelevant. The ACL2 encapsulate construct was\nused to assert the existence of the rewriting function and to state some of its\nproperties. Termination, irreducibility, and soundness properties were\nestablished for each procedure. The availability of the encapsulation mechanism\nin ACL2 is considered essential to rapid and efficient verification of this\nkind of algorithm."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0402010v1", 
    "other_authors": [
        "Olga Shumsky Matlin", 
        "William McCune"
    ], 
    "lead_author": "William McCune", 
    "arxiv-id": "cs/0402010v1", 
    "title": "Encapsulation for Practical Simplification Procedures", 
    "publish": "2004-02-03T19:04:02Z", 
    "summary": "ACL2 was used to prove properties of two simplification procedures. The\nprocedures differ in complexity but solve the same programming problem that\narises in the context of a resolution/paramodulation theorem proving system.\nTerm rewriting is at the core of the two procedures, but details of the\nrewriting procedure itself are irrelevant. The ACL2 encapsulate construct was\nused to assert the existence of the rewriting function and to state some of its\nproperties. Termination, irreducibility, and soundness properties were\nestablished for each procedure. The availability of the encapsulation mechanism\nin ACL2 is considered essential to rapid and efficient verification of this\nkind of algorithm."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0402010v1", 
    "other_authors": [
        "Olga Shumsky Matlin", 
        "William McCune"
    ], 
    "lead_author": "William McCune", 
    "arxiv-id": "cs/0402010v1", 
    "title": "Encapsulation for Practical Simplification Procedures", 
    "publish": "2004-02-03T19:04:02Z", 
    "summary": "ACL2 was used to prove properties of two simplification procedures. The\nprocedures differ in complexity but solve the same programming problem that\narises in the context of a resolution/paramodulation theorem proving system.\nTerm rewriting is at the core of the two procedures, but details of the\nrewriting procedure itself are irrelevant. The ACL2 encapsulate construct was\nused to assert the existence of the rewriting function and to state some of its\nproperties. Termination, irreducibility, and soundness properties were\nestablished for each procedure. The availability of the encapsulation mechanism\nin ACL2 is considered essential to rapid and efficient verification of this\nkind of algorithm."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0402010v1", 
    "other_authors": [
        "Olga Shumsky Matlin", 
        "William McCune"
    ], 
    "lead_author": "William McCune", 
    "arxiv-id": "cs/0402010v1", 
    "title": "Encapsulation for Practical Simplification Procedures", 
    "publish": "2004-02-03T19:04:02Z", 
    "summary": "ACL2 was used to prove properties of two simplification procedures. The\nprocedures differ in complexity but solve the same programming problem that\narises in the context of a resolution/paramodulation theorem proving system.\nTerm rewriting is at the core of the two procedures, but details of the\nrewriting procedure itself are irrelevant. The ACL2 encapsulate construct was\nused to assert the existence of the rewriting function and to state some of its\nproperties. Termination, irreducibility, and soundness properties were\nestablished for each procedure. The availability of the encapsulation mechanism\nin ACL2 is considered essential to rapid and efficient verification of this\nkind of algorithm."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0402038v1", 
    "other_authors": [
        "Serban E. Vlad"
    ], 
    "lead_author": "Serban E. Vlad", 
    "arxiv-id": "cs/0402038v1", 
    "title": "Towards a Mathematical Theory of the Delays of the Asynchronous Circuits", 
    "publish": "2004-02-17T12:11:56Z", 
    "summary": "The inequations of the delays of the asynchronous circuits are written, by\nmaking use of pseudo-Boolean differential calculus. We consider these efforts\nto be a possible starting point in the semi-formalized reconstruction of the\ndigital electrical engineering (which is a non-formalized theory)."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0402039v1", 
    "other_authors": [
        "Serban E. Vlad"
    ], 
    "lead_author": "Serban E. Vlad", 
    "arxiv-id": "cs/0402039v1", 
    "title": "On the Inertia of the Asynchronous Circuits", 
    "publish": "2004-02-17T12:54:00Z", 
    "summary": "We present the bounded delays, the absolute inertia and the relative inertia."
},{
    "category": "cs.LO", 
    "link": "http://arxiv.org/pdf/cs/0402040v1", 
    "other_authors": [
        "Serban E. Vlad"
    ], 
    "lead_author": "Serban E. Vlad", 
    "arxiv-id": "cs/0402040v1", 
    "title": "Defining the Delays of the Asynchronous Circuits", 
    "publish": "2004-02-17T13:01:05Z", 
    "summary": "We define the delays of a circuit, as well as the properties of determinism,\norder, time invariance, constancy, symmetry and the serial connection."
}]